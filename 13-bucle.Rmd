```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```


# Estructuras de control: bucles {#bucles}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script12.R**](https://github.com/dadosdelaplace/courses-intro-R/blob/main/scripts/script12.R). Ver en <https://github.com/dadosdelaplace/courses-intro-R/blob/main/scripts/script12.R>

::::

Aunque la mayor√≠a de veces son sustituibles por otras expresiones m√°s legibles y eficientes, es importante que conozcamos otra archiconocida **expresion de control**: <mark>**los bucles**</mark>. 

* `for`: permite <mark>**repetir el mismo c√≥digo un n√∫mero fijo (y conocido a priori) de veces**</mark> (normalmente en funci√≥n de un √≠ndice).
* `while`: permite <mark>**repetir el mismo c√≥digo un n√∫mero indeterminado**</mark> de veces, hasta que una condici√≥n dada se deje de cumplir.

## for

Aunque la mayor√≠a de las veces los <mark>**bucles pueden ser sustituidos**</mark> por expresiones mucho m√°s eficientes (f√≠jate que ya hemos filtrado columnas, filas y aplicado operaciones por filas y columnas, sin necesitarlo), a veces no nos quedar√° m√°s remedio que usarlos por lo que nunca viene mal conocer su estructura.

Un <mark>**bucle `for{}`**</mark> es una estructura que nos permite <mark>**repetir un conjunto de √≥rdenes un n√∫mero finito y conocido de veces**</mark>: dado un conjunto de √≠ndices, el bucle ir√° <mark>**recorriendo cada uno de ellos**</mark>, y para cada uno ejecutar√° lo que tenga dentro de las llaves.

Veamos un ejemplo muy sencillo. Vamos a definir un vector de n√∫meros de longitud 4, por ejemplo `x <- c(0, -7, 1, 4)`. Si quisi√©ramos devolver el primer elemento al cuadrado escribir√≠amos `x[1]^2` (accedemos con `[1]` al primer elemento y lo elevamos al cuadrado). Si quisi√©ramos devolver el segundo elemento al cuadrado escribir√≠amos `x[2]^2`. Si lo quisi√©ramos hacer en general, para el elemento i-√©simo (el que ocupa la posici√≥n `i`), escribir√≠amos `x[i]^2`. Lo que haremos dentro del `for (...) {}` es indicarle que valores ir√° tomando `i`: creamos un vector de √≠ndices, en este caso `1:4`, para que `i` vaya tomando sus valores (primero `i=1`, luego `i=2`, etc)

```{r}
x <- c(0, -7, 1, 4)
for (i in 1:4) {
  
  print(x[i]^2) # que lo imprima
  
}
```

Lo que tenemos **dentro de los par√©ntesis**, en la l√≠nea del `for`, no es m√°s que la secuencia de n√∫meros que hemos aprendido a construir.

```{r}
1:4
```

Si quisi√©ramos que haga lo mismo pero excluyendo por ejemplo el segundo elemento bastar√≠a con definir los √≠ndices a recorrer como `c(1, 3, 4)` o `c(1, 3:4)`

```{r}
for (i in c(1, 3, 4)) {
  
  print(x[i]^2) # que lo imprima
  
}
```

Podemos definir tambi√©n una variable `y <- rep(0, 4)` (un vector de la misma longitud pero, de momento, lleno de ceros), y hacer que elemento i-√©simo del vector `y` se defina como `x[i]^2`

```{r}
y <- rep(0, 4)
for (i in 1:4) {
  
  y[i] <- x[i]^2
  
}

y
```

F√≠jate que, dado que las operaciones en `R` ya se hacen por defecto de forma vectorial, elemento a elemento, lo anterior es equivalente a esto

```{r}
y <- x^2
y
```

No solo es equivalente sino que adem√°s, haciendo uso del paquete `{microbenchmark}` podemos comprobar como el bucle, am√©n de no ser necesario, es <mark>**menos eficiente**</mark> (de ah√≠ que la mayor√≠a de veces los intentemos evitar si existe otra alternativa)

```{r}
# install.packages("microbenchmark)
library(microbenchmark)

# Le pasamos dos conjuntos de c√≥digos, y le indicamos con
# times el n√∫mero de simulaciones a realizar para luego obtener
# un promedio de tiempos
microbenchmark(x^2, for (i in 1:4) { y[i] <- x[i]^2 },
               times = 1000)
```

&nbsp;

Veamos otro ejemplo: vamos a **definir de nuevo un vector de edades y  nombres**, y vamos a recorrer cada uno imprimiento un mensaje por pantalla.

```{r}
library(glue)

nombres <- c("Javi", "Laura", "Carlos", "Luc√≠a", "Mar")
edades <- c(32, 51, 18, 43, 29)

# Recorremos cada uno de los 5 elementos e imprimimos un
# mensaje que depende de ese √≠ndice i
for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```


F√≠jate que si <mark>**no nos queremos preocupar de si a√±adimos**</mark> otra persona, podemos hacer que el bucle empiece en `1` y termine en el √∫ltimo lugar (sea el que sea), usando `length()`

```{r}
for (i in 1:length(nombres)) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```

Aunque normalmente el conjunto que recorre el bucle suelen ser √≠ndices num√©ricos, <mark>**podemos recorrer cualquier tipo de objeto**</mark>, por ejemplo d√≠as e la semana

```{r}
library(stringr)
dias_semana <- c("lunes", "martes", "mi√©rcoles", "jueves",
                 "viernes", "s√°bado", "domingo")

for (dias in dias_semana) { # dias recorre los d√≠as de la semana
  
  print(str_to_upper(dias)) # Imprimimos en may√∫sculas el d√≠a
}
```

Como hemos visto, adem√°s de imprimir por pantalla podemos asignar valores a variables o cambiarlas. Por ejemplo, vamos a recorrer nuestro conjunto `swiss` de `{datasets}` y vamos a pasar a dato ausente todos los valores de fertilidad superiores a 80. Para ello **recorreremos cada fila para despu√©s ejecutar un `if`**.

```{r}
for (i in 1:nrow(swiss)) {
  
  # si cumple la condici√≥n dicha fila, ponemos ausente.
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
swiss
```

Esto ser√≠a exactamente equivalente al `ifelse` vectorizado que vimos en el tema anterior

```{r}
data("swiss") # lo cargamos de 0
swiss$Fertility <- ifelse(swiss$Fertility > 80, NA, swiss$Fertility)
swiss
```

&nbsp;

¬øTe acuerdas de las operaciones por filas y columnas que hicimos con los `apply()`? Podemos hacer lo mismo (aunque menos eficiente) con un bucle: vamos a sumar las filas del conjunto `swiss`. Para ello antes definiremos una variable llena de ceros que luego rellenaremos, de tama√±o igual al n√∫mero de filas, con `suma <- rep(0, nrow(swiss))`

```{r}
suma <- rep(0, nrow(swiss))
for (i in 1:nrow(swiss)) {
  
  suma[i] <- sum(swiss[i, ])
}
suma
```

&nbsp;

## while

Otra manera de dise√±ar un bucle es con la <mark>**estructura `while{}`**</mark>, que ejecutar√° el **bucle un n√∫mero de veces pero que a priori es desconocido**, lo har√° hasta que la condici√≥n impuesta deje de ser `TRUE` (en el `for` sabemos de antemano el n√∫mero de iteraciones). Por ejemplo, vamos a inicializar una variable `ciclos <- 1`, y en cada paso aumentaremos una unidad `ciclos`, y no saldremos del bucle hasta que `ciclos > 5`

```{r}
ciclos <- 1
# Mientras el n√∫mero de ciclos sea inferior 5, imprime
while(ciclos <= 5) {
  
  print(paste("Todav√≠a no, vamos por el ciclo ", ciclos)) # Pegamos la frase al n√∫mero de ciclo por el que vayamos con paste
  ciclos <- ciclos + 1
  
}
``` 

**¬øY qu√© sucede cuando la condici√≥n nunca llega a ser `FALSE`?** Compru√©balo t√∫ mismo/a.

```{r eval = FALSE}
while (1 > 0) { # Nunca va a dejar de ser cierto
  
  print("Presiona ESC para salir del bucle")
  
}
```

## break/next

En `R` tenemos dos comandos reservados para poder <mark>**abortar un bucle**</mark> o <mark>**avanzar forzosamente un bucle**</mark>: dichas palabras son `break` y `next`. La primera nos habilita para **parar un bucle** aunque no haya llegado al final de su conjunto de √≠ndices a recorrer (o se siga cumpliendo la condici√≥n del `while{}`).

Vamos a hacer un bucle de `1` a `10`: cuando el √≠ndice `i` es igual a 7, el bucle se para.

```{r}
for(i in 1:10) {
  if (i == 7) {
    
    break # si i es 7, el bucle frena aqu√≠ (nunca llegar√° a imprimir el 7 ni los sucesivos)
    
  }
  print(i)
}
```

Mientras que la segunda, el `next` <mark>**obliga al bucle a avanzar a la siguiente interacci√≥n**</mark>, abortando la iteraci√≥n actual en la que se encuentra. Vamos ahora a hacer un bucle de `1` a `10`: cuando el √≠ndice `i` es igual a 7, el bucle salta al `i = 8`.

```{r}
for(i in 1:10) {
  if (i == 7) {
    
    next # si i es 7, la iteraci√≥n frenar√° aqu√≠ y pasar√° a la siguiente por lo que imprimir√° todos menos el 7
    
  }
  print(i)
}
```

## repeat

Aunque es una opci√≥n muy poco usada, existe una estructura de control llamada `repeat{}` que nos **ejecuta un bucle de forma infinita** hasta que le ordenemos parar con un `break`.

```{r}
conteo <- 0
repeat { 
  
  conteo <- conteo + 1
  if (conteo >= 100) { break }
  
}
conteo
``` 



&nbsp;

**`r colorize("WARNING: cuidado con los bucles infinitos", "#ffc107")`**


Las estucturas `while{}` y `repeat{}` son de las menos usadas por su peligrosidad, ya que si no incluimos un `break` o la condici√≥n nunca llega a ser `TRUE`, el bucle seguir√° ejecut√°ndose de forma infinita y solo podr√° ser detenido abortando la ejecuci√≥n con la tecla `ESC`.

&nbsp;



## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Evita bucles (si puedes)", "#20935E")`**

Recuerda: por lo general, di no a los bucles en `R` (intenta evitarlos, en la mayor√≠a de casos hay una alternativa mejor).

&nbsp;

**`r colorize("Evita bucles (parte II)", "#20935E")`**

Evita al m√°ximo los bucles en `R`: suele existir una forma m√°s eficiente de programarlo. Veamos un ejemplo muy sencillo: dado un vector de √≠ndices `idx`, queremos calcular su cuadrado y guardarlo. Vamos a comparar como ser√≠a con un sencillo bucle y de forma vectorial, repiti√©ndolo 1000 veces para sacar tiempos medios, haciendo uso del paquete `{microbenchmark}`.

```{r}
idx <- 1:10000
x <- y <- rep(0, length(idx))
microbenchmark::microbenchmark(x <- idx^2, 
                               for (i in idx) {  y[i] <- idx[i]^2},
                               times = 1e3)
``` 

Una tarea tan sencilla, **programada en un bucle (segunda fila), tarda 40 veces m√°s que hacerlo de forma vectorial (primera fila)** (elevando cada elemento al cuadrado, iterando internamente, sin necesidad de implementar un bucle).


## üìù Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: modifica el c√≥digo inferior para dise√±ar un bucle `for` de 5 iteraciones que recorra los 5 primeros impares y les sume uno.

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Una forma
for (i in seq(1, 9, by = 2)) {
  
  print(i + 1)
}

# Otra
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i + 1)
}
```

<!-- tocstop -->
</details>

```{r}
for (i in 1:5) {
  
  print(i)
}
```

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: modifica el c√≥digo inferior para dise√±ar un bucle `while` que parta con una variable `conteo <- 1` y pare cuando llegue a 6.

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
conteo <- 1
while (conteo < 6) {
  
  print(conteo)
  conteo <- conteo + 1
}
```

<!-- tocstop -->
</details>

```{r}
conteo <- 1
while (conteo == 2) {
  
  print(conteo)
}
```

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 3</strong>: construye un bucle que recorra las primeras 8 filas del conjunto de datos `datasets::airquality` y que imprima un mensaje con la temperatura

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
for (i in 1:8) {
  
  print(glue("La temperatura es de {airquality$Temp[i]}¬∫F"))
}
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 4</strong>: dise√±a un bucle `for` de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3‚Ç¨ si el n√∫mero actual es par y te reste 5‚Ç¨ si es impar. Un n√∫mero par o impar: un n√∫mero par ser√° todo aquel n√∫mero que al dividir entre 2, la divisi√≥n es exacta, es decir, que su resto es nulo. Por ejemplo, al dividir 5 entre 2, el resto es 1, pero al dividir 12 entre 2 el resto es 0. Para calcula ese resto usaremos la funci√≥n `%%`.


</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# pares e impares
5 %% 2
12 %% 2
23 %% 2
46 %% 2
```

```{r}
# dinero inicial
dinero <- 100

# Bucle for
for (i in 1:200) {
  
  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero  - 5)
  
}
dinero
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: dise√±a el anterior bucle pero guardando el dinero de cada iteraci√≥n.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# vector de importes
dinero <- rep(0, 201)
dinero[1] <- 100 # dinero inicial

# Bucle for
for (i in 2:201) {
  
  # si dinero[i - 1] es par o  impar
  dinero[i] <- ifelse(dinero[i - 1] %% 2 == 0, dinero[i - 1] + 3,
                      dinero[i - 1]  - 5)
  
}
dinero
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 6</strong>: dise√±a el bucle del ejercicio 4 parando cuando no nos quede dinero.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
dinero <- 100 # dinero inicial

# Bucle while
while (dinero > 0) {
  
  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero - 5)
  
}
dinero
```

<!-- tocstop -->
</details>



