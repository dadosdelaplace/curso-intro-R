```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Tipos de datos {-}

# Variables individuales: n칰meros y caracteres {#var-num}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script05.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.R).  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script05.R>

::::

&nbsp;

Tras los primeros ejercicios planteados deber칤amos saber m치s o menos usar `R` como una calculadora, definiendo variables que nos guardan n칰meros, como `a <- 1`. Vamos a ir m치s all치: <mark>**쯘xisten variables m치s all치 de los n칰meros?**</mark> En este cap칤tulo vamos a empezar a familiarizarnos con los <mark>**tipos de datos**</mark> que podemos necesitar. Piensa por ejemplo en los datos guardados de una persona en cualquier registro:

* La edad ser치 un <mark>**n칰mero (sin decimales)**</mark>
* Su peso o estatura ser치 otro <mark>**n칰mero (ahora con decimales)**</mark>.
* Su nombre ser치 una <mark>**cadena de texto**</mark>.
* Su fecha de nacimiento ser치 precisamente eso, un  <mark>**dato de tipo fecha**</mark>.
* A la pregunta 춺쯘st치 usted soltero/a?췉 la respuesta ser치 lo que llamamos una <mark>**variable binaria o l칩gica**</mark>: una variable que solo puede valer `TRUE` (si est치 soltero/a) y `FALSE` (en otro caso), guarada internamente como un `1` o `0`.

Existen **m치s tipos de datos** (por ejemplo, n칰meros complejos, listas, etc) pero con estos nos valdr치 de momento.


## Variables num칠ricas (individuales) {#numericas}

Probablemente el dato **m치s sencillo y obvio** de entender sean los datos num칠ricos, datos que ya hemos usado en nuestros primeros pasos como calculadora.

```{r}
a <- 1
b <- 2
a + b
```

En el c칩digo anterior, tanto `a` como `b`, como la suma `a + b`, son de <mark>**tipo num칠rico**</mark>, algo que podemos comprobar con la funci칩n `class()` (nos devuelve _numeric_).

```{r}
# Clase de las variables
class(a)
class(b)
class(a + b)
```

Tambi칠n podemos comprobar su naturaleza con `typeof()`, que nos devuelve la naturaleza del dato tal cual es guardada en `R`.

```{r}
# Tipolog칤a interna
typeof(a)
typeof(b)
typeof(a + b)
```

Aunque no es especialmente relevante profundizar en ello de momento, f칤jate que ambas 칩rdenes combinadas nos dicen que las variables son de tipo num칠rico pero concretamente de tipo <mark>**double**</mark>: dichas variables son entendidas internamente como n칰meros con decimales (aunque no los veamos), lo que en **matem치ticas se llaman n칰meros reales** (por curiosidad: el t칠rmino _double_ viene de lenguajes de programaci칩n antiguos como `C`, que significa 춺doble precisi칩n췉, para indicarle que reserve 8 bytes - 64 bits - de memoria). Durante el curso no distinguiremos entre distintos tipos de n칰meros, para nosotros ser치n siempre de clase _numeric_ y de tipo _double_, pero podr칤amos definir n칰meros enteros o _integer_ (sin decimales, ahorrando huecos en memoria).

```{r}
# Dato num칠rico (entero)
a <- 1L
class(a)
typeof(a)
```

Con los <mark>**datos num칠ricos**</mark> podemos realizar todas las <mark>**operaciones**</mark> que se nos ocurrir칤a hacer en una **calculadora**, como sumar (`+`), restar (`-`), multiplicar (`*`), dividir (`/`), ra칤z cuadrada (`sqrt()`), valor absoluto (`abs()`), elevar al cuadrado  (`^2`), elevar al cubo (`^3`), etc.


```{r}
# Definimos dos variables num칠ricas
a <- 1
b <- -2

# Suma y resta
a + b
a - b

# Multiplicaci칩n y divisi칩n
a * b
a / b

# Ra칤z cuadrada
sqrt(a)

# Potencias
a^2
b^3
```



## Variables de tipo caracter (texto) {#caracter}

Pero no solo de n칰meros viven los datos: imagina que adem치s de la edad de una persona queremos guardar su nombre.

```{r}
edad <- 32
nombre <- "Javier"

class(nombre)
typeof(nombre)
```

F칤jate que ahora tenemos guardado en la variable `nombre` una variable de tipo _character_, es decir, una <mark>**cadena de texto**</mark> (conocido en otros lenguajes como _string_ o _char_): <mark>**caracteres entre comillas**</mark>. 

Es importante el concepto de las comillas, ya que todo lo que vaya entre comillas ser치 un texto: `"1"` no representa un n칰mero, representa un texto (igual que `"hola"` o `"adios"`)

## Nuestra primera funci칩n: paste


Las <mark>**cadenas de texto**</mark> son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritm칠ticas, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la <mark>**funci칩n `paste()`**</mark>. Dicha funci칩n nos permite **pegar dos cadenas de caracteres**.


```{r}
nombre <- "Javier"
apellido <- "츼lvarez"
paste(nombre)
```

Si queremos pegar cadenas de texto sin ning칰n tipo de caracter en medio (ahora tenemos un espacio), existe una forma m치s abreviada y limpia de ejecutar la orden, usando la <mark>**funci칩n `paste0()`**</mark>

```{r}
paste0(nombre, apellido) # todo junto sin espacio
```

Cuando hemos ejecutado `paste()` y `paste0()` estamos ejecutando lo que se conoce como una <mark>**funci칩n**</mark>: una palabra reservada que representa un **conjunto de 칩rdenes encapsuladas**, y que se ejecuta a partir de unos <mark>**argumentos de entrada**</mark>. En este caso, solo hemos introducido como argumentos las cadenas de texto.

<mark>**쯈u칠 sucededer칤a si queremos pegar cadenas de texto usando el punto o la coma o cualquier otro caracter**</mark> En el caso de la funci칩n `paste()`, podremos hacer uso de lo que se conoce como **argumento opcional** llamado `sep`, que podemos darle un valor en concreto o dejarlo sin especificar. Lo que har치 `R` ser치 tomar su <mark>**valor por defecto**</mark> igual a `sep = " "` (por defecto, la funci칩n `paste()` pega cadenas de texto con un espacio entre ellas porque en realidad ejecuta por defecto `paste(..., sep = " ")`). 

```{r}
paste(nombre, apellido, sep = "") # todo junto
paste(nombre, apellido, sep = " ") # separados por un espacio
paste(nombre, apellido, sep = ".") # separados por un punto .
paste(nombre, apellido, sep = ",,") # separados por dos comas.
```

Prueba a ejecutar `? paste` en consola para ver las opciones de la funci칩n en el **panel de ayuda**.

## Nuestro primer paquete: glue


Otra forma m치s **intuitiva de trabajar con textos y variables num칠ricas** es usar el paquete `{glue}`, que nos permite <mark>**pegar cadenas de texto a variables num칠ricas de forma simb칩lica**</mark>.

```{r eval = FALSE}
install.packages("glue") # solo la primera vez
```

```{r}
library(glue)
```

Recuerda que `install.packages()` es solo necesario la primera que 춺compramos el libro췉: nos bajamos una serie de archivos a nuestro ordenador. Una vez que hemos comprado el libro, cada vez que queramos usarlo bastar치 con indicarle que nos traiga ese libro concreto con `library()`.

El paquete `{glue}` nos permite pegar de una forma mucho m치s legible cadenas de texto. Por ejemplo, supongamos que queremos construir la frase `"La edad es de X a침os"`, donde `X` ser치 la edad guardada e una variable.

```{r}
edad <- 32
paste("La edad es de", edad, "a침os")
```

Con `paste()` podemos mezclar texto y n칰meros pero de una forma un poco aparatosa ya que debemos de ir cerrando la frase con comillas. Para evitarlo, `glue()` nos proporciona una forma m치s c칩moda, sin salirnos de la cadena de texto, encapsulando las variables en llaves.

```{r}
glue("La edad es de {edad} a침os")

unidades <- "a침os"
glue("La edad es de {edad} {unidades}")
```

Tambi칠n podemos hacer uso de dicha funci칩n sin tener los valores num칠ricos previamente guardados en variables.

```{r}
# Otra forma sin definir variables a priori
glue("La edad es de {32} a침os")
```



## Manejando textos: paquete stringr


```{r stringr, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.cap = 'Paquete stringr https://github.com/rstudio/cheatsheets/blob/main/strings.pdf', out.width = '70%'}
knitr::include_graphics("img/stringr.png")
```

El paquete `{stringr}` nos proporciona un <mark>**abanico de funciones y utilidades para poder trabajar con variables de tipo texto**</mark>, permitiendo desde la b칰squeda hasta la extracci칩n de cadenas de texto dentro de la variable.

```{r}
# install.packages("stringr") # solo la primera vez
library(stringr)
```

Aunque no es el objetivo de este manual introductorio adentrarnos en lo que se conoce como _text mining_ o miner칤a de textos, he aqu칤 una lista de funciones 칰tiles que podemos encontrar en dicho paquete

* La funci칩n `str_length()` nos proporciona la <mark>**longitud de una cadena**</mark> de caracteres (reminder: un espacio cuenta como caracter).

```{r}
str_length("hola")
str_length("espejo")
```

* La funci칩n `str_sub()` nos permite <mark>**extraer subcadenas**</mark> de caracteres, indic치ndole no solo la cadena sino las posiciones iniciales y finales.

```{r}
x <- "ornitorrinco"
str_sub(x, 3, 3) # tercer caracter
str_sub(x, 3, 5) # del tercero al quinto (ambos inclusive)
str_sub(x, 2, -3) # del segundo al antepen칰ltimo caracter
```

Dicha funci칩n se puede usar incluso para <mark>**modificar subcadenas**</mark>

```{r}
str_sub(x, 3, 6) <- "jeje" # del tercero al sexto colamos un "jeje"
x
```

* La funci칩n `str_dup()` nos permite <mark>**duplicar cadenas**</mark> de caracteres

```{r}
str_sub("ja", 2) # duplicamos 2 veces "ja"
str_sub("ja", 5) # duplicamos 5 veces "ja"
```

* La funci칩n `str_remove()` nos permite <mark>**eliminar subcadenas**</mark> de caracteres (reminder: el espacio porque cuenta como caracter)

```{r}
# eliminamos de la variable la subcadena o patr칩n "DNI:"
str_remove("DNI: 41378292", "DNI:") # nos deja ese espacio
```

* La funci칩n `str_trim()` nos permite <mark>**eliminar espacios en blanco**</mark> que nos hayan quedado en el texto, algo bastante habitual cuando lees cadenas de caracteres de archivos o de internet.

```{r}
# eliminamos de la variable la subcadena o patr칩n "DNI:"
x <- str_remove("DNI: 41378292", "DNI:") # nos deja ese espacio
str_trim(x) # eliminamos ese espacio
str_trim("  calle mayor ", side = "left") # solo los de la izquierda
str_trim("  calle mayor ", side = "right") # solo los de la derecha
str_trim("  calle mayor ", side = "both") # ambos (pro defecto)
```

* La funci칩n `str_pad()` nos permite <mark>**a침adir espacios en blanco**</mark>

```{r}
x <- "mochila"
# un espacio en la izquierda (cadena resultante de longitud dada)
str_pad(x, 8) # longitud 8 ==> mochila tiene 7, as칤 que a침ade un espacio
str_pad(x, 15) # longitud 15 ==> mochila tiene 7, as칤 que a침ade 8 espacios
str_pad(x, 12, "right") # a la derecha
str_pad(x, 13, "both") # a ambos lados
```

* La funci칩n `str_to_upper()` nos permite <mark>**convertir un texto a may칰scula**</mark> y `str_to_title()` pone en may칰scula solo la primera letra de cada palabra. La funci칩n `str_to_lower()` nos permite <mark>**convertir un texto a min칰scula**</mark>

```{r}
x <- "Hola, me llamo Javi"
str_to_upper(x)
str_to_title(x)
str_to_lower("춰PARA! No puedes pasar")
```

* La funci칩n `str_detect()` nos permite <mark>**detectar subcadenas**</mark> de caracteres

```{r}
subcadena <- "ministerio"
x <- "En un documento del Ministerio del Interior..."
str_detect(x, subcadena) # no lo detecta porque se sensitive a may칰sculas
str_detect(str_to_lower(x), subcadena)
```

Haciendo adem치s uso de expresiones regulares podemos afinar nuestra b칰squeda

```{r}
telefono <- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
x <- "mi telefono es 219 733 8965"
y <- "mi telefono es 329-293-8753"
z <- "mi telefono es 32-293-87"
str_detect(x, telefono)
str_detect(y, telefono)
str_detect(z, telefono)
```

* La funci칩n `str_locate()` nos permite <mark>**localizar inicio y final donde se sit칰an cadenas**</mark> de caracteres

```{r}
str_locate("hola me llamo Javi", "Javi")
```

* La funci칩n `str_replace()` nos permite <mark>**reemplazar subcadenas en base a un patr칩n**</mark> pero solo lo hace con la primera que detecta. Con `str_replace_all()` podemos reemplazar todos

```{r}
str_replace("la vida del oso panda", "panda", "pardo") # reemplazamos panda por pardo
str_replace("la vida del oso pardo y el oso polar", "oso", "delf칤n")
str_replace_all("la vida del oso pardo y el oso polar", "oso", "delf칤n")
```


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Recuperar un comando y autocompletar", "#20935E")`**

Si haces click con el rat칩n en la consola y pulsas la flecha 춺arriba췉 del teclado, te ir치 apareciendo todo el <mark>**historial de 칩rdenes ejecutadas**</mark>. Es una manera de ahorrar tiempo para ejecutar 칩rdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando **tabulador** te **autocompletar치** solo.

&nbsp;

**`r colorize("Convertir tipos de datos",  "#20935E")`**

A veces la lectura de variables num칠ricas de nuestros archivos puede hacer que un n칰mero, por ejemplo `1`, sea le칤do como la cadena de texto `"1"`, con la que no podemos operar como un n칰mero. Las funciones `as.numeric()`, o `as.character()` nos permiten convertir una variable en tipo num칠rico, caracter o l칩gico, respectivamente.

```{r error = TRUE}
"1" + 1
as.numeric("1") + 1
as.character(1)
```

&nbsp;

## 游닇 Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>游닇<strong>Ejercicio 1</strong>: define una variable `edad` que guarde tu edad y otra `nombre` con tu nombre. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
edad <- 32 # tipo numeric
nombre <- "Javier" # tipo caracter

edad
nombre
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 2</strong>: define otra variable con tus apellidos y junta las variables `nombre` y `apellidos` en una sola cadena de texto que guardes en `nombre_completo`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Apellidos
apellidos <- "츼lvarez Li칠bana"

# Pegamos
nombre_completo <- glue("{nombre} {apellidos}")
nombre_completo

# Otra forma
nombre_completo <- paste(nombre, apellidos)
nombre_completo
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 3</strong>: define dos variables num칠ricas y realiza la suma de ambas. Obt칠n con `class()` la clase de dicha variable suma </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Definimos dos variables num칠ricas
a <- 1
b <- -2

a + b
class(a + b)
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 4</strong>: construye una frase que diga 춺Hola, me llamo ... y tengo ... a침os췉. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
edad <- 32
glue("Hola, me llamo {nombre_completo} y tengo {edad} a침os")
```

<!-- tocstop -->
</details>


&nbsp;


<details>
  <summary>游닇<strong>Ejercicio 5</strong>: define una cadena de texto con `"mi c칩digo postal es 28045"`. Calcula la longitud de la cadena y extrae la subcadena del lugar 3 al 17 con `str_sub()` (guarda dicha subcadena en una variable `y`) </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
x <- "mi c칩digo postal es 28045"
y <- str_sub(x, 3, 17)
y
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 6</strong>: con la subcadena `y` del ejercicio anterior, elimina los espacios solo de la izquierda y convierte a may칰sculas </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Todo en una l칤nea
str_to_upper(str_trim(y, side = "left"))

# Paso a paso
z <- str_trim(y, side = "left")
str_to_upper(z)
```

<!-- tocstop -->
</details>


&nbsp;


<details>
  <summary>游닇<strong>Ejercicio 7</strong>: con la cadena `x` original, sustituye la subcadena "c칩digo postal" por "cp".</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
str_sub(x, 4, 16) <- "cp"
```

<!-- tocstop -->
</details>


&nbsp;





