# Creaci칩n de funciones {#FUNCIONES}

En `R` no solo podemos usar las funciones predeterminadas que vienen ya cargadas, o las de los paquetes que instalamos, sino que adem치s podemos **crear nuestras propias funciones**, para automatizar tareas que vayamos a repetir a lo largo de nuestro c칩digo.

**쮺칩mo crear nuestra propia funci칩n?** Veamos su sintaxis b치sica. Para crear una funci칩n necesitamos un `nombre_funcion` (sin espacios ni caracteres extra침os), al que le asignamos la orden `function()`. Dentro de `function()` tendr칤amos que definir los argumentos de entrada que vamos a usar.

```{r}
nombre_funcion <- function(argumento_1, argumento_2, ... ) {
  
  # C칩digo que queramos ejecutar en la funci칩n
  c칩digo
  
  # Salida
  return(variable_salida)
}
``` 

- **argumento_1, argumento_2, ...**: ser치n los argumentos de entrada, los argumentos que toma la funci칩n para ejecutar el c칩digo que tiene dentro
- **c칩digo**: l칤neas de c칩digo que queramos que ejecute la funci칩n. **IMPORTANTE**: todas las variables que definamos dentro de la funci칩n son variables locales, solo existir치n dentro de la funci칩n salvo que especifiquemos lo contrario.
- `return(variable_salida)`: dentro del comando `return()` se introducir치 la salida de la funci칩n, que puede ser un n칰mero, un ` data.frame`, una gr치fica, una matriz, o todo junto en una lista.


## Primera funci칩n

Veamos un **ejemplo muy simple de funci칩n** para calcular el 치rea de un rect치ngulo.

```{r}
# Definici칩n del nombre de funci칩n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  # Cuerpo de la funci칩n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

**쮺칩mo aplicar la funci칩n?** Con el nombre y los valores de los argumentos.

```{r}
# Aplicaci칩n de la funci칩n con los par치metros por defecto
calcular_area(5, 3) # 치rea de un rect치ngulo 5 x 3 
```

Imagina ahora que nos damos cuenta que el 90% de las veces el 치rea que nos toca calcular es la de un cuadrado: `R` nos permite definir **argumentos en la funci칩n con valores por defecto** (tomar치n dicho valor salvo que le asignemos otro). **Por qu칠 no asignar `lado_2 = lado_1` por defecto**, para ahorrar l칤neas de c칩digo y tiempo? 

```{r}
# Definici칩n del nombre de funci칩n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci칩n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


```{r}
calcular_area(lado_1 = 5) # si no indicamos nada, lado_2 = lado_1
``` 

Compliquemos un poco la funci칩n y a침adamos en la salida los valores de cada lado etiquetados como primer lado y segundo lado.

```{r}
# Definici칩n del nombre de funci칩n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci칩n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos en modo lista ya que devolvemos
  # varios argumentos a la vez (podemos dar a cada elemento 
  # de la lista con un nombre que nos permita identificarlo)
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

Veamos que nos devuelve ahora

```{r}
calcular_area(5, 3)
```

F칤jate que puedes guardar la salida de forma conjunta para luego acceder a solo uno de los elementos de la lista de salida.

```{r}
x <- calcular_area(5, 3)
x$area
x$lado_1
x$lado_2
```

Antes nos daba igual el orden de los argumentos pero ahora no, ya que en la salida incluimos `lado_1` y `lado_2`. Es **altamente recomendable** hacer la llamada a la funci칩n indicando expl칤citamente los argumentos `argumento_1 = valor_1` para **mejorar la legibilidad e interpretabilidad de nuestro c칩digo** (recuerda: programa como escribir칤as una novela).

```{r}
calcular_area(lado_1 = 5, lado_2 = 3)
```

<details>
  <summary>游닇<strong>Ejercicio</strong>: define una funci칩n propia llamada `pares` que, dados dos n칰meros `x` e `y`, nos diga si la suma de ambos es par o no.</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Definimos funci칩n
pares <- function(x, y) {
  
  # Sumamos
  suma <- x + y
  
  # Comprobamos si es par calculando el resto al dividir entre 2: si al dividir suma entre 2 el resto es 0 ==> es par
  
  par <- suma %% 2 == 0
  
  # Devolvemos la salida
  return(par)
}

# Aplicamos la funci칩n
pares(1, 3)
pares(1, 0)
pares(2, 6)
pares(2, 7)
```

Tambi칠n se puede definir directamente como

```{r}
# Definimos funci칩n
pares <- function(x, y) {

  # Devolvemos la salida
  return((x + y) %% 2 == 0)
}

pares(1, 3)
pares(1, 0)
pares(2, 6)
pares(2, 7)
```

<!-- tocstop -->
</details>

## Segunda funci칩n
 

Vayamos con un **ejemplo m치s complejo**. Imaginemos que en nuestro c칩digo vamos a tener calcular, para cada d칤a, el n칰mero de vacunas diarias administradas, el n칰mero de vacunas administradas en los 칰ltimos 7 d칤as y el n칰mero de vacunadas administradas en los 칰ltimos 14 d칤as, usando tan solo el n칰mero de vacunadas acumuladas. Para ello vamos a usar la **funci칩n `diff()` que nos calcula las diferencias de un vector dado**.

```{r}
x <- c(1, 2, 3, 7, 10, 15, 20, 50, 100, 250, 600, 1200)
diff(x) # vector con [elemento2 - elemento1, elemento3 - elemento2, elemento4 - elemento3, ...]
diff(x, 3) # vector con [elemento4 - elemento1, elemento5 - elemento2, elemento6 - elemento3, ...]
diff(x, 7) # vector con [elemento8 - elemento1, elemento9 - elemento2, elemento10 - elemento3, ...]
```


```{r include = FALSE}
load("~/Dropbox/DIVULGACI칍N/CURSO R BIOQUIMICA EN MOVIMIENTO/CURSO R/curso_R/DATOS/panel_vacunas_ccaa.RData") 
load("~/Dropbox/DIVULGACI칍N/CURSO R BIOQUIMICA EN MOVIMIENTO/CURSO R/curso_R/DATOS/panel_vacunas_fecha.RData")
```


```{r}
# Para Espa침a
casos_diarios <- diff(panel_vacunas$ES$personas_vacunadas)
casos_7D <- diff(panel_vacunas$ES$personas_vacunadas, 7) # diferencias a 7 d칤as
casos_14D <- diff(panel_vacunas$ES$personas_vacunadas, 14) # diferencias a 14 d칤as

# Para Andaluc칤a
casos_diarios <- diff(panel_vacunas$AN$personas_vacunadas)
casos_7D <- diff(panel_vacunas$AN$personas_vacunadas, 7) # diferencias a 7 d칤as
casos_14D <- diff(panel_vacunas$AN$personas_vacunadas, 14) # diferencias a 14 d칤as

# ...
```


쮺u치nto ocupar칤a realizar esta misma tarea para cada comunidad, y cada variable? **쯇or qu칠 no la automatizamos?**


```{r}
datos_acumulados <- function(variable_acumulada, dias_dif = c(1, 7, 14)) {
  
  # Dentro de las llaves el cuerpo de la funci칩n
  acumulados_diferenciales <- NULL
  for (i in dias_dif) { # Vamos calculando tantos acumulados diferenciales como le hayamos pasado por el argumento dias_dif
    
    # A lo que ten칤amos, le concatenamos por columnas uno nuevo
    acumulados_diferenciales <- c(acumulados_diferenciales,
                                  rev(diff(variable_acumulada, i))[1])
  
  }
  
  # La salida de la funci칩n
  return(acumulados_diferenciales)
}
``` 

Como vemos, los argumentos pueden ser cualquier tipo de variable, y nos permite adem치s **generalizar y automatizar una tarea** para que pueda ser usada incluso en alg칰n escenario para el que no tuvi칠ramos previsto (acumulados a ... 13 d칤as, por ejemplo). Para que nuestra funci칩n sea realmente 칰til debemos intentar asignar **nombres de funciones y argumentos lo m치s concisos posibles y evidentes en su interpretaci칩n**.

```{r}
datos_acumulados(panel_vacunas$ES$personas_vacunadas)
datos_acumulados(panel_vacunas$AN$personas_vacunadas)
datos_acumulados(panel_vacunas$ES$personas_vacunadas, dias_dif = c(1, 3, 13, 21))
``` 

F칤jate que hemos devuelto solo el 칰ltimo acumulado (hemos dado la vuelta al vector resultante y nos hemos quedado con el primer elemento). Para hacer que la salida sea m치s interpretable, muchas de las **funciones en `R` tienen como salida una lista, con unos nombres asignados**. 

```{r}
datos_acumulados <- function(variable_acumulada) {
  
  # Datos
  dato_diario <- diff(variable_acumulada)
  dato_7D <- diff(variable_acumulada, 7)
  dato_14D <- diff(variable_acumulada, 14)

  # La salida de la funci칩n como una lista, con 3 vectores
  return(list("diario" = dato_diario, "7D" = dato_7D,
              "14D" = dato_14D))
}
datos_salida <- datos_acumulados(panel_vacunas$ES$personas_vacunadas)
names(datos_salida)
datos_salida
``` 


<details>
  <summary>游닇<strong>Ejercicio</strong>: define una funci칩n propia llamada `proximo_par` que, dados un n칰mero `x`, nos diga si es par y, en aso de no serlo, nos devuelva el pr칩ximo n칰mero que si lo sea.</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Definimos funci칩n
proximo_par <- function(x) {
  
  # 쯣ar? TRUE/FALSE
  par <- (x %% 2) == 0
  
  # Si es par, devolvemos el propio n칰mero (era par), sino le sumamos uno
  if (par) {
    
    return(list("par" = par, "proximo" = x))
    
  } else { # Si no es par, devolvemos el siguiente (que ser치 par) 
    
    return(list("par" = par, "proximo" = x + 1))
  
  }
  # Devolvemos una lista de dos elementos: par (TRUE/FALSE) y proximo (si es par, el propio x, sino x + 1)
}

# Aplicamos la funci칩n
proximo_par(7)
proximo_par(8)
```


## Variables locales/globales

Hemos dicho que 춺lo local se queda en lo local췉, 쯣ero qu칠 sucede si nombramos a una variable dentro de una funci칩n que se nos ha olvidado asignar un valor dentro de la misma? Debemos ser cautos al usar funciones en `R`, ya que debido a la **춺regla lexicogr치fica췉**, si una variable no se define dentro de la funci칩n, `R`  buscar치 dicha variable en el entorno de variable. 

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada per se, solo realiza la acci칩n de imprimir en consola
}
funcion_ejemplo()
```

Si una **variable ya est치 definida fuera de la funci칩n (entorno global)**, y adem치s es usada dentro de la misma cambiando su valor, el valor de dicha variable solo cambia dentro de la funci칩n pero no en el entorno global.


```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
funcion_ejemplo() # lo que vale dentro
print(x) # lo que vale fuera
```

Si queremos que **adem치s de cambiar localmente lo haga globalmente** deberemos usar la **doble asignaci칩n** (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  x <- 3 # no cambia globalmente, solo localmente
  y <<- 0 # cambia globalmente
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```



