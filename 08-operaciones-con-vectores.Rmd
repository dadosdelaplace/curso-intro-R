```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# Operaciones con vectores {#operacionesvectores}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script07.R**](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script07.R).  Ver en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script07.R>

::::


## Vectores num칠ricos

### Operaciones aritm칠ticas

Hemos dicho ya que un n칰mero es un vector de longitud 1, as칤 que toda <mark>**operaci칩n aritm칠tica**</mark> (suma, resta, multiplicaci칩n, etc) que podamos hacer con un n칰mero la vamos a poder a hacer con un vector de n칰meros. Si hacemos por ejemplo la operaci칩n `2 * x`, siendo `x` un vector, lo que suceder치 es que <mark>**la operaci칩n se realizar치 en CADA ELEMENTO del vector**</mark>. Esto es una ventaja enorme ya podremos escribir una sola l칤nea de c칩digo pero realizar operaciones en 10, 20, 1000 o 100000 elementos (tantos como tenga el vector).


```{r}
# Multiplicamos por 2 a CADA ELEMENTO del vector
x <- c(2, 4, 6)
2 * x
```

El resultado es por tanto otro vector. De la misma manera sucede si sumamos o restamos una constante.

```{r}
# Sumamos 3 a CADA ELEMENTO DEL VECTOR
x + 3

# Restamos 5 a CADA ELEMENTO DEL VECTOR
x - 5
```

Los vectores tambi칠n pueden interactuar entre ellos, as칤 que podemos definir sumas de vectores, como `x + y`, con `y <- c(1, 3, 5)` (por ejemplo), ra칤ces cuadradas `sqrt(x)` o elevar **cada elemento** al cuadrado `x^2`.

```{r}
y <- c(1, 3, 5)
x + y # suma de vectores 
sqrt(x) # Hacemos la ra칤z cuadrada de CADA ELEMENTO DEL VECTOR
x^2 # Elevamos al cuadrado CADA ELEMENTO DEL VECTOR
```

&nbsp;

En `R`, salvo que especifiquemos lo contrario, **`r colorize("toda operaci칩n ARITM칄TICA que hagas a un vector ser치 elemento a elemento", "#20935E")`**. Esto 칰ltimo es bastante importante que no se te olvide ya que en otros lenguajes no siempre es as칤. 

&nbsp;

Dado que la operaci칩n (por ejemplo, una suma) se realiza **elemento a elemento**, 쯤u칠 suceder치 si <mark>**sumamos dos vectores de distinta longitud**</mark>? Prueba a definir un vector `z` con los 4 primeros impares, e intentar hacer la suma `x + z` (un vector de longitud 3 m치s un vector de longitud 4).

```{r}
z <- c(1, 3, 5, 7)
x + z
```

`R` intenta molestarte lo menos posible, as칤 que lo que hace es <mark>**reciclar elementos**</mark>: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que har치 ser치 **reciclar** elementos del vector con menor longitud: har치 `1 + 2`, `3 + 4`, `5 + 6` pero... `7 + 2` (vuelve al primero).   

&nbsp;

Como hemos comentado anteriormente, los <mark>**valores l칩gicos**</mark> `TRUE/FALSE` son guardados internamente como `0/1` por lo que podemos usar <mark>**operaciones aritm칠ticas**</mark> con ellos. Por ejemplo, si queremos averiguar el n칰mero de elementos de un vector que cumplen una condici칩n l칩gica (por ejemplo, `< 3`), los que lo hagan tendr치n asignado un `1` y los que no un `0`, por lo que basta con <mark>**sumar dicho vector l칩gico**</mark> para obtener el n칰mero de elementos que cumplen dicha condici칩n (elementos que son `TRUE`).

```{r}
sum(x < 3) # sumamos el vector de TRUE/FALSE --> n칰mero de valores TRUE
```


### Operaciones estad칤sticas

Al igual que podemos ejecutar operaciones aritm칠ticas, podemos realizar tambi칠n <mark>**operaciones estad칤sticas**</mark> con los vectores, como calcular su suma (`sum()`), su media (`mean()`), su mediana (`median()`) o su suma acumulada (`cumsum()` cada elemento lo acumula al anterior).

Hagamos antes un <mark>**breve repaso de algunos t칠rminos estad칤sticos**</mark>:

* **`r colorize("Media", "#4197D2")`**: medida de centralizaci칩n que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. A pesar de ser la m치s conocida, la media es **muy poco robusta**: dado un conjunto, si se introducen **valores at칤picos o outliers** (valores muy grandes o muy peque침os), la media se perturbar con mucha facilidad (por ejemplo, el salario medio en un pa칤s con mucha desigualdad no tiene valor estad칤stico ya que est치 perturbado por las altas fortunas). Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $\overline{x}$.

$$\overline{x} = \frac{\displaystyle \sum_{i=1}^{n}x_i}{n}$$

* **`r colorize("Mediana", "#4197D2")`**: medida de centralizaci칩n que consiste en, tras ordenar los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos n칰meros por debajo como por encima). M치s robusta que la media aunque menos que la moda. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $Me_x$.

$$Me_x = \displaystyle \arg \min_{x_i} \left\lbrace F_i > 0.5 \right\rbrace, \quad F_i = \frac{\#\left\lbrace x_j \leq x_i \right\rbrace}{n}$$

* **`r colorize("Moda", "#4197D2")`**: medida de centralizaci칩n que consiste en encontrar el valor m치s repetido (el valor _trending_). Es la medida de centralizaci칩n m치s robusta. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $Mo_x$.


$$Mo_x = \displaystyle \arg \max_{x_i} f_i  , \quad f_i = \frac{\#\left\lbrace x_j = x_i \right\rbrace}{n}$$

&nbsp;

He aqu칤 un ejemplo de algunas funciones estad칤sticas 칰tiles

```{r}
sum(y) # suma
mean(y) # media
median(y) # mediana
cumsum(y) # suma acumulada
```

Otra operaci칩n 칰til en estad칤stica es calcular los <mark>**percentiles**</mark> con la funci칩n `quantiles()`.

```{r}
y <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)
quantile(y) # Percentiles por defecto: cuartiles (0%-25%-50%-75%-100%)
```

Recuerda que en `R` algunas **funciones tienen argumentos por defecto**, argumentos que no necesitan ser asignados un valor a priori. En el ejemplo de calcular los percentiles con `quantile()`, hay un argumento por defecto (con un valor ya asignado sino se especifica lo contrario) que es `probs = c(0, 0.25, 0.5, 0.75, 1)`. Pero dicho argumento por defecto puede ser cambiado, por ejemplo, para sacar los percentiles 15%-30%-70%-90%.

```{r}
y <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)
quantile(y, probs = c(0.15, 0.3, 0.7, 0.9)) # Percentiles p15, p30, p70 y p90
```

### Operaciones con ausentes {#operacionesausentes}

Imagina que tenemos un vector de temperaturas pero varios de los d칤as el aparato de medici칩n no funcionaba, por lo que tenemos un ausente `NA`.

```{r}
x <- c(21, NA, 13, NA, NA, 25, 36, 17, 19, 5)
sum(x)
```

Dado que hay d칤as que no tenemos disponibles, la suma de todos los d칤as tampoco la podemos conocer (salvo que obviemos los d칤as donde no tenemos dato). Para evitar que un dato ausente en nuestros datos nos impida hacer ciertas operaciones, en muchas funciones de `R` podemos a침adir el argumento `na.rm = TRUE`: <mark>**primero elimina los datos ausentes**</mark>, y luego ejecuta la funci칩n.

```{r}
# eliminando datos ausentes antes de aplicar la funci칩n
sum(x, na.rm = TRUE) 
mean(x, na.rm = TRUE)
``` 


## Seleccionar elementos

Ya sabemos definir variables que sean vectores (recuerda: colecci칩n de valores del **mismo tipo**). 쯏 si del <mark>**vector original queremos EXTRAER UN SUBCONJUNTO del mismo**</mark>, por ejemplo, los primeros 10 elementos?

`R` tiene varias formas de hacer esto pero la m치s sencilla es entendiendo que si yo quiero <mark>**acceder al elemento i-칠simo**</mark> de un vector, deber칠 usar el **operador de selecci칩n `[i]`**. Veamos un ejemplo: definimos las edades de cinco personas y queremos saber la edad de la persona que ocupa el tercer lugar.

```{r}
edades <- c(20, 30, 32, NA, 61)
edades[3] # accedemos a la edad de la tercera persona en la lista
edades[4] # accedemos a la edad de la cuarta persona (que no la tenemos guardada)
```

Un n칰mero no es m치s que un vector de longitud uno, as칤 que esta operaci칩n tambi칠n la podemos aplicar <mark>**usando un vector de 칤ndices a seleccionar**</mark>, de forma que le podemos indicar simultaneamente que valores que queremos (por ejemplo, al tercer y cuarto elemento de nuestras edades).

```{r}
edades[c(3, 4)] # queremos acceder a la vez al tercer y cuarto elemento
```

Esta l칩gica para acceder a elementos de vectores tambi칠n sirve para nuestros <mark>**vectores de caracteres**</mark>. 

```{r}
y <- c("hola", "qu칠", "tal", "todo", "ok", "?")
y[1:2] # Solo queremos acceder a los elementos en la posici칩n 1 y 2
```

Para acceder al 칰ltimo elemento de un vector podemos pasarle como 칤ndice la longitud de dicho vector (si el vector tiene longitud 6, el 칰ltimo elemento ocupar치 el lugar 6).

```{r}
# Accedemos a los elementos en la posici칩n 1, 2 y adem치s el
# que ocupa la 칰ltima posici칩n
y[c(1:2, length(y))] 
```

Otras veces no querremos seleccionar un elemento en concreto sino <mark>**filtrar algunos elementos en concreto y no extraerlos, eliminarlos**</mark>, para lo cual deberemos repetir la misma operaci칩n pero con el signo `-` delante: el operador `[-i]` no selecciona el elemento i-칠simo del vector sino que lo elimina en nuestro filtro.

```{r}
y
y[-2] # Nos muestra todo y salvo el elemento que ocupa la segunda posici칩n
```

&nbsp;

Sin embargo, **lo habitual** es que dicho **filtro** lo hagamos en base a una <mark>**condici칩n l칩gica**</mark>. Supongamos que `edades_1 <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)` e `edades_2 <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)` son las edades de dos grupos de personas y que queremos quedarnos solo con los mayores edad. 쯊enemos que andar averiguando en que posici칩n se encuentran para luego seleccionarlos? No, vamos a <mark>**seleccionar los elementos que cumplen una condici칩n dada**</mark>.

```{r}
edades_1 <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)
edades_2 <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)
edades_1[edades_1 >= 18] # mayores de 18 a침os del conjunto x
edades_2[edades_2 >= 18] # mayores de 18 a침os del conjunto y
```

Lo que hemos hecho ha sido pasar como **칤ndices a seleccionar un vector l칩gico `TRUE/FALSE`**: solo filtrar치 los lugares donde se guarde un `TRUE`, aquellos que cumplen la condici칩n l칩gica introducida. 

```{r}
edades_1 >= 18 # donde haya TRUE, lo seleccionar치
edades_1[edades_1 >= 18] # mayores de 18 a침os del conjunto x
```

Esto tambi칠n nos puede servir para limpiar de datos ausentes, combinando la funci칩n `is.na()`, que nos localiza el lugar que ocupan los ausentes, con el operador `!`, que lo que hace es negar el valor l칩gico que venga detr치s. 

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[is.na(x)] # solo valores ausentes
x[!is.na(x)] # sin valores ausentes: ! es el s칤mbolo de la negaci칩n
```

Tambi칠n podemos probar a <mark>**combinar condiciones l칩gicas**</mark> para nuestra **selecci칩n**.

```{r}
x[x >= 18 & x <= 25] # los valores que cumplen ambas (&): entre 18 y 25 a침os
```

Como ves, si un valor est치 ausente (`NA`), la evaluaci칩n de una condici칩n l칩gica sobre 칠l (mayor o menor de 18 a침os) nos seguir치 devolviendo `NA` en dicho lugar

&nbsp;


### which

Hemos visto como seleccionar elementos de un vector que cumplen una condici칩n, para a veces no queremos el elemento en s칤, sino el <mark>**lugar que ocupa**</mark>: **쯤u칠 valores de un vector cumplen una condici칩n l칩gica, qu칠 lugar ocupan?** Para obtener dicho 칤ndice tenemos a nuestro disposici칩n la funci칩n `which()`, que no nos devuelve el elemento en s칤 sino su lugar.

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[x >= 18] # Accedemos a los elementos que cumplen la condici칩n
which(x >= 18) # Obtenemos los lugares que ocupan los elementos que cumplen la condici칩n
```

Esta funci칩n es muy 칰til especialmente cuando queremos **averiguar el valor que ocupa el m치ximo/m칤nimo** de una colecci칩n de valores, con las funciones `which.max()` y `which.min()`.

```{r}
x
max(x, na.rm = TRUE) # m치ximo de x (si no eliminamos NA, nos devolver치 NA)
min(x, na.rm = TRUE) # m칤nimo de x (si no eliminamos NA, nos devolver치 NA)
which.max(x) # Lugar que ocupa el m치ximo
which.min(x) # Lugar que ocupa el m칤nimo
```

### NULL

A veces adem치s de `NA` y `NaN`, `R` nos muestra un dato llamado `NULL`. Cuando tenemos `NA` en alguna variable, el registro existe, pero no est치 relleno. Sin embargo, cuando tenemos un `NULL` significa que ese valor ni siquiera existe: no es un dato guardado pero cuyo valor desconocemos, es un dato que ni siquiera existe (por ejemplo, si guardamos datos de 7 personas, el dato de la octava persona no es `NA`, es que no hay octava persona directamente).

```{r}
x <- c(1, NA, 3, NA, NA, 5, 6)
x[2] # NA: el registro existe pero sin dato
names(x) # No hemos definido el nombre de las variables, as칤 que devuelve NULL
```


## Nombrando vectores: a침adiendo metainformaci칩n

Adem치s `R` nos permite <mark>**dar significado l칠xico**</mark> a nuestros valores (significan algo, no solo n칰meros), pudiendo poner **nombres a los elementos de un vector**.

```{r}
x <- c("edad" = 31, "tlf" = 613910687, "cp" = 33007) # cada n칰mero tiene un significado distinto
x
```

Esto es una ventaja ya que nos permite su selecci칩n usando dichos nombres: ya no elegimos el tercer n칰mero o el primero, sino el n칰mero que representa el tel칠fono y el c칩digo postal de una persona.

```{r}
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

Con la funci칩n `names()` podemos, no solo consultar los nombres de una variable, sino cambiarlos a nuestro gusto.

```{r}
names(x) # Consultamos nombres
names(x) <- c("a침os", "m칩vil", "direcci칩n") # Cambiamos nombres
names(x) # Consultamos nuevos nombres
x
```

M치s adelante dejaremos introducidos un tipo de dato m치s apropiado para guardar datos en 춺formato tabla췉, que se compondr치 de una concetenaci칩n de concatenaciones, una concatenaci칩n de columnas (de vectores). 

## Ordenar

Una acci칩n habitual al trabajar con datos es <mark>**saber ordenarlos**</mark>: de menor a mayor edad, datos m치s recientes vs antiguos, etc. Para ello tenemos la funci칩n `sort()`, que podemos usar directamente para **ordenar de menor a mayor**. Vamos a ordenar, por ejemplo, una colecci칩n de edades de diferentes personas.


```{r}
edades <- c(81, 7, 25, 41, 65, 20, 32, 23, 77)
sort(edades) # orden de joven a mayor
```

Por defecto, `sort()` **ordena de menor a mayor**. Con el argumento opcional `decreasing = TRUE` podemos **ordenar de mayor a menor**. 

```{r}
sort(edades, decreasing = FALSE) # orden de mayor a joven
```

Otra forma de ordenar un vector es que `R` nos **devuelva los 칤ndices de los elementos ordenados**, y luego usar dichos 칤ndices para reorganizar los elementos, con la funci칩n `order()`.

```{r}
order(x) 
x[order(x)] # accedemos a los 칤ndices ordenados
```



## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Operaciones estad칤sticas", "#20935E")`**

Como has podido comprobar, las **`r colorize("operaciones ESTAD칈STICAS no se realizan elemento a elemento", "#20935E")`**: la media o la suma las realiza tomando todos los elementos del vector.

&nbsp;

**`r colorize("all, any", "#20935E")`**
 
Existen dos funciones muy 칰tiles en `R` para saber si **TODOS** o **ALGUNO** de los elementos de un vector cumple una condici칩n. Las funciones `all()` y `any()` nos devolver치 un 칰nico valor l칩gico. Estas funciones son muy 칰tiles al final de los c칩digos para comprobar que las condiciones que tienen que verificar los datos se cumplen, y asegurarnos que el proceso se ha ejecutado correctamente (por ejemplo, que todos los datos sean positivos o no haya datos ausentes).

```{r}
x <- c(1, 2, 3, 4, 5, NA, 7)
all(x < 3)
any(x < 3)
all(x > 0)
all(na.omit(x) > 0)
all(is.na(x))
any(is.na(x))
```

&nbsp;

**`r colorize("Argumentos por defecto", "#20935E")`**

La funci칩n `sort()` es un buen ejemplo de que las **funciones traen definidos argumentos por defecto** (aunque no los veamos a priori). La orden `sort(x)` en realidad est치 ejecutando `sort(x, decreasing = TRUE)`, pero como es su valor por defecto, nos podemos ahorrar incluirlo. Escribe `? help sort()` en la consola y ver치s como en la cabecera de la funci칩n ya hay preasignado un `decreasing = TRUE`.



&nbsp;


**`r colorize("Diferencia de conjuntos", "#20935E")`**

Una funci칩n muy 칰til para ver las **diferencias entre dos conjuntos** es `setdiff()`, una funci칩n que nos devuelve los elementos distintos entre dos conjuntos.

```{r}
y <- 1:10
z <- c(1, 3, 7, 10)
setdiff(y, z) # Elementos en y que no est치n en z 
```

&nbsp;

**`r colorize("Optimiza tu c칩digo", "#20935E")`**

Aunque parezca un tema menor, si tu c칩digo tarda 1 milisegundo m치s de lo que podr칤a tardar de otra forma, si esa orden se repite muchas veces, ese milisegundo extra puede ser 5, 10 o 20 minutos m치s que tu c칩digo tardar치 en ejecutarse. Hay un paquete muy 칰til en `R` para medir tiempos de distintas 칩rdenes que hacen lo mismo (el paquete `{microbenchmark}`), vamos a instalarlo.

```{r eval = FALSE}
install.packages("microbenchmark")
library(microbenchmark)
```


```{r echo = FALSE}
library(microbenchmark)
```

Este paquete contiene una orden para comparar el tiempo de dos 칩rdenes: necesita como primeros argumentos las dos 칩rdenes cuyos tiempos vamos a comparar, y un argumento `times` en el que le indicamos el n칰mero de veces que ejecutar치 cada orden para realizar los tiempos medios. Vamos a comparar los comandos de ordenaci칩n `order()` y `sort()`.

```{r}
x <- rnorm(1e3) # 1000 elementos aleatorias de una normal N(0, 1)
microbenchmark(sort(x), # primera forma
               x[order(x)], # segunda forma
               times = 1e3) # se repetir치 1000 veces
```

Aunque a priori parezca contraintuitivo, es m치s corto obtener los 칤ndices ordenados de un vector, y luego reordenarlo en base a esos 칤ndices, que la ordenaci칩n directa a trav칠s del comando `sort()` (ya que usan algoritmos de ordenaci칩n distintos).


## 游닇 Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>游닇<strong>Ejercicio 1</strong>: define el vector `x` como la concatenaci칩n de los n칰meros 1, 10, -1 y 2, y calcula su suma.</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de n칰meros
x <- c(1, 10, -1, 2)

# Suma
sum(x)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 2</strong>: define otro vector `y` que contenga los n칰meros `5, -7, 8, -3`, y haz la suma de `x` e `y`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de n칰meros
y <- c(5, -7, 8, -3)

# Suma
x + y
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 3</strong>: calcula el n칰mero de elementos mayores que 0 del resultado de la suma de `x + y`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
sum((x + y) > 0)

# Otra forma
suma <- x + y
sum(suma > 0)
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 4</strong>: calcula la versi칩n ordenada del vector `x`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Ordenamos el vector (con sort)
sort(x)

# Ordenamos el vector  (con order)
x[order(x)]
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>游닇<strong>Ejercicio 5</strong>: encuentra del vector `x` original el lugar (el 칤ndice) que ocupa su m칤nimo y su m치ximo. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
x<- c(1, 10, -1, 2)

# Encontrando el lugar que ocupa el m치ximo y m칤nimo
which.max(x)
which.min(x)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 6</strong>: encuentra del vector `x` los elementos mayores que 1 y menores que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector l칩gico: mayores que 1 y menores que 7
x > 1 & x < 7

# 쯉on todos positivos? Mira tambi칠n any()
all(x > 0)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 7</strong>: define el vector `c(-1, 0, 4, 5, -2)`, calcula la ra칤z cuadrada del vector y determina que lugares son ausente de tipo `NaN`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector
z <- c(-1, 0, 4, 5, -2)

# 쮺u치les son ausentes tras aplicar la ra칤z cuadrada?
is.nan(sqrt(z))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 8</strong>: define el vector de los primeros n칰meros impares (hasta el 21) y extrae los elementos que ocupan los lugares 1, 4, 5, 8. Elimina del vector el segundo elemento</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de impares (de 1 a 21 saltando de dos en dos)
x <- seq(1, 21, by = 2)

# Seleccionamos elementos
x[c(1, 4, 5, 8)]

# Eliminamos elementos
y <- x[-2]
y
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 9</strong>: define una cadena de caracteres `texto <- c("oso polar", "oso pardo", "salamandra", "buho", "lechuza", "oso malayo")`. Usa `str_count()` para contabilizar el n칰mero de osos. Usa `str_starts()` para saber que elemento del vector es un oso o no. Obten la longitud de cada cadena. Sustituye en todas las cadenas la `o` por `*`</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
texto <- c("oso polar", "oso pardo", "salamandra", "buho", "lechuza", "oso malayo")

# Cuenta el n칰mero de cadenas que contienen la palabra "oso"
str_count(texto, "oso")

# Nos devuelve TRUE en las cadenas que empiecen por "oso"
str_starts(texto, "oso")
str_ends(texto, "oso") # devuelve todo FALSE

# Longitud de cada cadena
str_length(texto)

# Sustituimos en todas las oes por *
str_replace_all(texto, "o", "*")
```

<!-- tocstop -->
</details>


