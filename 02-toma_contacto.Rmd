# Primeros pasos

**쮼mpezamos?**

Veamos antes **un poco de historia** sobre nuestro deidad.

All치 por 1975, los **laboratorios Bell** (los que inventaron la radio moderna tal y como la conocemos), necesitaban una alternativa a los lenguajes m치s 춺rudos췉 y antiguos como `C++` o `Fortran`, lenguajes r치pidos en la ejecuci칩n pero complejos en su uso, con una gran curva de aprendizaje y con **muy poca capacidad en la visualizaci칩n de datos** que se empezaba a necesitar.

As칤 que en **1976 sacaron la primera versi칩n del lenguaje conocido `S`** (hasta entonces estaba de moda lo de llamar a los lenguajes con una sola inicial). En **1980** se empez칩 a distribuir la primera versi칩n p칰blica de `S`, m치s all치 de los laboratorios Bell, y en **1988** se a침adieron bastantes funcionalidades nuevas como poder aplicar funciones a otras funciones (los famosos `apply()` que ya veremos). A침os m치s tarde, en **1991**, dicho lenguaje se simplific칩, reescribiendo muchas subrutinas de otros lenguajes m치s primitivos, para tener una versi칩n muy parecida al actual `R`, permitiendo el usod de operadores, `data.frames` (que veremos) y otro tipo de objetos, sencillos en la programaci칩n pero muy versatiles.

Sin embargo, salvo uso docente, `S` ten칤a licencia as칤 que **en 1992 Ross Ihaka y Robert Gentleman se lanzaron a crear una versi칩n de `S` libre y gratuita**, un trabajo de casi 8 a침os hasta que en el a침o 2000, ambos investigadores de la Universidad de Auckland en Nueva Zelanda lanzaron la primera versi칩n estable del lenguaje.

Tras dicho lanzamiento, se cre칩 un **equipo de expertos en estad칤stica computacional (el conocido como _R Development Core Team_)** que es el que se encarga de mantener toda la aerquitectura de `R` y los que se encargar de actualizar y mejorar el paquete `{base}`, una **librer칤a motor** sobre la que se construye el resto de funciones.

## Excel no es tu amigo

**`R` es un lenguaje de programaci칩n**, de alto nivel para el usuario y modular. Los lenguajes de alto nivel como `R`, `Python` (curso interactivo de Python en <https://checkio.org/>) o `Matlab`, facilitan la programaci칩n al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una **menor curva de aprendizaje** aunque suelen ser m치s lentos en su ejecuci칩n en comparaci칩n con lenguajes de bajo nivel (`C`, `C++` o `Fortran`), lenguajes muy r치pidos en su ejecuci칩n pero cuya programaci칩n requiere un mayor tiempo y formaci칩n, teniendo que adem치s estar pendiente del tipo de variables, espacio en memoria, etc.

Por su arquitectura, `R` es un lenguaje que puede ser usado para un prop칩sito general pero que est치 especialmente dise침ado para el **an치lisis estad칤stico de datos**. Su **modularidad** nos da la ventaja de que podemos instalar las funcionalidades que vayamos necesitando de forma progresiva.

**쯇or qu칠 no es recomendable usar Excel?**

* **Software de pago**: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. A nivel individual, todos hemos tenido una versi칩n que no hemos pagado, pero dicha evasi칩n no se la puede permitir una empresa o administraci칩n, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que no ser칤a necesario si los investigadores y trabajadores tuvieran formaci칩n (remunerada) en otras herramientas de software libre.

* **Software cerrado**: no solo es de pago sino que es cerrado, as칤 que solo podemos hacer lo que Excel ha cre칤do que interesante que podamos hacer. Incluso con la programaci칩n de MACROS, las funcionalidades de Excel siguen siendo mucho m치s limitadas ya que viene 춺programadas췉 de antemano

* **Alto consumo de memoria**: dicha programaci칩n predeterminada hace que Excel ocupe much칤simo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas a la vez en tu ordenador).

* **No es universal**: no solo es de pago sino que adem치s, dependiendo de la versi칩n que tengas de Excel, tendr치 un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo `.xls` abierto por un Excel moderno puede provocar errores en la carga.

* **춰ES SOLO UNA HOJA DE C츼LCULO!**: el propio Microsoft desaconseja el uso de Excel para el an치lisis de grandes vol칰menes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de c치lculo: llevar las cuentas de tu familia, de tu peque침o negocio, una declaraci칩n de la Renta sencilla, planificar viajes, etc. Pero el programa **NO EST츼 DISE칌ADO** para ser una base de datos ni para an치lisis detallado, y muchos menos pensado para generar un entorno flexible para el an치lisis estad칤stico y la visualizaci칩n de datos.

**쯇uedes ser el mejor partiendo un filete con una cuchara?** Seguramente puedas (en Excel puedes hasta programar con macros), y si siempre lo hiciste as칤, acabar치s normaliz치ndolo, pero seguir치s siendo una persona comiendo filete con cuchara.

&nbsp;

![](img/pregunta.png){style="float: left; margin-left: 0.5px; margin-right: 4px; margin-top: 1px; width: 4%"} **쯈u칠 sucede si usamos la herramienta equivocada?**

Tres ejemplos: 

* **Problemas para codificar fechas**: en 2016 se public칩 una [revisi칩n de art칤culos en gen칠tica](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1044-7), descubriendo que 1 de cada 5 art칤culos conten칤an errores debido a una mala codificaci칩n de las fechas, conviertiendo por ejemplo los genes Septin-2 (conocido como SEPT2) en fechas, y al rev칠s [@Ziemannetal16].

```{r excel-genes, echo = FALSE,  out.width = "50%", fig.align = "center", fig.cap = "Excel en una noche loca."}
knitr::include_graphics("./img/excel_genes.jpg")
```

* **Problemas de memoria**: un Excel permite por defecto una cantidad m치xima de filas. Aunque dicha cantidad se puede ampliar, sigue siendo finita, por lo que cuando superas el umbral de filas, al a침adir filas Excel te borra registros **sin avisarte de que lo est치 haciendo**. Esto es lo que sucedi칩 con los [registros de casos covid en Reino Unido](https://www.redaccionmedica.com/secciones/sanidad-hoy/covid-reino-unido-pierden-16000-positivos-9989).

```{r excel-uk, echo = FALSE,  out.width = "50%", fig.align = "center", fig.cap = "Cuando Excel dice basta."}
knitr::include_graphics("./img/excel_uk.jpg")

```

* **Problemas para codificar edades**: una variable de tipo fecha, aunque nosotros la veamos con letras, en realidad es una variable num칠rica que representa los d칤as que han pasado desde una fecha origen. En funci칩n de las distintas versiones de Excel, dicha fecha origen cambia. Adem치s, si se codifica mal la fecha en formato `dd-mm-YY`, dicho formato cuando se exporta a otro excel en texto, no permite distinguir a un nacido en 1918 y a un nacido en 2018, as칤 que podemos estar confundiendo personas de 103 a침os con ni침os de 3 a침os (y es lo que [sucedi칩 en Espa침a](https://www.niusdiario.es/sociedad/sanidad/sanidad-reconoce-datos-muertes-ninos-covid-erroneos-contabilizaban-centenarios-como-menores_18_3107220241.html), observando unas tasas de mortalidad en ni침os muy peque침os equivalentes a personas mayores).

```{r excel-edades, echo = FALSE,  out.width = "50%", fig.align = "center", fig.cap = "Los centenarios con biber칩n."}
knitr::include_graphics("./img/excel_edades.jpg")

```


## Primeros pasos: calculadora

쯊e acuerdas de lo que era la **consola**? Vamos a trabajar de momento en esa ventana que tienes en la ventana inferior.

```{r inicio-rstudio-2a, echo = FALSE, out.width = "75%", fig.align = "center", fig.cap = "Lanzando a consola nuestras primeras 칩rdenes en RStudio."}
knitr::include_graphics("./img/inicio_rstudio_2.jpg")
```

Lo que ya hemos descubierto en los pasos de la instalaci칩n (ver imagen \@ref(fig:inicio-rstudio-2a)) es que la consola de `R` tiene una funci칩n muy b치sica y evidente: nos sirve de calculadora. Un ejemplo muy simple: si escribimos `r 1 + 2` en la consola y pulsamos _ENTER_, la consola nos mostrar치 el resultado de la suma

```{r}
1 + 2
```

&nbsp;

**쯇ero cu치l es la diferencia entre una calculadora y un lenguaje de programaci칩n?**

Imagina que dicha suma `r 1 + 2` la quisi칠ramos utilizar para un segundo c치lculo: 쯫 si en lugar de lanzarlo a la consola sin m치s lo **almacenamos en alguna variable**?

Como hemos visto en la instalaci칩n de `RStudio`, para **asignar variables** lo haremos con la orden `x <- 1 + 2`: una variable de nombre `x` va a tener asignada `<-` lo que valga la suma `1 + 2`

```{r}
x <- 1 + 2
```

Como puedes comprobar, en tu parte superior derecha (nuestro entorno de variables), podr치s ver como una nueva variable `x` es ahora visualizada, con su valor asignado (**no se mostrar치 en consola** salvo que escribas `r x ` en ella: `R` asume que no quer칤as visualizarla en consola sino solo guardarla).

```{r echo = FALSE, out.width = "75%", fig.align = "center", fig.cap = "Environment."}
knitr::include_graphics("./img/environment_1.jpg")
```

Dicha variable `x` adem치s podemos reciclarla para definir una variable `y`, rest치ndole una constante.

&nbsp;

De la misma manera que hemos hecho restas, sumas y multiplicaciones, `R` tiene todas las operaciones cl치sicas que podr칤as tener en una calculadora. Prueba a ejecutar en la consola las 칩rdenes `x^2`, `sqrt(x)` o `abs(y)`: `R` calcular치 las operaciones _elevar al cuadrado_, _ra칤z cuadrada_ y _valor absoluto_ de la variable que tengan entre par칠ntesis

```{r}
x^2
sqrt(x)
y <- x - 5
abs(y)
```

&nbsp;


## Tipos de errores {#tipos_errores}

Durante tu aprendizaje en `R` va a ser **muy habitual** que las cosas no salgan a la primera, **apareciendo en consola mensajes en un color rojo**. Un **miedo** muy habitual cuando se empieza a programar es pensar que si haces algo mal o aparece alg칰n mensaje de error, el ordenador puede explotar en cualquier momento. **A programar se aprende programando**, as칤 que haz las pruebas que quieres, lo peor que puede pasar es que necesites cerrar sesi칩n en `R Studio` y abrirlo de nuevo.

Dado que el 99.99999% de veces tu c칩digo tendr치 errores que deber치s ir solventando, no est치 de m치s conocer los tipos de mensajes que `R` puede sacarte por consola:

```{r colorize, echo = FALSE}
# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

* **`r colorize("Errores", "red")`**: los mensajes de error ir치n precedidos de la frase **춺Error in...췉**, d치ndote a veces incluso el tipo de error y la l칤nea de c칩digo en la que se ha producido. Veamos un ejemplo intentando sumar un n칰mero a una cadena de texto.

```{r error = TRUE}
"a" + 1
```

Los **errores son aquellos fallos que seguramente impidan la ejecuci칩n** del c칩digo. Un **error muy habitual** es intentar acceder a alguna funci칩n de alg칰n paquete que, o bien no tenemos instalado, o bien no hemos llamado haciendo uso del `library()`: est치s intentando leerte un libro de tu biblioteca pero ni siquiera has ido a la tienda a 춺comprarlo췉.


* **`r colorize("Warnings", "yellow")`**: los mensajes de _warning_ ir치n precedidos de la frase **춺Warning:...췉**, y son los fallos m치s delicados ya que son **posibles errores o incoherencias** que `R` detecta en tu c칩digo pero que **no van a hacer que tu c칩digo deje de ejecutarse**, aunque probablemente no lo haga como a ti te gustar칤a. Un ejemplo es cuando tratamos de hacer la raiz cuadrada de un n칰mero negativo.

```{r warning = TRUE}
sqrt(-1)
``` 

쮿a ejecutado la orden? S칤, pero te **advierte de que el resultado de la operaci칩n es un `NaN`, un valor que no existe (al menos dentro de los n칰meros reales), un _Not A Number_ (ver Secci칩n \@ref(ausentes)).

* **`r colorize("Mensajes de control", "green")`**: los mensajes de control ser치n aquellos que aparecer치n por consola sin empezar por 춺Error in...췉 ni 춺Warning:...췉. Dichos mensajes, que puedes incluir t칰 mismo en tu c칩digo con funciones como `cat()` para monitorizar la ejecuci칩n de c칩digos largos, no son errores ni problemas, son simplemente informaci칩n que `R` considera 칰til aportarte.


## ![](img/logo_info.png){width=4%}  Consejos y tips
  

<details>
  <summary><strong>Argumentos de una funci칩n</strong></summary>

Las 칩rdenes `sqrt(x)` y `abs(y)` se llaman **funciones**, y la variable que tienen entre par칠ntesis se llama **argumento de la funci칩n**: una variable que toma de entrada la funci칩n y con la que opera internamente.

</details> 

&nbsp;  
<details>
  <summary><strong>Panel de ayuda</strong></summary>

Si escribes en la consola `? nombre_funcion` (por ejemplo, escribe en la consola `? sqrt`), en el panel inferior derecho te aparecer치 una **documentaci칩n de ayuda** de la funci칩n para saber que argumentos necesita, como puedes usar la funci칩n, qu칠 es lo que te devuelve, ejemplos de uso, etc.

```{r}
? sqrt
```

```{r echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Panel de ayuda."}
knitr::include_graphics("./img/panel_ayuda.jpg")

```
</details> 


## 游닇 Ejercicios

<details>
  <summary>游닇<strong>Ejercicio 1</strong>: calcula en consola la suma de 3 m치s 4, y todo ello multiplicado por 10, y as칤gnalo a una variable `x`.</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
x <- (3 + 4) * 10
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 2</strong>: usando la variable `x` ya definida, calcula `x - 5` y gu치rdalo en una nueva variable `y`.</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
y <- x - 5
y
```
<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 3</strong>: usando las variables `x` e `y` ya definidas, calcula la ra칤z cuadrada del m치ximo entre ambas, y gu치rdalo en una nueva variable `z`.</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
z <- sqrt(max(x, y)) # No hace falta gastar una l칤nea por cada orden (cada asignaci칩n que hagas es una variable guardada que consume memoria en tu ordenador)
z
```
<!-- tocstop -->
</details>




