```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# Tipos de datos II: datos estructurados {#datos}

Ya sabemos un poco la gram√°tica y ortograf√≠a de nuestro lenguaje, y algunas de las funcionalidades b√°sicas de nuestro ¬´Word¬ª. Vamos a aprender c√≥mo escribir la mejor trama para la novela: hablemos de <mark>**estructuras de datos**</mark>.

## Matrices

Hasta ahora **hemos visto solo datos en una dimensi√≥n**: una variable, que tiene $n$ valores num√©ricos, $n$ valores l√≥gicos o $n$ valores de tipo texto. **Una sola variable** (de $n$ elementos).

```{r}
c(1, 4, NA, -2, 0)
c("a", NA, "b", "c")
c(TRUE, TRUE, FALSE, TRUE)
```

Pero cuando analizamos datos solemos tener varias variables distintas, por ejemplo, la **estatura y el peso de una persona**. Cuando tenemos **distintas variables num√©ricas de IGUAL longitud**, un formato de dato muy habitual es lo que conocemos como <mark>**matrices**</mark>: una **<mark>¬´tabla¬ª de n√∫meros**</mark>, con filas y columnas.

Vamos a empezar con una matriz sencilla: guardamos las estaturas y pesos de 5 personas.

```{r}
estaturas <- c(150, 160, 170, 180, 190)
pesos <- c(60, 70, 80, 90, 100)
```

Hasta ahora, cada variable la hemos definido por separado, pero ahora vamos a **juntarlas**: vamos a crear nuestro **primer conjunto de datos** juntado todas ellas en una matriz, un conjunto de n√∫meros organizado en **2 columnas (una por variable)** y **5 filas o registros (una por persona)**. Para ello usaremos la funci√≥n `cbind()`, que nos <mark>**concatena vectores de igual longitud en formato columna**</mark>.


```{r}
datos_matriz <- cbind(estaturas, pesos) # Construimos la matriz por columnas
datos_matriz
```

Para practicar vamos a definir otro ejemplo con las **edades, tel√©fonos y c√≥digos postales de una serie de individuos**.

```{r}
edades <- c(14, 24, 56, 31, 20, 87, 73) # vector num√©rico de longitud 7
tlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)

# Construimos la matriz por columnas
datos_matriz <- cbind(edades, tlf, cp) 
datos_matriz
```

Lo que tenemos es **una columna por variable y una fila por registro**. Tambi√©n podemos construir la **matriz por filas** con el comando `rbind()`, que nos permite a√±adir filas a una matriz o construirla desde cero (aunque lo habitual es tener cada variable en una columna).


```{r}
datos_matriz_filas <- rbind(edades, tlf, cp) # Construimos la matriz por filas
datos_matriz_filas

# A√±adimos una fila
rbind(datos_matriz_filas, c(27, 620125780, 28051))
```

Como ves, ahora nuestros <mark>**datos est√°n tabulados**</mark>, tienen dos dimensiones. ¬øC√≥mo saber las **dimensiones** que tiene una matriz? Prueba a ejecutar la funci√≥n `dim()`.

```{r}
dim(datos_matriz)
dim(datos_matriz_filas)
```

F√≠jate que `dim()` devuelve un vector de 2 elementos, por lo que para acceder al n√∫mero de filas deberemos ejecutar `dim(x)[1]` (y `dim(x)[2]` para el n√∫mero de columnas). 

```{r}
dim(datos_matriz)[1]
dim(datos_matriz)[2]
```

Tambi√©n tenemos a nuestra disposici√≥n las funciones `nrow()` y `ncol()`, que nos devuelven directamente el n√∫mero de filas y columnas.

```{r}
nrow(datos_matriz)
ncol(datos_matriz)
```

Bien, ya sabemos **definir una matriz a partir de variables sueltas**. Igual que a veces es √∫til generar un vector de elementos repetidos, tambi√©n podemos definir una <mark>**matriz de n√∫meros repetidos**</mark> (por ejemplo, de ceros), con la funci√≥n `matrix()`, indic√°ndole el n√∫mero de filas y columnas.

```{r}
matrix(0, nrow = 5, ncol = 3) # 5 filas, 3 columnas, todo 0's
```

Tambi√©n podemos definir una **matriz a partir de un vector num√©rico**, reorganizando los valores en forma de matriz (con una dimensi√≥n tal que `filas * columnas = longitud del vector`), sabiendo que los elementos se van colocando por columnas (primeros valores en la primera columna, de arriba a abajo).

```{r}
z <- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas)
z
class(z) # Clase de la variable
```

&nbsp;

Dada una matriz tambi√©n podemos darle vuelta (lo que se conoce como <mark>**matriz transpuesta**</mark>, donde filas pasan a ser columnas y viceversa) con la funci√≥n `t()`.

```{r}
datos_matriz
t(datos_matriz) # Matriz transpuesta
```


Con las matrices sucede como con los vectores: cuando <mark>**aplicamos una operaci√≥n aritm√©tica**</mark>, se la estamos aplicando elemento a elemento, por ejemplo, dividir entre 5.

```{r}
datos_matriz / 5
```

## Apply vs bucles


Si eres un programador avezado te estar√°s preguntando: **¬øno se usan apenas los bucles en `R`?** Existir existen, pero la raz√≥n por la que no usaremos apenas **bucles**, e intentaremos evitarlos lo m√°ximo posible, es porque en `R` son **muy ineficientes** en tiempo de ejecuci√≥n. Vamos a poner un ejemplo. Supongamos que queremos calcular la suma de cada fila (es decir, 7 valores). Con bucles ser√≠a as√≠.

```{r}
# Creamos la matriz
estaturas <- c(150, 160, 170, 180, 190)
pesos <- c(60, 70, 80, 90, 100)
x <- cbind(estaturas, pesos)

# Bucle
suma <- rep(0, dim(x)[1]) 
for (i in 1:dim(x)[1]) { # Bucle recorriendo filas

  suma[i] <- sum(x[i, ], na.rm = TRUE) # Suma de la fila i
    
}
suma
``` 

En el c√≥digo anterior puedes ver como para <mark>**acceder a la fila i-√©sima de la matriz**</mark> se usa el operador `[i, ]` (dejando libre el √≠ndice de la columna), mientras que para **acceder a la columna j-√©sima de la matriz** se usar√≠a el operador `[, j]`. Para **acceder al elemento `(i, j)`** se usa el operador `[i, j]`. 


La pregunta es: **¬øno hay una forma m√°s eficiente de hacerlo?** La respuesta: s√≠. La **funci√≥n `apply()` nos permite ejecutar una funci√≥n por filas o por columnas**.

```{r}
# Suma por filas (MARGIN = 1)
suma_por_filas <- apply(x, MARGIN = 1, FUN = "sum")
suma_por_filas 

# Una funci√≥n cualquiera por filas
operacion_por_filas <- apply(x, MARGIN = 1, FUN = function(x) { sum(sqrt(2) - 2) })
operacion_por_filas

# Suma por columnas (MARGIN = 2)
suma_por_cols <- apply(x, MARGIN = 2, FUN = "sum")
suma_por_cols
```

Como puedes observar, necesitas tres argmentos y otros opcionales: la matriz, el √≠ndice por el que operar (`MARGIN = 1` por filas, `MARGIN = 2` por columnas) y la funci√≥n a aplicar, am√©n de otros argumentos extras que pudiera necesitar la funci√≥n.

Veamos qu√© es m√°s eficiente con el paquete `{microbenchmark}`, que nos permite **comparar el tiempo de dos conjuntos de √≥rdenes**.

```{r}
library(microbenchmark)

# Comparamos tiempos de ejecuci√≥n de ambas formas, y lo
# repetimos 100 veces para sacar tiempos medios
microbenchmark(
  # √≥rdenes 1
  for (i in 1:dim(x)[1]) {
    
    suma_por_filas[i] <- sum(x[i, ]) 
    
  },
  # √≥rdenes 2
  apply(x, MARGIN = 1, FUN = "sum"), times = 500) 
```

**¬°El bucle nos tarda 40-80 veces m√°s que el `apply`!**

&nbsp;


## Tablas: data.frames


Adem√°s del nombre de las columnas (heredado de los nombres de las variables con las que hemos construido las columnas), podemos poner **nombre a los registros**, por ejemplo, el nombre de las personas a las que pertenece cada dato, **definiendo una nueva variable con los nombres y concaten√°ndola**.


```{r}
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
cbind(nombres, datos_matriz)
```

**¬øHas visto lo que ha sucedido?**

Como <mark>**una matriz SOLO puede tener un tipo de dato**</mark>, al a√±adir una variable de tipo texto, ha convertido los n√∫meros tambi√©n a texto poni√©ndole comillas: **hemos roto la integridad de nuestro dato**. Una forma de a√±adir **nombre a los registros, sin incluirlo como variable**, es usando la funci√≥n `row.names()`.

```{r}
row.names(datos_matriz) <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
datos_matriz
```

&nbsp; 

**¬øQu√© sucede si realmente queremos a√±adir variables cuyos <mark>tipos sean distintos (¬°ojo, pero con la misma longitud!)</mark>?**

Vamos a crear nuevas variables de texto `nombres` y `apellidos`, un valor l√≥gico `casado`, valores num√©ricos `edades`, `cp` y `tlf`, y una fecha `fecha_creacion` (fecha de entrada en el sistema) para cada persona.

```{r}
# Nombres
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")

# Apellidos
apellidos <- c(NA, "Gonz√°lez", "Fern√°ndez", "Mart√≠nez", "Li√©bana", "Garc√≠a", "Ortiz")

# C√≥digo postal
cp <- c(28019, 28001, 34005, 18410, 33007, 34500, 28017)

# Edades
edades <- c(45, 67, NA, 31, 27, 19, 50)

# Estado civil (no lo sabemos de una persona)
casado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)

# Tel√©fono
tlf <- c(618910564, 914718475, 934567891, 620176565, NA, NA, 688921344)

# Fecha de creaci√≥n (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
fecha_creacion <-
  as.Date(c("2021-03-04", "2020-10-12", "1990-04-05",
            "2019-09-10", "2017-03-21", "2020-07-07",
            "2000-01-28"))
```


Seguimos teniendo 7 registros, uno por persona pero ahora tenemos un popurr√≠ de variables, de la <mark>**misma longitud pero de tipos distintos**</mark>: 

* `(edades, tlf, cp)` son variables **num√©ricas**.
* `(nombres, apellidos)` son variables de **texto**.
* `casado` es una variable **l√≥gica**.
* `fecha_creacion` de tipo **fecha**.

**¬øQu√© suceder√≠a si yo intento mezclar todo en una matriz?**


```{r}
# Juntamos todo en una matriz (juntamos por columnas)
x <- cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)
x
```

Efectivamente: como en una matriz solo puede haber datos de un tipo, los n√∫meros los convierte a texto, las variables l√≥gicas las convierte a texto (`TRUE` es un valor l√≥gico, `"TRUE"` es un texto, como `"Pepito"`, sin significado l√≥gico de verdadero/falso) y las fechas las ha convertido a texto (aunque las veas igual, ya no son de tipo de fecha, son texto y no podemos operar con ellas).

```{r error = TRUE}
# D√≠as entre la primera y el segundo elemento de fecha de creaci√≥n
fecha_creacion[1] - fecha_creacion[2]

# D√≠as entre primera y segunda fecha de creaci√≥n pero tom√°ndolo de nuestra matriz (columna 7, fila 1 y 2)
x[1, 7] - x[2, 7]
```

&nbsp; 

He aqu√≠ LA PREGUNTA

<mark>**¬øC√≥mo juntar variables de distinto tipo, sin cambiar su naturaleza, como cuando juntamos datos en una tabla de excel?**</mark>

El formato de tabla de datos en `R` que vamos a empezar a usar se llama <mark>**`data.frame`**</mark>: una colecci√≥n de <mark>**variables de igual longitud pero cada una de un tipo distinto**</mark>. Para crear un objeto de este tipo basta con usar la funci√≥n `data.frame()`, pas√°ndole como argumentos (separados por comas) las variables que queremos reunir, indicando en texto el nombre de las columnas.

```{r}
# Creamos nuestro primer data.frame
tabla <- data.frame("Nombre" = nombres, "Apellido" = apellidos,
                    "Edad" = edades, "Tel√©fono" = tlf,
                    "C√≥digo Postal" = cp, "Casado" = casado,
                    "Fecha_de_creaci√≥n" = fecha_creacion)
tabla
```

<mark>**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**</mark>

Puedes <mark>**visualizarlo**</mark> escribiendo su nombre en consola o con la funci√≥n `View()`

```{r eval = FALSE}
View(tabla)
```


### Selecci√≥n de columnas y filas

Si tenemos un `data.frame` ya creado y queremos <mark>**a√±adir una columna**</mark> es tan simple como usar la funci√≥n  `data.frame()` que ya hemos visto para concatenar la columna. 

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos <- c(0, 0, 1, 5, 2, 3, 0)
tabla <- data.frame(tabla, hermanos)
tabla
```

Si queremos <mark>**acceder a una columna, fila o elemento en concreto**</mark>, los **`data.frame` tienen las mismas ventajas que una matriz**, as√≠ basta con usar los mismos operadores.

```{r}
# Accedemos a la tercera columna
tabla[, 3]

# Accedemos a la quinta fila
tabla[5, ]

# Accedemos a la tercera variable del quinto registro
tabla[5, 3]
``` 


Un `data.frame` **no solo tiene las ventajas de una matriz** si no que tambi√©n tiene las <mark>**ventajas de una tabla de datos**</mark>. Por ejemplo, podemos **aceder a las variables** por el √≠ndice de columna que ocupan pero <mark>**tambi√©n acceder a las columnas por su nombre**</mark>, poniendo el nombre de la tabla, el s√≠mbolo `$` y con el tabulador nos aparecer√° un men√∫ de columnas a elegir. 

```{r tabla-dolar, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Men√∫ desplegable de variables (columnas) de un data.frame."}
knitr::include_graphics("./img/tabla_dolar.jpg")
```


Adem√°s del conjunto de datos `tabla` que ya tenemos, vamos a instalar (sino lo hemos hecho nunca en este ordenador) un paquete muy √∫til en `R` llamado `{datasets}`. Los paquetes que vayamos necesitando los instalaremos y llamaremos al inicio del c√≥digo principal.


```{r}
# Paquetes necesarios
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
```

Am√©n de nuestro conjunto de datos `tabla` en nuestro panel de entorno, si escribimos `datasets::` y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usados: el paquete `datasets` nos proporciona `data.frames` de prueba para que podamos usarlos en nuestros c√≥digos seg√∫n vamos aprendiendo.

Una de las **ventajas de los `data.frame`** es que podemos visualizarlos como si fuera una tabla de Excel dentro de nuestro `R` con la funci√≥n `View()`. Vamos a visualizar no solo el conjunto de datos `tabla` sino tambi√©n el conjunto `iris` del paquete `datasets`: los <mark>**`data.frame` nos permiten trabajar con ellos como bases de datos o como matrices**</mark>, con las ventajas de ambos.

```{r eval = FALSE}
View(iris)
View(tabla)
```

```{r view-datasets, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Men√∫ desplegable con los data.frame de prueba en datasets"}
knitr::include_graphics("./img/view_datasets.jpg")
```

&nbsp;

En el caso de los `data.frame` tenemos adem√°s a nuestro disposici√≥n una <mark>**herramienta muy potente: la funci√≥n `subset()`**</mark> Dicha funci√≥n nos va a permitir <mark>**seleccionar filas y columnas a la vez**<mark>, tomando de entrada los siguientes argumentos

* `x`: una tabla de entrada, un `data.frame` de entrada.
* `subset`: la condici√≥n l√≥gica que queramos usar para seleccionar registros (filas).
* `select`: un vector que contenga el nombre de las columnas que queremos seleccionar (a lo mejor solo queremos filtrar por filas pero quiz√°s tambi√©n por columnas).

Por ejemplo, vamos a **seleccionar solo los nombres y apellidos de aquellas personas mayores de edad** de nuestro conjunto de datos `tabla`, y del conjunto `iris` vamos a extraer todos los registros en los que el largo del s√©palo es mayor que 7.1, seleccionando solo las columnas de longitud de s√©palo y la especie de la planta.


```{r}
subset(tabla, subset = Edad > 18, select = c("Nombre", "Apellido"))
subset(iris, subset = Sepal.Length > 7.1, select = c("Sepal.Length", "Species"))
``` 


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Acceder a las funciones de los paquetes", "#20935E")`**

A veces puede que no queramos cargar todo un paquete sino solo una funci√≥n del mismo, para lo que es suficiente `nombre_paquete::nombre_funcion`. Recuerda que instalar un paquete es c√≥mo comprar un libro, cargar el paquete con `library()` es c√≥mo traer el libro comprado de la estanter√≠a a tu mesa, y usar solo una funci√≥n con `nombre_paquete::nombre_funcion` es c√≥mo pedirle a alguien que te arranque solo una p√°gina y te la traiga a la mesa.

&nbsp;

**`r colorize("CONSEJO: nombre de variables", "#20935E")`**

La funci√≥n `names()` no solo sirve para consultar los nombres de las variables de un `data.frame` sino tambi√©n para cambiarlos a nuestro gusto.

```{r}
# Consultamos nombres
names(tabla)

# Cambiamos nombres
names(tabla) <- c("nombre_persona", "apellido_persona", "edad", "tlf",
                  "cp", "casado", "f_creacion")
tabla
```


## üìù Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary><strong>Ejercicio 1</strong>: define una matriz `x` de ceros de 3 filas y 7 columnas. Tras ello suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5</summary>

- Soluci√≥n:

```{r}
# Matriz
x <- matrix(0, nrow = 3, ncol = 7)
x

(x + 1) / 5
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 2</strong>: tras definir la matriz `x` calcula su transpuesta y obt√©n sus dimensiones</summary>

- Soluci√≥n:

```{r}
# Transpuesta
t(x)

# Dimensiones transpuesta: pasa de ser 3x7 a 7x3
dim(t(x))
ncol(t(x)) # n√∫mero de columnas de la transpuesta
nrow(t(x)) # n√∫mero de filas de la transpuesta
```

</details>

&nbsp;

<details>
  <summary><strong>Ejercicio 3</strong>: calcula la suma de cada fila de la matriz `matrix(1:12, nrow = 4)` usando un bucle. Haz lo mismo evitando usar bucles.</summary>

- Soluci√≥n:

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

# Con bucle (recorremos sus filas)
suma <- rep(0, nrow(matriz)) # Definimos un vector de 0's con tantos elementos como filas, donde iremos metiendo los valores de la suma
for (i in 1:nrow(matriz)) {
  
  suma[i] <- sum(matriz[i, ]) # Sumamos la fila i
}
suma

# Sin bucle (MARGIN = 1 ya que es una operaci√≥n por filas)
suma <- apply(matriz, MARGIN = 1, FUN = "sum")
suma
```
</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 4</strong>: con la matriz `matrix(1:12, nrow = 4)` anterior, calcula la media de todos los elementos, la media de cada fila y la media de cada columna.</summary>

- Soluci√≥n:

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

#  media de todos
mean(matriz)

# Media por filas (MARGIN = 1 ya que es una operaci√≥n por filas)
apply(matriz, MARGIN = 1, FUN = "mean")

# Media por filas (MARGIN = 2 ya que es una operaci√≥n por filas)
apply(matriz, MARGIN = 2, FUN = "mean")
```
</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 5</strong>: del data.frame `iris` (al que puedes acceder desde el paquete `{datasets}`), obt√©n el nombre de las variables.</summary>
  
- Soluci√≥n:

```{r}
# Nombres de variables
names(iris)
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 6</strong>: del conjunto `iris` selecciona aquellas filas cuya variable `Petal.Width` sea distinta de 0.2.</summary>
  
- Soluci√≥n:

```{r}
# Filtramos filas
filtro_fila <- subset(iris, subset = Petal.Width != 0.2)
filtro_fila
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 7</strong>: del conjunto `iris` qu√©date solo con las variables `Sepal.Length`, `Sepal.Width` y `Species`.</summary>
  
- Soluci√≥n:

```{r}
# Filtramos columnas
filtro_col <- subset(iris,  select = c("Sepal.Length", "Sepal.Width", "Species"))
filtro_col
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 8</strong>: del conjunto `iris` selecciona a la vez aquellas filas cuya variable `Petal.Width` sea distinta de 0.2, y qu√©date solo con las variables `Sepal.Length`, `Sepal.Width` y `Species`.</summary>
  
- Soluci√≥n:

```{r}
# Todo de una vez
filtro <- subset(iris, subset = Petal.Width != 0.2, select = c("Sepal.Length", "Sepal.Width", "Species"))
filtro
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 9</strong>: calcula el n√∫mero de filas borradas del ejercicio anterior. Tras hacer todo ello, traduce a castellano el nombre de las columnas del `data.frame` filtrado.</summary>
  
- Soluci√≥n:

```{r}
# Filas borradas
nrow(iris) - nrow(filtro)

# Cambiamos nombres a castellano del conjunto filtrado
names(filtro) <- c("longitud_sepalo", "anchura_sepalo", "especies")
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 10</strong>: del conjunto `iris`  accede a las columnas con nombres `"Sepal.Length"` y  `"Sepal.Width"`.</summary>
  
- Soluci√≥n:

```{r}
# Accedemos por √≠ndice
iris[, 1:2]

# Accedemos por nombre
iris[, c("Sepal.Length", "Sepal.Width")]

# Accedemos a cada una individualmente
iris$Sepal.Length
iris$Sepal.Width
```

</details>


