
# (PART) Listas y funciones {-}

# Tipos de datos III: listas/factores {#otros_datos}

Veamos alg√∫n tipo de dato muy particular m√°s all√° de vectores, matrices y `data.frames`.

## Listas

Probablemente las **listas** sea uno de los tipos de datos m√°s importantes en `R` ya que permiten almacenar **colecciones de variables de diferente tipo (ya lo hac√≠an los `data.frames`) pero tambi√©n de diferente longitud**, y con estructuras totalmente heter√≥geneas, de ah√≠ que sea el formato de salida de much√≠simas funciones de `R` que te devuelven a la vez un cadena de texto, un vector de n√∫meros o una tabla, todo guardado en la misma variable (incluso una lista puede tener dentro a su vez otra lista).

Vamos a crear nuestra primera lista.

```{r}
# Fecha de nacimiento
fecha_nacimiento <- as.Date("1989-09-10")

# Notas de asignaturas en primer y segundo parcial
notas <- data.frame("biolog√≠a" = c(5, 7), "f√≠sica" = c(4, 5),
                    "matem√°ticas" = c(8, 9.5))
# Nombre a las filas
row.names(notas) <- c("primer_parcial", "segundo_parcial")

# N√∫meros de tel√©fono
tlf <- c("914719567", "617920765", "716505013")

# Nombres
padres <- c("Juan", "Julia")

# Guardamos TODO en una lista (con nombres de cada elemento)
datos <- list("nacimiento" = fecha_nacimiento,
              "notas_insti" = notas, "tel√©fonos" = tlf,
              "nombre_padres" = padres)
datos
names(datos)
``` 

Hemos creado una lista de 4 elementos: el elemento `nacimiento` (una fecha), el elemento `notas_insti` (un `data.frame`), el elemento `tel√©fonos` (un vector de n√∫meros) y `nombre_padres` (un vector de texto).

Una lista es una varible que en un primer nivel solo tiene una dimensi√≥n por lo que si quieres saber cuantos elementos tiene debes ejecutar la funci√≥n `length()`.

```{r}
dim(datos) # devolver√° NULL al no tener dos dimensiones
length(datos)
class(datos) # de tipo lista
```

Para acceder a un elemento de la lista tenemos dos opciones:

- Acceder por √≠ndice: con el operador `[[i]]` accedemos al elemento i-√©simo de la lista.

- Acceder por nombre: con el operador `$nombre_elemento` accedemos al elemento cuyo nombre sea `nombre_elemento`.

```{r}
datos[[1]]
datos$nacimiento

datos[[2]]
datos$notas_insti
```

Si queremos acceder a varios elementos a la vez de la lista deberemos usar el operador `[]`.

```{r}
datos[1:2]
```

Como hemos comentado, tambi√©n podemos **aplicar la recursividad** y hacer listas con otras listas dentro, de forma que para acceder a cada nivel deberemos usar el operador `[[]]`.

```{r}

lista_de_listas <- list("lista_1" = datos[3:4], "lista_2" = datos[1:2])
names(lista_de_listas) # Nombres de los elementos del primer nivel
names(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista
lista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior
```


Un ejemplo de la utilidad de las listas la tenemos en los archivos `R.Data` de vacunas que hemos cargado en nuestro script. Con `names(panel_vacunas)` podemos ver que elementos contiene en el primer nivel.

```{r include = FALSE}
load("./DATOS/panel_vacunas_ccaa.RData")
load("./DATOS/panel_vacunas_fecha.RData")
```

```{r}
names(panel_vacunas)
```

Cada elemento de la lista es un `data.frame` de una comunidad auton√≥noma, que a su vez contiene una serie de variables (columnas) para cada una de las fechas (filas): **¬°nos permite guardar ¬´datos tridimensionales¬ª!**.

```{r}
class(panel_vacunas$ES)
names(panel_vacunas$ES)
head(panel_vacunas$ES[, 1:7])
```

El acceso lo podemos realizar por orden que ocupa en la lista pero tambi√©n de forma intuitiva con `$` y el c√≥digo ISO de la comunidad aut√≥noma. Lo mismo podemos hacer con el panel de fechas, donde ahora cada elemento de la lista es una fecha, y en cada elemento de ella, est√° guardada la informaci√≥n de cada variable (columna) y cada comunidad (fila).

```{r}
names(panel_vacunas_fecha)
names(panel_vacunas_fecha$`2021-04-23`)
head(panel_vacunas_fecha$`2021-04-23`[, 1:7])
```



## Factores

Los **factores son el tipo de dato que tiene `R` para definir variables categ√≥ricas**, variables que aunque puedan ser n√∫meros, en realidad representa **categor√≠as (categor√≠a 1, 2, 3...)**. Internamente los factores se guardan como variable num√©ricas enteras (enumerando las categor√≠as) pero se nos mostar√°n con el nombre asignada a dicha categor√≠a. Para convertir una variable a factor basta con ejecutar la funci√≥n `factor()`, que nos convierte cada valor diferente en una categor√≠a (para ver valores diferentes de un vector, usar la funci√≥n `unique()`).


```{r}
datos <- c(1, 2, 2, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1)
unique(datos)
datos
datos_factor <- factor(datos) # Convertimos a factor
datos_factor 
``` 

Es importante entender que un **factor es una categor√≠a**, como rojo/blanco/negro, por lo que desde el momento en el que lo convertimos en factor, ya no podemos hacer operaciones aritm√©ticas.


```{r error = TRUE}
datos + 1
datos_factor + 1
``` 

Como puedes observar, al tenerlo en factor, adem√°s de la variable en s√≠ se nos **muestra debajo los `levels`, los nombres de las categor√≠as**. Si no le indicamos que nombres queremos, nos convierte los valores a texto y lo toma como nombre de categor√≠a. Con el **argumento `labels` podemos configurarlo** a nuestro gusto. Con la funci√≥n `levels` podemos reasignarle nombres tras su generaci√≥n.

```{r}
datos_factor <- factor(datos, labels = paste("Categor√≠a", sort(unique(datos)))) # damos nombre de categor√≠a 1, 2, 3...
datos_factor 
levels(datos_factor) <- c("C1", "C2", "C3")
datos_factor
``` 

Aunque sirve tambi√©n para variables num√©ricas, la funci√≥n **`table()` nos calcula las frecuencias de cada una de las categor√≠as**, las veces que se repiten en nuestro conjunto (es una forma eficiente de guardar categor√≠as ya que solo se guardan los valores √∫nicos y el n√∫mero de veces que se repiten, as√≠ como su lugar).

```{r}
table(datos_factor)
``` 

Una ventaja de los factores es que le podemos **indicar que considere que las categor√≠as son ordinales**: tiene una jerarqu√≠a de orden, con el argumento `ordered = TRUE`.

```{r}
notas <- c(7, 2, 10, 5, 7, 8, 10, 8, 2, 2, 5, 5, 5, 10) # notas de clase: tienen un orden
notas_factor <- factor(notas)
notas_factor[1] < notas_factor[2]

notas_factor_ordenados <- factor(notas, ordered = TRUE)
notas_factor_ordenados[1] < notas_factor_ordenados[2] # nos dice que la categor√≠a 7 no es menor que la categor√≠a 2
notas_factor_ordenados
``` 

Para pasar de factor a variable num√©rica (y poder operar con ellos), basta usar la funci√≥n `as.numeric()`.

```{r error = TRUE}
notas_factor_ordenados + 1
as.numeric(notas_factor_ordenados) + 1
mean(as.numeric(notas_factor_ordenados))
``` 

Tambi√©n podemos **convertir variables continuas (o discretas) a factores indicando los rangos de las categor√≠as** que queremos asignar con la funci√≥n `cut()`. Por ejemplo, supongamos que tenemos notas num√©ricas de clase y queremos asignar una nota categ√≥rica. En el argumento `breaks` debemos indicarle los cortes que queremos en los datos, teniendo `n+1` valores, siendo `n` el n√∫mero de categor√≠as. Con `right = FALSE` le vamos a indicar que los intervalos son abiertos por la derecha.

```{r}
notas <- c(7.4, 1.1, 2.9, 10, 5.2, 7.7, 8.9, 10, 8.1, 2.6, 2.4, 5.5, 5, 5, 10, 6.3, 9.4) # notas de clase
notas_categoricas <- cut(notas, breaks = c(0, 5, 7, 9, 10, 10.1), labels = c("suspenso", "aprobado", "notable", "sobresaliente", "mh"), right = FALSE)
notas_categoricas
``` 

Adem√°s, la funci√≥n `cut()` identifica los datos de tipo fecha, pudiendo hacer **cortes por unidades temporales**.


```{r}
fechas <- as.Date(c("2021-04-10", "2021-03-10", "2021-01-01", "2020-01-15", "2020-09-10", "2020-09-15", "2020-07-08"))
fechas_cortes <- cut(fechas, breaks = "year")
levels(fechas_cortes) <- c("2020", "2021")
fechas_cortes
``` 


## Fechas y horas

Como ya hemos dicho, las fechas y momentos temporales no ser√°n meras cadenas de caracter sino que tienen clases especiales asociadas y algunas funciones especiales que pueden sernos √∫tiles: las fechas ser√°n de tipo `dates` mientras que las horas ser√° de tipo `POSIXct` o `POSIXlt`. En el primer caso, las fechas ser√°n guardadas internamente como el **n√∫mero de d√≠as transcurridos desde el 1 de enero de 1970**, y las horas como **n√∫mero de segundos desde el 1 de enero de 1970** (para la clase `POSIXct`) o una lista de segundos, minutos y horas (para la clase `POSIXlt`).

**¬øC√≥mo obtener autom√°ticamente la fecha de hoy, por ejemplo?** La funci√≥n `Sys.Date()` nos devuelve directamente la fecha y hora en el momento de la ejecuci√≥n de la orden.

```{r}
fecha <- Sys.Date()
fecha
fecha - 7 # una semana antes
class(fecha) # de clase fecha
``` 

Para **convertir una cadena de texto a fecha**, basta usar la funci√≥n `as.Date()` con la fecha en formato `"yyyy-mm-dd"` por defecto. Si le introducimos otro tipo de formato, debemos especific√°rselo en un segundo argumento.

```{r}
as.Date("2021-03-10") # formato por defecto
as.Date("10-03-2020", "%d-%m-%Y") # con d√≠a-mes-a√±o (4 cifras)
as.Date("10-03-20", "%d-%m-%y")  # con d√≠a-mes-a√±o (2 cifras)
as.Date("03-10-2020", "%m-%d-%Y") # con mes-d√≠a-a√±o (4 cifras)
as.Date("Octubre 21, 1995 21:24", "%B %d, %Y %H:%M") # fecha escrita
``` 

F√≠jate la diferencia cuando lo convertimos en fecha

```{r error = TRUE}
"2021-03-10" - 1 # error
as.Date("2021-03-10") - 1 # d√≠a previo
``` 

Aunque aparentemente parezca una cadena de texto, prueba a ejecutar `unclass(fecha)` para comprobar que tiene internamente guardado.

```{r}
unclass(fecha)
unclass(as.Date("1969-01-01")) # justo un a√±o antes de la referencia
``` 

Para la **fecha con hora actual** podemos usar una funci√≥n similar, la funci√≥n `Sys.time()`. Al igual que la funci√≥n `as.Date()` para convertir cadenas de texto en fechas, podemos hacer uso de la funci√≥n `strptime()` para convertir cadenas de texto en fecha-hora.

```{r}
fecha_hora <- Sys.time() # fecha y hora actual en formato POSIXct
class(fecha_hora)
unclass(fecha_hora)
strptime("Octubre 21, 1995 21:24", "%B %d, %Y %H:%M") # fecha escrita


# fecha y hora actual en formato POSIXlt
fecha_hora2 <- as.POSIXlt(Sys.time())
class(fecha_hora2)
unclass(fecha_hora2)
str(unclass(fecha_hora2))
fecha_hora2$min # Accedemos a los minutos
``` 

Adem√°s tenemos disponibles funciones para extraer facilmente algunas variables temporales como el d√≠a de la semana, el mes o el cuatrimestre, con las funciones `weekdays()`, `months()`, and `quarters()`.


```{r}
weekdays(fecha)
months(fecha)
quarters(fecha)
``` 

Al igual que podemos realizar operaciones aritm√©ticas sencillas con las fechas, tambi√©n podemos **realizar comparaciones**, por ejemplo, si el d√≠a actual es menor o mayor que otra fecha dada. 

```{r}
fecha_actual <- Sys.Date()
fecha_actual > as.Date("2020-04-15")
fecha_actual < as.Date("2020-04-15")
``` 

La funci√≥n `difftime()` nos permite adem√°s hallar distancias entre fechas pero no solo en d√≠as (lo que suceder√≠a si restamos 2 fechas) sino en las unidades temporales que queramos.

```{r}
difftime(Sys.time(), as.POSIXct("2020-01-17 10:24:12 CEST"), units = "days")
difftime(Sys.time(), as.POSIXct("2020-01-17 10:24:12 CEST"), units = "hours")
difftime(Sys.time(), as.POSIXct("2020-01-17 10:24:12 CEST"), units = "weeks")
``` 


&nbsp;

<details>
  <summary>![](img/logo_info.png){width=4%}  <strong>Consejos y tips</strong></summary>
  
<!-- toc -->

* **Paquete stringr**

En dicho paquete tienes muchas **funcionalidades para trabajar con cadenas de texto** y **expresiones regulares**. En el **paquete `glue`** hay a√∫n m√°s funciones para pegar y concatenar de forma simb√≥lica cadenas de texto. Ver <https://stringr.tidyverse.org/> y <https://github.com/tidyverse/glue>

```{r stringr, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete stringr."}
knitr::include_graphics("./img/stringr.png")
```


&nbsp;  

&nbsp;  

* **Paquete lubridate**

En dicho paquete tienes muchas **funcionalidades para trabajar con fechas**. Ver <https://lubridate.tidyverse.org/>.

```{r lubridate, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete lubridate."}
knitr::include_graphics("./img/lubridate.png")
```

&nbsp;  

&nbsp;  

* **Paquete forcats**

En dicho paquete tienes muchas **funcionalidades para trabajar con factores**. Ver <https://forcats.tidyverse.org/>.

```{r forcats, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete lubridate."}
knitr::include_graphics("./img/forcats.png")
```

&nbsp;  

&nbsp;  

* **Prohibido operaciones aritm√©ticas con listas**

Una **lista no se puede vectorizar de forma inmediata**, por lo cualquier operaci√≥n aritm√©tica aplicada a una lista dar√° error (ver m√°s adelante la funci√≥n `lapply()`).

```{r error = TRUE}
datos / 2
``` 

<!-- tocstop -->
</details>


<details>
  <summary>üìù<strong>Ejercicio</strong>: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad (como dato num√©rico) y si est√°s soltero/a.</summary>
  
  
<!-- toc -->
- Soluci√≥n:

```{r}
library(lubridate)
# Creamos lista: con lubridate calculamos la diferencia de a√±os desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "√Ålvarez Li√©bana",
                       "edad" = time_length(interval(ymd("1989-09-10"), ymd(Sys.Date())), unit = "years"),
                       "soltero" = TRUE)
lista_personal

# Otra opci√≥n: la edad calculada con floor (quita decimales y se queda con la parte entera)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "√Ålvarez Li√©bana",
                       "edad" = floor(time_length(interval(ymd("1989-09-10"), ymd(Sys.Date())), unit = "years")),
                       "soltero" = TRUE)
lista_personal
```


<!-- tocstop -->
</details>


