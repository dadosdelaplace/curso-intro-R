```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# Operaciones con vectores {#operacionesvectores}

## Operaciones aritm칠ticas con vectores num칠ricos

Hemos dicho que un n칰mero es un vector de longitud 1, as칤 que toda <mark>**operaci칩n aritm칠tica**</mark> que podamos hacer con un n칰mero la vamos a poder a hacer con un vector de n칰meros, de forma que si hacemos por ejemplo la operaci칩n `2 * z`, lo que suceder치 es que **CADA ELEMENTO del vector** ser치 multiplicado por 2.


```{r}
# Multiplicamos por 2 a CADA ELEMENTO del vector
z <- c(2, 4, 6)
2 * z
```


```{r}
# Sumamos 3 a CADA ELEMENTO DEL VECTOR
z + 3
```

De la misma manera se pueden definir sumas `z + x`, ra칤ces cuadradas `sqrt(z)` o elevar **cada elemento** al cuadrado `z^2`.


```{r}
# Hacemos la ra칤z cuadrada de CADA ELEMENTO DEL VECTOR
sqrt(z)
```

```{r}
# Elevamos al cuadrado CADA ELEMENTO DEL VECTOR
z^2
```

&nbsp;


Esto 칰ltimo es bastante importante que no se te olvide ya que en otros lenguajes no siempre es as칤. En `R`, salvo que especifiquemos lo contrario, **`r colorize("toda operaci칩n ARITM칄TICA que hagas a un vector ser치 elemento a elemento", "#20935E")`**:  si multiplicas dos matrices, la operaci칩n la realizar치 elemento a elemento, no como una multiplicaci칩n matricial.

&nbsp;

Dado que la operaci칩n (por ejemplo, una suma) se realiza elemento a elemento, **쯤u칠 suceder치 si sumamos dos vectores de distinta longitud?** Prueba a definir un vector con los 4 primeros impares, e intentar hacer la suma `z + y` (un vector de longitud 3 m치s un vector de longitud 4).

```{r}
y <- c(1, 3, 5, 7)
z + y
```

`R` intenta molestarte lo menos posible, as칤 que lo que hace es **`r colorize("reciclar", "#ffc107")`**: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que har치 ser치 **reciclar** elementos del vector con menor longitud: har치 `1+2`, `3+4`, `5+6` pero... `7+2` (vuelve al primero).   

&nbsp;

Como hemos comentado anteriormente, los <mark>**valores l칩gicos**</mark> `TRUE/FALSE` son guardados internamente como `0/1` por lo que podemos usar **operaciones aritm칠ticas con ellos**. Por ejemplo, si queremos averiguar el n칰mero de elementos de un vector que cumplen una condici칩n l칩gica `< 2`, los que lo hagan tendr치n asignado un `1` y los que no un `0`, por lo que basta con sumar el vector l칩gico para obtener el n칰mero de elementos bajo dicha condici칩n.

```{r}
sum(x < 2) # sumamos el vector de TRUE/FALSE --> n칰mero de TRUE
```


## Operaciones estad칤sticas con vectores num칠ricos

Al igual que podemos ejecutar operaciones aritm칠ticas, podemos realizar tambi칠n <mark>**operaciones estad칤sticas**</mark> con los vectores, como calcular su suma (`sum()`), su media (`mean()`), su mediana (`median()`), su suma acumulada (`cumsum()` cada elemento lo acumula al anterior) o percentiles (`quantiles()`).


```{r}
sum(y) # suma
```

```{r}
mean(y) # media
```


```{r}
median(y) # mediana
```


```{r}
cumsum(y) # suma acumulada
```

```{r}
y <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)
quantile(y) # Percentiles por defecto: cuartiles (0%-25%-50%-75%-100%)
```

&nbsp;

**`r colorize("WARNING:", "#ffc107")`**

En `R` algunas **funciones tienen argumentos por defecto**, argumentos que no necesitan ser asignados un valor a priori. En el ejemplo de calcular los percentiles con `quantile()`, hay un argumento por defecto (con un valor ya asignado sino se especifica lo contrario) que es `probs = c(0, 0.25, 0.5, 0.75, 1)`. Pero dicho argumento por defecto puede ser cambiado, por ejemplo, para sacar los percentiles 15%-30%-70%-90%.

```{r}
y <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)
quantile(y, probs = c(0.15, 0.3, 0.7, 0.9)) # Percentiles p15, p30, p70 y p90
```

&nbsp;

**`r colorize("CONSEJO", "#20935E")`**

Como has podido comprobar, este otro tipo de **`r colorize("operaciones ESTAD칈STICAS no se realizan elemento a elemento", "#20935E")`**: la media o la suma las realiza tomando todos los elementos del vector.

&nbsp;


**`r colorize("GLOSARIO:", "#4197D2")`**

* **`r colorize("Media", "#4197D2")`**: medida de centralizaci칩n que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. A pesar de ser la m치s conocida, la media es **muy poco robusta**: dado un conjunto, si se introducen **valores at칤picos o outliers** (valores muy grandes o muy peque침os), la media se perturbar con mucha facilidad. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $\overline{x}$.

$$\overline{x} = \frac{\displaystyle \sum_{i=1}^{n}x_i}{n}$$

* **`r colorize("Mediana", "#4197D2")`**: medida de centralizaci칩n que consiste en, tras ordenar los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos n칰meros por debajo como por encima). M치s robusta que la media aunque menos la moda. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $Me_x$.

$$Me_x = \displaystyle \arg \min_{x_i} \left\lbrace F_i > 0.5 \right\rbrace, \quad F_i = \frac{\#\left\lbrace x_j \leq x_i \right\rbrace}{n}$$

* **`r colorize("Moda", "#4197D2")`**: medida de centralizaci칩n que consiste en encontrar el valor m치s repetido (el valor _trending_). Es la medida de centralizaci칩n m치s robusta. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $Mo_x$.


$$Mo_x = \displaystyle \arg \max_{x_i} f_i  , \quad f_i = \frac{\#\left\lbrace x_j = x_i \right\rbrace}{n}$$

&nbsp;


## Datos ausentes: NA y NaN {#ausentes}

La vida no siempre es perfecta as칤 que en muchas ocasiones nos encontraremos con lo que llamamos en estad칤stica un <mark>**dato ausente o _missing value_**</mark>, un **valor que no tenemos en nuestra variable**, y un ejemplo pr치ctico lo tenemos con los datos de vacunaci칩n de covid del Ministerio de Sanidad que hemos tenido en 2020-2021. Cada d칤a se publicaba un PDF (ya...mal) con los datos de vacunaci칩n PERO...no se publican datos los fines de semana: en dichas fechas hay datos que no tenemos, y en `R` se representan por `NA` (significa _not available_).

### NA: not available

Vamos a crear un vector de n칰meros con datos ausentes con la orden `x <- c(1, NA, 3, NA, NA, 5, 6)`: el vector tendr치 longitud 7 pero en el segundo, cuarto y quinto elemento tendremos un dato faltante, un lugar que no tenemos relleno (pero que no eliminamos).

```{r}
x <- c(1, NA, 3, NA, NA, 5, 6) # Vector num칠rico con datos faltante
length(x) # longitud del vector
x
``` 


**쯇uedes aventurar que sucede cuando multiplicamos ese vector por 2 por ejemplo?**

```{r}
2 * x # operaci칩n aritm칠tica con un vector con NA
``` 
&nbsp;

**`r colorize("WARNING:", "#ffc107")`**

Un dato que no tenemos, multiplicado por 2, sigue siendo un dato ausente. Es muy importante para evitar resultados err칩neos que entendamos que un **dato ausente no computa en una operaci칩n aritm칠tica**, es un <mark>**hueco vac칤o**</mark>. Si hacemos la suma del vector, estamos sumando n칰meros m치s datos ausentes, por lo que el resultado final ser치 tambi칠n un dato ausente. Si tenemos alg칰n dato ausente en nuestro vector, la suma final est치 a su vez ausente, 춰no podemos saber cu치nto vale!


```{r}
sum(x) # suma de un vector que contiene NA
``` 

&nbsp;

Para evitar que un dato ausente en nuestros datos nos impida hacer ciertas operaciones, en muchas funciones de `R` podemos a침adir el argumento `na.rm = TRUE`: **primero elimina los datos ausentes**, y luego ejecuta la funci칩n.

```{r}
sum(x, na.rm = TRUE) # eliminando datos ausentes
``` 

Una manera de **localizar que elementos est치n ausentes** en nuestras variables es con la funci칩n `is.na()`, una funci칩n que nos devuelve un vector de valores l칩gico: `TRUE` si el elemento est치 ausente y `FALSE` si no lo est치.

```{r}
is.na(x) # TRUE si est치 ausente (NA), FALSE si no lo est치.
``` 

Dichos **datos ausentes se pueden eliminar** (sin necesidad de sumarlos) con la funci칩n `na.omit()` (aunque a veces lo que nos interesa es que no sea ausente, introduciendo el punto medio entre su valor anterior y su valor posterior, por ejemplo).

```{r}
na.omit(x)
``` 

### NaN: not a number

Hay un **tipo de dato**, como <mark>**resultado de operaciones no permitidas o cuyo resultado es indeterminado**</mark>, que en `R` lo veremos como `NaN`: _not a number_, un resultado fruto de una indeterminaci칩n, como por ejemplo la operaci칩n `0/0` (cuyo l칤mite no est치 definido). Importante saber que tambi칠n existe una forma de denotar al infinito como `Inf`, siendo el resultado de algunas operaciones como `1/0`.

```{r}
1/0
0/0
``` 

De la misma manera que podemos localizar valores `NA`, tenemos a nuestra disposici칩n las funciones `is.infinte()` y `is.nan()` para detectar que elementos de nuestro vector son `Inf` o `NaN`, respectivamente.

```{r}
x <- c(1, NA, 3, 4, Inf, 6, 7, Inf, NaN, NA)
is.na(x)
is.nan(x)
is.infinite(x)
``` 


## Seleccionar elementos de un vector

Ya sabemos definir variables que sean vectores (recuerda: colecci칩n de valores del mismo tipo). 쯏 si del <mark>**vector original queremos EXTRAER UN SUBCONJUNTO del mismo**</mark>, por ejemplo, los primeros 10 elementos?

`R` tiene varias formas de hacer esto pero la m치s sencilla es entendiendo que si yo quiero <mark>**acceder al elemento i-칠simo**</mark> de un vector, deber칠 usar el **operador de selecci칩n `[i]`**. Veamos un ejemplo

```{r}
x <- 1:100 # Vector de longitud 100 (del 1 al 100)
y <- x[37] # Solo me interesa el elemento que ocupa el lugar 37
y
```

Dado que hemos visto que un n칰mero no es m치s que un vector de longitud uno, esta operaci칩n tambi칠n la podemos aplicar usando un vector de 칤ndices a seleccionar, de forma que le podemos indicar simultaneamente que valores que queremos

```{r}
x[c(1, 4, 51, 77)] # Solo queremos acceder a los elementos en la posici칩n 1, 4, 51, y 77
y <- c("hola", "qu칠", "tal", "todo", "ok", "?")
y[1:2] # Solo queremos acceder a los elementos en la posici칩n 1 y 2
c(1:2, length(y))
y[c(1:2, length(y))] # Solo accedemos a los elementos en la posici칩n 1, 2 y adem치s el que ocupa la 칰ltima posici칩n (recuerda: length(y) nos da la longitud total del vector)
```

Otras veces no querremos seleccionar un elemento en concreto sino **filtrar algunos elementos en concreto y no extraerlos**, para lo cual deberemos repetir la misma operaci칩n pero con el signo `-` delante: el operador `[-i]` no selecciona el elemento i-칠simo del vector sino que lo elimina en nuestro filtro.

```{r}
y
z <- y[-2] # Nos muestra todo y salvo el elemento que ocupa la segunda posici칩n
z
```

&nbsp;

Sin embargo, **lo habitual es que dicho filtro lo hagamos en base a una condici칩n l칩gica**. Supongamos que `x <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)` y `y <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)` son las edades de dos grupos de personas y que queremos quedarnos solo con los mayores edad. 쯊enemos que andar averiguando en que posici칩n se encuentran para luego seleccionarlos? No, vamos a **seleccionar los elementos que cumplen una condici칩n dada**.

```{r}
x <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)
y <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)
x[x >= 18] # mayores de 18 a침os del conjunto x
y[x >= 18] # mayores de 18 a침os del conjunto y
```

Lo que hemos hecho ha sido pasarlo como 칤ndices un vector l칩gico `TRUE/FALSE`, de forma que solo filtrar치 los que tengan un `TRUE` asignado, aquellos que cumplen la condici칩n l칩gica introducida. Esto tambi칠n nos puede servir para limpiar de datos ausentes, combinando la funci칩n `is.na()`, que nos localiza el lugar que ocupan los ausentes, con el operador `!`, que lo que hace es negar lo que venga detr치s. Tambi칠n podemos probar a **combinar condiciones l칩gicas para nuestra selecci칩n**.

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[x >= 18] # mayores de 18 a침os del conjunto x
x[is.na(x)] # solo valores ausentes
x[!is.na(x)] # sin valores ausentes: ! es el s칤mbolo de la negaci칩n
!(x >= 18) # niega los mayores de 18 a침os, todo lo que no cumpla esa condici칩n
x[x >= 18 & x <= 25] # los valores que cumplen ambas (&): entre 18 y 25 a침os
```

Como ves si un valor es `NA`, la evaluaci칩n de una condici칩n l칩gica sobre 칠l (mayor o menor de 18 a침os) nos seguir치 devolviendo `NA`. Por 칰ltimo, `R` nos permite **dar significado l칠xico** a nuestros valores (significan algo, no solo n칰meros), pudiendo poner nombres a los elementos de un vector, permitiendo su selecci칩n por dichos nombres.

```{r}
x <- c("edad" = 31, "tlf" = 613910687, "cp" = 33007) # cada n칰mero tiene un significado distinto
x
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

Con la funci칩n `names()` adem치s podemos, no solo consultar los nombres de una variable, sino cambiarlos a nuestro gusto.

```{r}
names(x) # Consultamos nombres
names(x) <- c("a침os", "m칩vil", "direcci칩n") # Cambiamos nombres
names(x) # Consultamos nuevos nombres
x
```

&nbsp;

**`r colorize("CONSEJO: all, any", "#20935E")`**
 
Existen dos funciones muy 칰tiles en `R` para saber si **TODOS** o **ALGUNO** de los elementos de un vector cumple una condici칩n. Las funciones `all()` y `any()` nos devolver치 un 칰nico valor l칩gico. Estas funciones son muy 칰tiles al final de los c칩digos para comprobar que las condiciones que tienen que verificar los datos se cumplen, y asegurarnos que el proceso se ha ejecutado correctamente (por ejemplo, que todos los datos sean positivos o no haya datos ausentes).

```{r}
x <- c(1, 2, 3, 4, 5, NA, 7)
all(x < 3)
any(x < 3)
all(x > 0)
all(na.omit(x) > 0)
all(is.na(x))
any(is.na(x))
```

&nbsp;


### which

Hemos visto como seleccionar elementos de un vector que cumplen una condici칩n, para a veces no queremos el elemento en s칤, sino el lugar que ocupa: **쯤u칠 valores de un vector cumplen una condici칩n l칩gica, qu칠 lugar ocupan?** Para obtener dicho 칤ndice tenemos a nuestro disposici칩n la funci칩n `which()`, que no nos devuelve el elemento en s칤 sino su lugar.

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[x >= 18] # Accedemos a los elementos que cumplen la condici칩n
which(x >= 18) # Obtenemos los lugares que ocupan los elementos que cumplen la condici칩n

```

Esta funci칩n es muy 칰til especialmente cuando queremos **averiguar el valor que ocupa el m치ximo/m칤nimo** de una colecci칩n de valores, con las funciones `which.max()` y `which.min()`.

```{r}
max(x, na.rm = TRUE) # m치ximo de x (si no eliminamos NA, nos devolver치 NA)
min(x, na.rm = TRUE) # m칤nimo de x (si no eliminamos NA, nos devolver치 NA)
which.max(x) # Lugar que ocupa el m치ximo
x[which.max(x)]
which.min(x) # Lugar que ocupa el m칤nimo
x[which.min(x)]
```

### NULL

A veces veremos que adem치s de `NA` y `NaN`, `R` nos muestra un dato llamado `NULL`. Cuando tenemos `NA` en alguna variable, el registro existe, pero no est치 relleno. Sin embargo, cuando tenemos un `NULL` significa que ese registro ni siquiera existe: no es un dato guardado pero cuyo valor desconocemos, es un dato que ni siquiera existe (por ejemplo, si guardamos datos de 7 personas, el dato de la octava persona no es `NA`, es que no hay octava persona directamente).

```{r}
x <- c(1, NA, 3, NA, NA, 5, 6)
x[2] # NA: el registro existe pero sin dato
names(x) # No hemos definido el nombre de las variables, as칤 que devuelve NULL
```



## Ordenar vectores

Una acci칩n habitual al trabajar con datos es <mark>**saber ordenarlos**</mark>: de menor a mayor edad, datos m치s recientes vs antiguos, etc. Para ello tenemos la funci칩n `sort()`, que podemos usar directamente para **ordenar de menor a mayor**, o con el argumento `decreasing = TRUE`, para **ordenar de mayor a menor**.

```{r}
x <- c(1, -3, 0, 10, 5, 2, 7, -13)
sort(x) # orden de menor a mayor
sort(x, decreasing = FALSE) # orden de mayor a menor
```


Otra forma de ordenar un vector es que `R` nos **devuelva los 칤ndices de los elementos ordenados**, y luego usar dichos 칤ndices para reorganizar los elementos, con la funci칩n `order()`.
```{r}
order(x) # el elemento m치s peque침o es el octavo, luego el segundo, luego el tercero, luego el primero, luego el sexto, etc.
x[order(x)] # accedemos a los 칤ndices ordenados, equivalente al sort(x)
```

&nbsp;

**`r colorize("CONSEJO: argumentos por defecto", "#20935E")`**

La funci칩n `sort()` es un buen ejemplo de que las **funciones traen definidos argumentos por defecto** (aunque no los veamos a priori). La orden `sort(x)` en realidad est치 ejecutando `sort(x, decreasing = TRUE)`, pero como es su valor por defecto, nos podemos ahorrar incluirlo. Escribe `? help sort()` en la consola y ver치s como en la cabecera de la funci칩n ya hay preasignado un `decreasing = TRUE`.





## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;


**`r colorize("Diferencia de conjuntos", "#20935E")`**

Una funci칩n muy 칰til para ver las **diferencias entre dos conjuntos** es `setdiff()`, una funci칩n que nos devuelve los elementos distintos entre dos conjuntos.

```{r}
y <- 1:10
z <- c(1, 3, 7, 10)
setdiff(y, z) # Elementos en y que no est치n en z 
```

&nbsp;

**`r colorize("Optimiza tu c칩digo", "#20935E")`**

Aunque parezca un tema menor, si tu c칩digo tarda 1 milisegundo m치s de lo que podr칤a tardar de otra forma, si esa orden se repite muchas veces, ese milisegundo extra puede ser 5, 10 o 20 minutos m치s que tu c칩digo tardar치 en ejecutarse. Hay un paquete muy 칰til en `R` para medir tiempos de distintas 칩rdenes que hacen lo mismo (el paquete `{microbenchmark}`), vamos a instalarlo.

```{r eval = FALSE}
install.packages("microbenchmark")
library(microbenchmark)
```


```{r echo = FALSE}
library(microbenchmark)
```

Este paquete contiene una orden para comparar el tiempo de dos 칩rdenes: necesita como primeros argumentos las dos 칩rdenes cuyos tiempos vamos a comparar, y un argumento `times` en el que le indicamos el n칰mero de veces que ejecutar치 cada orden para realizar los tiempos medios. Vamos a comparar los comandos de ordenaci칩n `order()` y `sort()`.

```{r}
x <- rnorm(1e3) # 1000 elementos aleatorias de una normal N(0, 1)
microbenchmark(sort(x), # primera forma
               x[order(x)], # segunda forma
               times = 1e3) # se repetir치 1000 veces
```

S칤, est치s viendo bien: aunque a priori parezca contraintuitivo, es m치s corto obtener los 칤ndices ordenados de un vector, y luego reordenarlo en base a esos 칤ndices, que la ordenaci칩n directa a trav칠s del comando `sort()` (ya que usan algoritmos de ordenaci칩n distintos).



## 游닇 Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>游닇<strong>Ejercicio 1</strong>: calcula la suma del vector `vector_num` mencionado anteriormente (definido como un vector que contenga los n칰meros 1, 10, -1 y 2). </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de n칰meros
vector_num <- c(1, 10, -1, 2)

# Suma
sum(vector_num)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 2</strong>: define otro vector `vector_num2` que contenga los n칰meros 5, -7, 8, -3, y haz la suma de `vector_num` y `vector_num2`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de n칰meros
vector_num2 <- c(5, -7, 8, -3)

# Suma
vector_num + vector_num2
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 3</strong>: calcula el n칰mero de elementos mayores que 0 del resultado de la suma de `vector_num` y `vector_num2`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de n칰meros
vector_suma <- vector_num + vector_num2

# Suma
sum(vector_suma > 0)
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 4</strong>: calcula la versi칩n ordenada del vector anterior `vector_num`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Ordenamos el vector (con sort)
sort(vector_num)

# Ordenamos el vector  (con order)
vector_num[order(vector_num)]
```

<!-- tocstop -->
</details>

&nbsp;



<details>
  <summary>游닇<strong>Ejercicio 5</strong>: encuentra del vector `vector_num` original el lugar (el 칤ndice) que ocupa su m칤nimo y su m치ximo. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
vector_num <- c(1, 10, -1, 2)

# Encontrando el lugar que ocupa el m치ximo y m칤nimo
which.max(vector_num)
which.min(vector_num)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 6</strong>: encuentra del vector `vector_num` los elementos mayores que 1 y menores que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector l칩gico: mayores que 1 y menores que 7
vector_num > 1 & vector_num < 7

# 쯉on todos positivos?
all(vector_num > 0)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 7</strong>: define el vector `c(-1, 0, 4, 5, -2)`, calcula la ra칤z cuadrada del vector y determina que lugares son ausente de tipo `NaN`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector
x <- c(-1, 0, 4, 5, -2)

# 쮺u치les son ausentes tras aplicar la ra칤z cuadrada?
is.nan(sqrt(x))
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 8</strong>: define el vector de los primeros n칰meros impares (hasta el 21) y extrae los elementos que ocupan los lugares 1, 4, 5, 8. Elimina del vector el segundo elemento</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de impares (de 1 a 21 saltando de dos en dos)
x <- seq(1, 21, by = 2)

# Seleccionamos elementos
x[c(1, 4, 5, 8)]

# Eliminamos elementos
y <- x[-2]
y
```

<!-- tocstop -->
</details>


