```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) DATAVIZ: introducci칩n a la visualizaci칩n {-}

# Tidy data: ordenando datos {#procesamiento}

Empieza lo interesante :)

```{r flujo-tidy-data, echo = FALSE,  out.width = "60%", fig.align = "center", fig.cap = "Flujo deseable de datos seg칰n Hadley Wickham, extra칤da de <https://r4ds.had.co.nz/wrangle-intro.html>"}
knitr::include_graphics("./img/flujo_tidy_data.jpg")
``` 

F칤jate bien en el anterior **flujo de trabajo**: aunque el objetivo de este manual es muy introductorio, y no vamos a profundizar excesivamente en ninguna de las etapas, si queremos acabar teniendo unas nociones b치sicas de comunicar los datos **vamos a necesitar algunas nociones b치sicas de c칩mo prepararlos y de c칩mo modelizarlos**.

El **primero de los pasos**, la [importaci칩n de datos](#importar-exportar), la hemos revisado de forma superficial en la Secci칩n \@ref(importar-exportar), pero **nos bastar치 con lo aprendido** para poder empezar a manipular datos. Antes de pasar al segundo paso, **la limpieza de los datos**, vamos a repasar los tipos de datos que hemos hasta ahora.

## Repaso: tipos de datos {#repaso_datos}

::: {.rmdnote}

**`r colorize("쯈u칠 datos hemos aprendido a manejar?", "#4197D2")`**

```{r echo = FALSE}
library(knitr)
paquetes <-
  data.frame("tipo de dato" = c("x <- 1 (dato num칠rico)",
                                "x <- c(1, 2, 3) (vector de n칰meros)",
                                "x <- c('a', 'b', 'c') (vector de caracteres)",
                                "x <- matrix(1:6, nrow = 2)",
                                "x <- data.frame('a' = 1:3, 'b' = c('a', 'b', 'c'), 'c' = c(TRUE, TRUE, FALSE))",
                                "x <- list(1:3, c('a'), c(TRUE, FALSE))"),
             "descripci칩n" = c("vector de longitud 1",
                               "vector (mismo tipo)",
                               "vector (mismo tipo)",
                               "matriz (mismo tipo, misma longitud)",
                               "data.frame (distinto tipo, misma longitud)",
                               "lista (distinto tipo, distinta longitud)"))
kable(paquetes, col.names = c("paquetes", "descripci칩n"), align = "ll",
      caption = "Tipos de datos mencionados hasta ahora")
``` 
:::

El cuadro de arriba es un **resumen de los tipos de datos que ya conocemos**. 쮼xisten m치s?

La respuesta te la estar치s imaginando: s칤. De hecho no es solo que existan m치s sino que **puedes crear tus propias clases de variables**, pero seguramente acabar치n siendo, en su nivel m치s profundo, una combinaci칩n de alguna de las estructuras que ya conocemos. El objetivo de este curso es empezar a ser aut칩nomo/a en el an치lisis de datos, pero **no es un curso profundo de R**, as칤 que (de momento) vamos a quedarnos como estamos.

Si es importante entender las diferencias entre los datos que ya hemos definido.

* **Vectores**: es el tipo de dato m치s simple, una colecci칩n de valores **PERO DEL MISMO TIPO**. Los vectores pueden ser de longitud 1 (valores individuales a secas), una **colecci칩n de n칰meros**, una **colecci칩n de cadenas de texto** o una **colecci칩n de valores l칩gicos** (pudiendo tener dentro datos ausentes, o valores especiales como `Inf` o `NaN`)

* **Matrices**: se pueden entender como una especie de colecci칩n de vectores, una colecci칩n de colecciones, un tipo de dato **BIDIMENSIONAL**. Una matriz se conforma de filas y columnas pero, de nuevo, **LOS DATOS DEBEN SER DEL MISMO TIPO**, y los vectores concatenados que forma las filas y/o columnas **DEBEN TENER LA MISMA LONGITUD**.

* **data.frame**: son datos estructurados, lo que comunmente conocemos como 춺tablas췉. A diferencia de las matrices, aunque deben **SEGUIR TENIENDO LA MISMA LONGITUD**, las variables que lo conforman pueden ser de **TIPOS DIFERENTES**, puediendo tener el mismo conjunto de datos num칠ricos, caracteres, l칩gicos, etc.

* **Listas**: las listas son una concatenaci칩n de elementos, a secas, de forma que nos permite concatenar cualquier tipo de dato anterior, pudiendo ser de **DIFERENTE LONGITUD Y DIFERENTE TIPO**.
      
::: {.rmdwarning}

Como hemos mencionado, una **`r colorize("lista no se puede vectorizar de forma inmediata", "#ffc107")`**, por lo cualquier operaci칩n aritm칠tica aplicada a una lista dar치 error. Para poder operar con ellas tenemos una opci칩n que es aplicar la funci칩n `lapply()`, o directamente acudir al paquete `{purrr}`.

```{r eval = FALSE}
install.packages("purrr") # solo la primera vez
```

Veamos un ejemplo muy sencillo (te animo a investigar en dicho paquete pero se escapa de los objetivos del curso): vamos definir una lista y a **aplicar la misma funci칩n para cada uno de los elementos de la misma**.

```{r}
library(purrr)

# Creamos una lista de tres elementos
x <- list(c(1, 2, 3), c(4, 5, 6, 7), c(8, 9, 10, 11, 12))

# Aplicamos una funci칩n a cada elemento de la lista
map(x, function(x) { sum(x) })
```

Si no indicamos nada, la salida ser치 a su vez una lista. Dado que la funci칩n que vamos a aplicar es la suma de cada uno de los elementos que conforman la lista original, y nos **devolver치 en cada simplemente un n칰mero**, quiz치s puede ser m치s 칰til pedir que nos lo devuelva en un vector de n칰meros.

```{r}
# Aplicamos una funci칩n a cada elemento de la lista
# y le pedimos que nos devuelva un vector de n칰meros
map_dbl(x, function(x) { sum(x) })
```
:::


## Mejorando los data.frame: tibble {#tibble}

Antes de ordenar, limpiar y procesar nuestros datos, vamos a ver un tipo de dato que mencionamos por encima en su momento: las tablas `tibble`. Los datos en formato `tibble` (del paquete `{tibble}`) son un **tipo de `data.frame` mejorado, para una gesti칩n m치s 치gil, eficiente y coherente**. Las **tablas en formato tibble (su clase ser치 tbl_df)** tiene 4 ventajas principales frente a los ya vistos `data.frame`:

* Permite **imprimir por consola la tabla con mayor informaci칩n** de las variables, y **solo imprime por defecto las primeras filas**.

```{r}
library(tibble)

# data.frame
tabla_df <-
  data.frame("x" = 1:50,
             "y" = rep(c("a", "b", "c", "d", "e"), 10),
             "z" = 11:60,
             "logica" = rep(c(TRUE, TRUE, FALSE, TRUE, FALSE), 10))
tabla_df

# tibble
tabla_tb <- tibble("x" = 1:50,
             "y" = rep(c("a", "b", "c", "d", "e"), 10),
             "z" = 11:60,
             "logica" = rep(c(TRUE, TRUE, FALSE, TRUE, FALSE), 10))
tabla_tb
```

Puedes imprimir las filas y columnas que quieras con `print()`, pero por defecto te aseguras de **no saturar la consola**.


```{r}
print(tabla_tb, n = 13, width = Inf)
```


*  Los **datos de tipo caracter (cadenas de texto) son guardados como tal** (y no como factores).

```{r}
# Caracteres en un data.frame
tabla_df$y

# Caracteres en un tibble
tabla_tb$y
```


* La **funci칩n `tibble()` construye las variables secuencialmente**, pudiendo hacer uso en la propia definici칩n de variables reci칠n definidas en dicha definici칩n.

```{r error = TRUE}
# data.frame
data.frame("x" = 1:5,
           "y" = c("a", "b", "c", "d", "e"),
           "z" = 11:15,
           "logica" = c(TRUE, TRUE, FALSE, TRUE, FALSE),
           "x*z" = x * z)

# tibble
tibble("x" = 1:5,
       "y" = c("a", "b", "c", "d", "e"),
       "z" = 11:15,
       "logica" = c(TRUE, TRUE, FALSE, TRUE, FALSE),
       "x*z" = x * z)
```

* Si **accedes a una columna que no existe avisa** con un warning.

```{r warning = TRUE, error = TRUE}
# data.frame
tabla_df$variable_inexistente

# tibble
tabla_tb$variable_inexistente
```

* No solo no te cambiar치 el tipo de datos sino que **no te cambiar치 el nombre de las variables** (los `data.frame` transforma los caracteres que no sean letras).

```{r}
# data.frame
data.frame(":)" = "emoticono", " " = "en blanco", "2000" = "n칰mero")

# tibble
tibble(":)" = "emoticono", " " = "en blanco", "2000" = "n칰mero")
```

::: {.rmdimportant}

**`r colorize("CONSEJO: convertir a tibble", "#20935E")`**

Si ya tienes un `data.frame` es altamente recomendable convertirlo a tibble con `as_tibble()`

```{r}
as_tibble(tabla_df)
```
:::


Puedes consultar m치s funcionalidades en <https://tibble.tidyverse.org/>.

## Tidy data vs messy data {#tidy_data}

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

Hasta ahora solo le hemos dado importancia al 춺qu칠췉 pero no al **춺c칩mo췉 manejamos los datos**. La **organizaci칩n de nuestros datos** es fundamental para que la preparaci칩n y explotaci칩n de los datos sea **lo m치s eficiente posible**: la limpieza y preprocesamiento puede llevarnos hasta el **80% del tiempo** en nuestro an치lisis si no se hace forma correcta [@DasuJohnson03].

El concepto _tidy data_ fue introducido por **Hadley Wickham** [@Wickham14] como objetivo del entorno de paquetes que posteriormente se fueron desarrollando en el entorno `{tidyverse}`. Los conjuntos _tidy_ o **datos ordenados** tienen tres objetivos

* **Estandarizaci칩n** en su estructura.
* **Sencillez** en su manipulaci칩n.
* Listos para ser **modelizados y visualizados**.

Para ello, los **datos ordenados** o _tidy data_ deben cumplir:

1. Cada **variable** medida tiene que estar en una **columna**.
2. Cada **observaci칩n/registro/individuo** de cada una de esas variables tiene que estar en una **fila diferente**.
3. Cada **celda** de la tabla debe contener un **칰nico valor**.
4. Cada **conjunto o unidad observacional** debe conformar una **tabla**.
5. Si contamos con **m칰ltiples tablas**, debemos tener una **columna com칰n** en cada una que nos permita **cruzarlas**.

```{r tidy-data, echo = FALSE,  out.width = "80%", fig.align = "center", fig.cap = "Infograf칤a con datos ordenados (tidy data) extra칤da de <https://r4ds.had.co.nz/tidy-data.html>"}
knitr::include_graphics("./img/tidy_data.png")
``` 

Lo contrario lo llamaremos **datos desordenados** o _messy data_. Para trabajar con los datos vamos a cargar `{tidyverse}`, un entorno de paquetes para el manejo de datos (ver m치s detalles en [Transformando los datos: incursi칩n al universo tidyverse](#tidyverse)).

```{r eval = FALSE}
install.packages("tidyverse") # SOLO la primera vez
```

```{r}
library(tidyverse)
```


### Messy data: valores en columnas en lugar de variables

Vamos a visualizar la tabla `table4a` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`).

```{r}
table4a
```

Si te fijas, tenemos una columna `country`, representando una variable con el nombre de los pa칤ses, **춰pero las otras columnas no representan cada una a una variables!** Ambas son la misma variable, solo que medida en a침os distintos (que deber칤a ser a su vez otra variable): **cada fila est치 representando dos observaciones** (1999, 2000) en lugar de un solo registro. Lo que haremos ser치 incluir una nueva columna llamada `year` que nos marque el a침o y otra `values` que nos diga el valor de la variable de inter칠s en cada uno de esos a침os.

Con la funci칩n `pivot_longer` del mencionada paquete le indicaremos lo siguiente:

- `cols`: el nombre de las columnas que vamos a **pivotar** (con comillas porque son n칰meros, no texto como nombre).
- `names_to`: el nombre de la columna a la que vamos a mandar los valores que figuran ahora en los nombres de las columnas.
- `values_to`: el nombre de la columna a la que vamos a mandar los valores.

```{r}
table4a %>% pivot_longer(cols = c("1999", "2000"),
                         names_to = "year",
                         values_to = "values")
```

Ahora tenemos un **registro por fila, una variable por columna y cada celda representa un 칰nico valor**. Este ejemplo de _messy data_ lo podemos encontrar muy a menudo cuando **construimos rangos de variables** pensando que es mejor tener una tabla m치s compacta (alargar la tabla a lo ancho en lugar de a lo largo). Es el caso de la tabla `relig_income`.

```{r}
relig_income
```

Salvo la primera, el resto de columnas tienen como **nombre los valores de una variable en s칤 misma** (ingresos). Para ordenar los datos vamos a razonar de la misma manera solo que ahora, en lugar de indicarle el nombre de todas las columnas que queremos usar de entrada, vamos a **indicarle de forma m치s corta la columna que NO queremos seleccionar**.

```{r}
# No necesitamos las comillas en el nombre de columnas salvo que tengan caracteres que no sean letras
relig_income %>% pivot_longer(-religion, names_to = "ingresos",
                              values_to = "frecuencia")
```

Lo que hacemos con `pivot_longer()` es **춺ampliar췉 la tabla, haci칠ndola m치s larga (m치s filas) pero con menos columnas**.


### Messy data: una observaci칩n guardada en varias filas


Vamos a visualizar la tabla `table2` del paquete `{tidyr}`.

```{r}
table2
```

F칤jate en las cuatro primeras filas: los registros con el mismo a침o deber칤an ser el mismo, es la misma informaci칩n, deber칤a estar en la misma fila, pero est치 dividada en dos. Por un lado una fila para la variable `cases` y otra para `population`. Lo que haremos ser치 lo opuesto a antes: con `pivot_wider()` **춺ampliaremos췉 la tabla a lo ancho, haci칠ndola menos (menos filas) pero con m치s columnas**.

- `names_from`: el nombre de la columna de la que vamos a sacar las nuevas columnas que vamos a crear (`cases` y `population`).
- `values_from`: el nombre de la columna de la que vamos a sacar los valores.

```{r}
table2 %>% pivot_wider(names_from = type, values_from = count)
```

Ahora tenemos **cada registro en una fila**, que nos indica pa칤s-a침o-casos-poblaci칩n.

### Messy data: una celda con m칰ltiples valores

Por 칰ltimo vamos a visualizar la tabla `table3` del paquete `{tidyr}`.

```{r}
table3
```

En la variable `rate` hay guardados dos valores, separados por `/`, lo que hace que en **una celda no tiene un 칰nico valor sino dos**. La funci칩n `separate()` del paquete `{tidyr}` nos permitir치 **separar los m칰ltiples valores de la columna** `rate` simplemente indic치ndole el nombre de las nuevas columnas en el argumento `into = ...`, creando una nueva columna para cada uno de ellos.

```{r}
table3 %>% separate(rate, into = c("cases", "population"))
```

Por defecto lo que hace es **localizar como separador cualquier caracter que no sea alfa-num칠rico**. Si queremos un caracter concreto para dividir podemos indic치rselo expl칤citamente

```{r}
table3 %>% separate(rate, into = c("cases", "population"), sep = "/")
```

Si **usas un separador que no est치 en los datos** te devolver치 dichas columnas vac칤as ya que no ha podido dividirlas.

```{r warning = TRUE}
table3 %>% separate(rate, into = c("cases", "population"), sep = ".")
```

::: {.rmdimportant}

**`r colorize("CONSEJO: convertir los datos", "#20935E")`**

Una opci칩n muy 칰til que podemos usar al aplicar la separaci칩n de los m칰ltiples valores es **convertir los datos al tipo adecuado**. Los datos unidos en `rate` eran caracteres ya que ten칤a el separador `/` (no pod칤an ser num칠ricos). Al separarlos, por defecto, aunque ahora ya son solo n칰meros, los separa como si fueran textos. Con `convert = TRUE` podemos indicarle que identifique el tipo de dato y lo convierta (f칤jate en la cabecera de las columnas ahora).

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE)
```
:::

Dicha funci칩n tambi칠n puede ser usada para **dividir cifras, como por ejemplo el a침o**

```{r warning = TRUE}
table3 %>% separate(year,
                    into = c("siglo", "a침o"),
                    sep = 2)
```
  
De la misma manera que podemos separar columnas **tambi칠n podemos unirlas**. Para ello vamos a usar la tabla `table5` del ya mencionado paquete. Con la funci칩n `unite()` vamos a unir el siglo (en `century`) y el a침o (en `year`), y al inicio le indicaremos como se llamar치 la nueva variable (`a침o_completo`).

```{r}
table5 %>% unite(a침o_completo, century, year)
```

Como pasaba en `separate()`, tiene un argumento de separador por defecto, en este caso `sep = "_"`. **Si queremos cambiarlo podemos hacerlo indic치ndoselo expl칤citamente**.

```{r}
table5 %>%
  unite(a침o_completo, century, year, sep = "")
```





## 游닇 Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>游닇<strong>Ejercicio 1</strong>: 쯘s el conjunto de datos `datasets::anscombe` (del paquete `{datasets}`) de tipo `tibble`? </summary>
  
<!-- toc -->
- Soluci칩n:

Recuerda que podemos cargar elementos de un paquete (en este caso `{datasets}`) cargando `library(datasets)` y luego el elemento, o bien `datasets::anscombe` (prefijo::nombre).

La respuesta: NO. Tienes muchas formas de comprobarlo si imprimes el conjunto por defecto.

```{r}
mtcars
```

- Imprime por defecto todas las filas.
- No especifica al imprimir que es de tipo `tibble`.
- No especifica al imprimir el tipo de dato de las columnas.
- Imprime el nombre de las filas (el nombre de los modelos) como si fuera una variable (춰que no existe!).

As칤 deber칤a de salir si fuera `tibble`.

```{r}
as_tibble(mtcars)
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>游닇<strong>Ejercicio 2</strong>: define un `tibble` con tres variables num칠ricas, tal que la tercera sea el producto de las dos primeras. Int칠ntalo hacer con un `data.frame`</summary>
  
<!-- toc -->
- Soluci칩n:

Un ejemplo:

```{r}
tibble("a" = 1:7, "b" = 11:17, "c" = a * b)
```

Si lo intentamos con un `data.frame`, intentar치 buscar una variable real que tengamos guardada que se llame `a` y `b`, sin encontrarlas.

```{r error = TRUE}
data.frame("a" = 1:7, "b" = 11:17, "c" = a * b)
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 3</strong>: define un `tibble` con tres variables de nombres `variable`, `2`, `tercera :)`, e intenta acceder a ellas.</summary>
  
<!-- toc -->
- Soluci칩n:

Las variables solo con caracteres del alfabeto se podr치n acceder sin necesidad de comillas.

```{r}
# Definimos el tibble
datos_tb <- tibble("variable" = 1:7, "tercera falsa :)" = 0,
                   "2" = 11:17)

# Accedemos a sus columnas
datos_tb$variable
datos_tb$`tercera falsa :)`
datos_tb$`2`
```

Tambi칠n se puede acceder por el orden que ocupan:

```{r}
datos_tb[1]
datos_tb[2]
datos_tb[3]
```

Y tambi칠n por el nombre entre corchetes (doble corchete extrae la variable fuera del tibble, corchete simple en formato tibble):

```{r}
datos_tb["variable"]
datos_tb[["variable"]]

datos_tb["tercera falsa :)"]
datos_tb["2"]
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 4</strong>: convierte en _tidy data_ el siguiente `data.frame`.</summary>

```{r}
tabla_tb <- tibble("trimestre" = c("T1", "T2", "T3"),
                   "2020" = c(10, 12, 7.5),
                   "2021" = c(8, 0, 9))
```

<!-- toc -->
- Soluci칩n:

El problema es que las dos columnas con nombres de a침o son en realidad valores que deber칤an pasar a ser variables, as칤 que deber칤amos disminuir aplicar `pivot_longer()`

```{r}
# Aplicamos pivot_longer
tabla_tb %>% pivot_longer(cols = c("2020", "2021"),
                          names_to = "a침o", values_to = "valores")
```

<!-- tocstop -->
</details>


&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 5</strong>: convierte en _tidy data_ el siguiente `data.frame`.</summary>

```{r}
tabla_tb <- tibble("a침o" = c(2019, 2019, 2020, 2020, 2021, 2021),
                   "variable" = c("A", "B", "A", "B", "A", "B"),
                   "valor" = c(10, 9383, 7.58, 10839, 9, 32949))
```

<!-- toc -->
- Soluci칩n:

El problema es que las filas que comparten a침o son el mismo registro (pero con dos caracter칤sticas que tenemos divididas en dos filas), as칤 que deber칤amos disminuir aplicar `pivot_wider()`

```{r}
# Aplicamos pivot_wider
tabla_tb %>% pivot_wider(names_from = "variable", values_from = "valor")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>游닇<strong>Ejercicio 6</strong>: convierte en _tidy data_ la tabla `table5` del paquete `{tidyr}`.</summary>

<!-- toc -->
- Soluci칩n:

Primero uniremos el siglo y las dos 칰ltimas cifras del a침o para obtener el a침o completo (guardado en `a침o`)

```{r}
table5 %>%
  unite(a침o, century, year, sep = "")
```

Tras ello deberemos separar el valor del ratio en denominador y numerador (ya que ahora hay dos valores en una celda), y convertiremos el tipo de dato en la salida para que sea n칰mero.

```{r}
table5 %>%
  unite(a침o, century, year, sep = "") %>%
  separate(rate, c("numerador", "denominador"), convert = TRUE)

```

<!-- tocstop -->
</details>




