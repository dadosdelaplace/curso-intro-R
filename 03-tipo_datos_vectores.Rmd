```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Conceptos b√°sicos {-}

# Tipos de datos I: vectores {#vectores}


Bien, ya controlamos la calculadora. Vamos a ir m√°s all√°: ¬øy si en lugar de tener un solo n√∫mero tenemos una <mark>**colecci√≥n de elementos**</mark>? En este cap√≠tulo vamos a ver un cl√°sico de cualquier lenguaje de programaci√≥n: los <mark>**vectores o arrays**</mark>, una <mark>**concatenaci√≥n**</mark> de elementos (del mismo tipo). De hecho un n√∫mero individual (por ejemplo, `1`) es en realidad un vector de longitud uno (un solo elemento).




## Vectores num√©ricos


La forma m√°s sencilla de **crear un vector** en `R` es con el comando `c()` (de **concatenar elementos**), y basta con introducir sus elementos entre par√©ntesis, y separados por comas. Vamos a crear el vector con los tres primeros n√∫meros naturales pares (el 0 no es natural, no seas b√°rbaro/a).

```{r}
z <- c(2, 4, 6)
z
```

Como ves ahora en el **environment (entorno, arriba a la derecha) tenemos una colecci√≥n de elementos**, tres en concreto, guardados en una misma variable `z`. La longitud de un vector se puede calcular con el comando `length()` (nos devolver√° el n√∫mero de elementos de la variable que le pasemos como argumento).

```{r}
length(z)
```

Adem√°s podemos **concatenar a su vez vectores**: vamos a concatenar el vector `z` consigo mismo, y a√±adi√©ndole al final un 8.

```{r}
c(z, z, 8)
```

Esta √∫ltima concatenaci√≥n lo que nos ha dado son, primero, los tres pares que ya ten√≠amos en `z`, despu√©s de nuevo los tres primeros pares, y por √∫ltimo un 8.


## Secuencias num√©ricas con un patr√≥n

Muchas veces nos gustar√≠a **crear vectores de una forma mucho m√°s r√°pida**. Supongamos que queremos el vector de los primeros 21 n√∫meros naturales. Si construy√©ramos el vector como antes, tendr√≠amos que ejecutar el comando `c(1, 2, 3, 4, 5, ...)` hasta llegar al n√∫mero 21. ¬øUn poco largo, no?

Hay un atajo: el comando `seq()` nos permite crear una <mark>**secuencia desde un elemento inicial hasta un elemento final**</mark>, avanzando de uno en uno.

```{r}
seq(1, 21) # secuencia desde 1 hasta 21 de uno en uno
```

Es importante que no perdamos el foco de que <mark>**programar es similar a escribir en un idioma**</mark>, por lo que si hay algo que se puede decir de una forma m√°s limpia y que se entienda mejor, ¬øpor qu√© no usarlo? Siempre que queramos definir secuencias entre dos n√∫meros naturales (por ejemplo, entre `1` y un valor `n`), cuya distancia entre elementos consecutivos sea uno, el comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Adem√°s, si el elemento inicial es mayor que el final, `R` entender√° solo que la secuencia la queremo decreciente.

```{r}
n <- 21
1:n # secuencia desde 1 hasta n (21) de uno en uno
n:1 # secuencia decreciente
```


&nbsp;

Tambi√©n podemos definir **otro tipo de distancia entre dos elementos consecutivos** (conocido como **paso de discretizaci√≥n**), por ejemplo de 0.5 en 0.5.

```{r}
seq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5
```

Otras veces nos interesar√° definir una secuencia entre un valor inicial y un valor final, pero nos da igual la distancia entre cada elemento: solo nos importa que tenga un n√∫mero concreto de elementos (y que sea `R` el que decida la distancia entre elementos consecutivos para conseguirlo).

```{r}
seq(1, 50, l = 11) # secuencia desde 1 a 50 de longitud 11
```

&nbsp;

Otro atajo que podemos usar para definir secuencias de n√∫meros con un patr√≥n es definir <mark>**vectores de elementos repetidos**</mark>, por ejemplo un vector lleno de ceros. La funci√≥n `rep()` nos permite repetir un elemento un n√∫mero fijado de veces.

```{r}
rep(0, 7) # vector de 7 ceros
```

No solo podemos repetir un n√∫mero sino que podemos repetir vectores enteros.

```{r}
rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces
```

Esa repetici√≥n adem√°s podemos definirla tambi√©n de forma **intercalada**: en lugar de repetir `c(0, 1, 2)` cuatro veces seguidas, queremos cuatro 0, despu√©s cuatro 1, y despu√©s cuatro 2.

```{r}
rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2
```


## Vectores de caracteres (texto)

Un error com√∫n es asociar el concepto de vectores solo a n√∫meros: un <mark>**vector es una colecci√≥n o concatenaci√≥n de elementos del mismo tipo**</mark> pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en `R` se llaman `char`): `"Mi"`, `"nombre"`, `"es"` `"Javier"`.

Como ves las variables de tipo `char` o `character` van entre comillas dobles, ya que es un <mark>**cadena de texto**</mark>.

```{r}
mi_nombre <- c("Mi", "nombre", "es", "Javier")
mi_nombre
```

Ya tenemos nuestro primer vector de texto de longitud 4. Las **cadenas de texto** son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritm√©ticas como la suma o la media, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la funci√≥n `paste()`. Dicha funci√≥n nos permite convertir un vector de 4 palabras en una frase, decidiendo que caracter queremos que vaya entre palabra con el argumento `collapse =`.


```{r}
paste(mi_nombre, collapse = "") # todo junto
paste(mi_nombre, collapse = " ") # separados por un espacio
paste(mi_nombre, collapse = ".") # separados por un punto .
```

Si queremos pegar los elementos de la cadena de texto sin ning√∫n tipo de caracter, existe una forma m√°s abreviada y limpia de ejecutar la orden `paste(mi_nombre, collapse = "")`, usando la funci√≥n `paste0()` 

```{r}
paste0(mi_nombre) # todo junto sin nada separando
```

Esta funci√≥n es muy √∫til si queremos definir variables de texto que compartan por ejemplo un prefijo (`variable_1`, `variable_2`, ...)

```{r}
paste0("variable", 1:7) # a la palabra ¬´variable¬ª le pegamos los n√∫meros del 1 al 7
paste("variable", 1:7, sep = "_") # separado por una barra baja
```

### Paquete glue

  
Otra **forma m√°s intuitiva de trabajar con textos y variables num√©ricas** es usar el paquete `{glue}`, que nos permite pegar cadenas de texto a variables num√©ricas de **forma simb√≥lica**.

```{r eval = FALSE}
install.packages("glue")
library(glue)
```

```{r eval = FALSE}
edad <- 10:15 # edades
glue("La edad es de {edad} a√±os")
```

```{r echo = FALSE}
library(glue)
edad <- 10:15 # edades
unidades <- "a√±os"
glue("La edad es de {edad} {unidades}")
```

Tambi√©n podemos hacer uso de dicha funci√≥n sin tener los valores num√©ricos previamente guardados en variables.

```{r}
# Otra forma sin definir variables a priori
glue("La edad es de {10:15} a√±os")
```

Ya sabemos trabajar con textos :) 

¬øY si queremos **pasar todo a may√∫scula**? ¬øO **todo a min√∫scula**? ¬øY si queremos **sustituir un caracter (por ejemplo `.`) por otro en todos los elementos**? `R` tambi√©n nos proporciona algunas funciones muy sencillas (del paquete `{base}`) de usar para dichas tareas. Aqu√≠ un ejemplo de algunas de ellas.

```{r}
texto <- c("Hola.", "qu√©", "ase?", "todo", "bien.", "y yo",
           "que", "ME", "ALEGRO")
toupper(texto) # todo a may√∫scula
tolower(texto) # todo a min√∫scula
```

El paquete `{base}` tambi√©n nos permite buscar y reemplazar patrones concretos en cadenas de texta (por ejemplo, sustituir toda letra ¬´o¬ª por el caracter ¬´*¬ª).

```{r}
gsub("o", "*", texto) # toda "o" en el texto ser√° sustituida por *
```

&nbsp;


## Vectores l√≥gicos (TRUE/FALSE)

- [X] Variables num√©ricas (individuales)
- [X] Vectores de n√∫meros
- [X] Vectores de caracteres
- [ ] Vectores l√≥gicos

Veamos un √∫ltimo tipo de vectores importante en todo lenguaje de programaci√≥n: los <mark>**vectores de valores l√≥gicos**</mark>. Un **valor l√≥gico** puede tomar tres valores:

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).
* `NA` (dato ausente, son las siglas de _not available_, cuando pretendemos aplicar una comparaci√≥n a un dato ya de por si ausente).

Estos valores son resultado de evaluar <mark>**condiciones l√≥gicas**</mark>. Por ejemplo, imaginemos que definimos un vector de n√∫meros `x <- c(1.5, -1, 2, 4, 3, -4)`. ¬øQu√© numeros del vector son menores que 2? Basta con que ejecutemos la orden `x < 2`, que nos devolver√° `TRUE/FALSE` en cada hueco, en funci√≥n de si cumple (`TRUE`) o no (`FALSE`) la condici√≥n pedida.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 2
```

El primer, segundo y sexto elemento del vector son los √∫nicos elementos (estrictamente) menores que `2`, de ah√≠ que en el primer, segundo y sexto elemento aparezca un `TRUE` y en el resto un `FALSE`. Es **importante** recordar que al **evaluar una condici√≥n l√≥gica sobre un vector** de longitud `n`, la **salida sigue siendo un vector** de longitud `n` pero con valores l√≥gicos.

Dicha condici√≥n l√≥gica puede hacerse con otros operadores como `<=`, `>` o `>=`. 

```{r}
x <= 2
```

```{r}
x > 2
```

```{r}
x >= 2
```

&nbsp;

Tambi√©n podemos **comparar si es igual a otro elemento**, para lo que usaremos el operador `==`, pudiendo usar tambi√©n su opuesto `!=` (¬´distinto de¬ª).

```{r}
x == 2
```

```{r}
x != 2
```

Las **condiciones pueden ser combinadas**, principalmente de dos maneras:

- **Intersecci√≥n**: todas las condiciones concatenadas se deben cumplir (conjunci√≥n `y`, operador `&`) para devolver un `TRUE`.

- **Uni√≥n**: basta con que una de las condiciones concatenadas se cumpla (conjunci√≥n `o`, operador `|`) para devolver un `TRUE`.

Por ejemplo, vamos a calcular qu√© elementos del vector `c(1.5, -1, 2, 4, 3, -4)` sean menores que 3 pero (y) mayores que 0, y los elementos menores que 2 o mayores que 3.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 3 & x > 0 # Solo los que cumplen ambas condiciones
x < 2 | x > 3 # Los cumplen al menos una de ellas
```


## Fechas


* `numeric`: variables de tipo num√©ricas (algunas veces vendr√°n indicados como `int` o integer para enteros, y `dbl` o `double` para n√∫meros con decimales).
* `character`: variables de tipo caracter.
* `Date`: variables de tipo fecha.

&nbsp;

Hay un tipo muy especial de datos que a√∫n no hemos visto que son los <mark>**datos tipo fecha**</mark>. Una fecha podr√≠a ser a priori una simple cadena de texto `"2021-04-21"` pero podemos usar la funci√≥n `as.Date()` para que `R` entienda que esa cadena de texto representa un instante temporal. F√≠jate la diferencia entre una fecha en texto y una fecha con `as.Date()`.

```{r error = TRUE}
fecha_char <- "2021-04-21"
fecha_date <- as.Date(fecha_char, format = "%Y-%m-%d")
fecha_char + 1
fecha_date + 1
```

En el momento en que convertimos la cadena de texto a fecha, aunque se visualice como tal, internamente es un n√∫mero, por lo que podemos restar fechas (d√≠as entre ambas), **podemos sumar n√∫meros a fechas (fecha d√≠as despu√©s)**, etc. Dentro del entorno `{tidyverse}`, el paquete `{lubridate}` tiene implementadas **m√∫ltiples funciones para poder operar con fechas de forma sencilla e intuitiva**.


```{r lubridate-package, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://lubridate.tidyverse.org/', out.width = '100%'}
knitr::include_graphics('img/lubridate.png')
```

Como ya hemos dicho, **las fechas y momentos temporales no ser√°n meras cadenas de caracter sino que tienen clases especiales asociadas** y algunas funciones especiales que pueden sernos √∫tiles: las fechas ser√°n de tipo `dates` mientras que las horas ser√° de tipo `POSIXct` o `POSIXlt`. En el primer caso, las fechas ser√°n guardadas internamente como el **n√∫mero de d√≠as transcurridos desde el 1 de enero de 1970**, y las horas como **n√∫mero de segundos desde el 1 de enero de 1970** (para la clase `POSIXct`) o una lista de segundos, minutos y horas (para la clase `POSIXlt`).

**¬øC√≥mo obtener autom√°ticamente la fecha de hoy, por ejemplo?** La funci√≥n `Sys.Date()` nos devuelve directamente la fecha y hora en el momento de la ejecuci√≥n de la orden.

```{r}
fecha <- Sys.Date()
fecha
fecha - 7 # una semana antes
class(fecha) # de clase fecha
``` 

Para <mark>**convertir una cadena de texto a fecha**</mark>, basta usar la funci√≥n `as.Date()` del paquete `{base}`, pas√°ndole como argumento la fecha en formato `"yyyy-mm-dd"` por defecto.

```{r}
as.Date("2021-03-10") # formato por defecto
```

Si **introducimos otro tipo de formato**, debemos especific√°rselo en un segundo argumento, para `R` sepa el formato de fecha que le estamos pasando

```{r}
as.Date("10-03-2020", "%d-%m-%Y") # con d√≠a-mes-a√±o (4 cifras)
as.Date("10-03-20", "%d-%m-%y")  # con d√≠a-mes-a√±o (2 cifras)
as.Date("03-10-2020", "%m-%d-%Y") # con mes-d√≠a-a√±o (4 cifras)
as.Date("Octubre 21, 1995 21:24", "%B %d, %Y %H:%M") # fecha escrita
``` 


&nbsp;

**`r colorize("ERROR: sin pasar a fecha no se puede operar", "#dc3545")`**

Si tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un d√≠a).

```{r error = TRUE}
"2021-03-10" - 1 # error
```

F√≠jate la diferencia cuando lo convertimos en fecha

```{r error = TRUE}
fecha <- as.Date("2021-03-10") - 1 # d√≠a previo
fecha
``` 

Aunque aparentemente parezca una cadena de texto, prueba a ejecutar `unclass(fecha)` para comprobar que tiene internamente guardado.

```{r}
unclass(fecha)
unclass(as.Date("1969-01-01")) # un a√±o antes de la referencia a partir de la cual cuenta d√≠as
``` 

&nbsp;


Dentro del entorno de paquetes de `{tidyverse}`, el paquete `{lubridate}` tiene bastantes funciones √∫tiles para trabajar con fechas como las siguientes


```{r}
library(lubridate)
ymd_hms("2017-11-28T14:02:00") # convertir a fecha una cadena a√±o-mes-d√≠a + hora
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena a√±o-d√≠a-mes + hora
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
mdy("July 4th, 2000") # convertir a fecha una cadena textual de fecha
ymd(20170131)
```

Adem√°s el paquete nos proporciona **herramientas para extraer la fecha y hora actuales** con las funciones `today()` y `now()`

```{r}
today()
now()
```


Tambi√©n tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el **d√≠a de la semana, el mes o el cuatrimestre**, con las funciones `year()`, `months()`, `day()` o `wday()` (d√≠a de la semana).


```{r}
fecha <- now()
year(fecha)
month(fecha)
day(fecha)
wday(fecha, week_start = 1) # D√≠a de la semana (empezando por el lunes)
hour(fecha)
minute(fecha)
second(fecha)
week(fecha) # N√∫mero de semana (del a√±o)
``` 

Al igual que podemos realizar operaciones aritm√©ticas sencillas con las fechas, tambi√©n podemos **realizar comparaciones**, por ejemplo, si el d√≠a actual es menor o mayor que otra fecha dada. 

```{r}
fecha_actual <- now()
fecha_actual > ymd(20170131) # Actual vs 2017-01-31
fecha_actual > ymd(21000131) # Actual vs 2100-01-31
``` 



&nbsp;

**`r colorize("ERROR: sumar n√∫meros a caracteres sin convertir tipos de datos", "#dc3545")`**


A veces la lectura de variables num√©ricas de nuestros archivos puede hacer que un n√∫mero, por ejemplo `1`, sea le√≠do como la cadena de texto `"1"`, con la que no podemos operar como un n√∫mero. Las funciones `as.numeric()`, `as.character()` y `as.logical()` nos permiten convertir una variable en tipo num√©rico, caracter o l√≥gico, respectivamente.

```{r error = TRUE}
"1" + 1
as.numeric("1") + 1
as.character(1)
as.logical(c(0, 1))
```


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Recuperar un comando y autocompletar", "#20935E")`**

Si haces click con el rat√≥n en la consola y pulsas la flecha ¬´arriba¬ª del teclado, te ir√° apareciendo todo el <mark>**historial de √≥rdenes ejecutadas**</mark>. Es una manera de ahorrar tiempo para ejecutar √≥rdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando **tabulador** te **autocompletar√°** solo.

&nbsp;

**`r colorize("Expresiones regulares", "#20935E")`**

Dentro del entorno de paquetes `{tidyverse}`, el paquete `{stringr}` permite un manejo m√°s complejo de cadenas de texo (como el uso de expresiones regulares).

```{r stringr2, echo = FALSE, fig.cap = "Paquete stringr para manejar cadenas de texto m√°s complejas"}
knitr::include_graphics("./img/stringr.png")
```

&nbsp;

```{r echo = FALSE}
paquetes <-
  data.frame("paquetes" = c("{base}", "{bookdown}", "{glue}", "{stringr}"),
             "descripci√≥n" = c("utilidades b√°sicas",
                               "creaci√≥n de libros, manuales e informes en R",
                               "manejo de texto literal",
                               "manejo complejo de cadenas de texto"))
kable(paquetes, col.names = c("paquetes", "descripci√≥n"), align = "ll",
      caption = "Paquetes mencionados hasta ahora")
``` 


## üìù Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: define un vector que contenga los n√∫meros 1, 10, -1 y 2, y gu√°rdalo en una variable llamada `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 10, -1, 2)
vector_num
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est√© correctamente escrita en castellano. Tras hacerlo, a√±ade "y tengo 30 a√±os". </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "√Ålvarez", "Li√©bana")

# Pegamos
paste(vector_char, collapse = " ")

# A√±adimos frase
paste0(paste(vector_char, collapse = " "), " y tengo 30 a√±os.")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: obten la fecha de hoy, define la fecha de tu cumplea√±os, y calcula la diferencia de d√≠as</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Hoy
hoy <- Sys.Date()

# Cumple (diferentes formatos de entrada)
cumple <- as.Date("1989-09-10") # por defecto
cumple <- as.Date("10-09-1989", "%d-%m-%Y")

# Diferencia
hoy - cumple
```

<!-- tocstop -->
</details>


