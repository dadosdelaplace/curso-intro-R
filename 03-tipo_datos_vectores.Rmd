# (PART) Conceptos b치sicos {-}

# Tipos de datos I: vectores

Bien, ya controlamos la calculadora. Vamos a ir m치s all치: 쯫 si en lugar de tener un solo n칰mero tenemos un **CONJUNTO de elementos**? En este cap칤tulo vamos a ver un cl치sico de cualquier lenguaje de programaci칩n: los **vectores o arrays**.



## Vectores num칠ricos

Un conjunto de elementos del mismo tipo se llama **vector** (en este caso de n칰meros), y de hecho un n칰mero individual (por ejemplo, `1`) es en realidad un vector de longitud uno (un solo elemento).

La forma m치s sencilla de **crear un vector** en `R` es con el comando `c()` (de **concatenar elementos**), y basta con introducir sus elementos entre par칠ntesis, y separados por comas. Vamos a crear el vector con los tres primeros n칰meros naturales pares (el 0 no es natural, no seas b치rbaro/a).

```{r}
z <- c(2, 4, 6)
z
```

Como ves ahora en el **environment tenemos una colecci칩n de elementos**, tres en concreto, guardados en una misma variable. La longitud de un vector se puede calcular con el comando `length()`.

```{r}
length(z)
```

Adem치s podemos **concatenar a su vez vectores**: vamos a concatenar el vector `z` consigo mismo, y a침adi칠ndole al final un 8.

```{r}
c(z, z, 8)
```

La 칰ltima concatenaci칩n lo que nos ha dado son los tres primeros pares, despu칠s de nuevo los tres primeros pares, y por 칰ltimo un 8.


### Secuencias con un patr칩n

Muchas veces nos gustar칤a **crear vectores de una forma mucho m치s r치pida**, por ejemplo, para tener un vector de 칤ndices que queramos recorrer. Supongamos que queremos el vector de los primeros 21 n칰meros naturales. Si construy칠ramos el vector como antes, tendr칤amos ejecutar el comando `c(1, 2, 3, 4, 5, ...)` hasta el n칰mero 21. 쯋n poco largo, no?

El comando `seq()` nos permite crear una **secuencia desde un elemento inicial hasta un elemento final, avanzando de uno en uno**.

```{r}
seq(1, 21) # secuencia desde 1 hasta 21 de uno en uno
```

Es importante que no perdamos el foco de que **programar es similar a escribir en un idioma**, por lo que si hay algo que se puede decir de una forma m치s limpia y que se entienda mejor, 쯣or qu칠 no usarlo? Siempre que queramos definir secuencias entre dos n칰meros naturales (por ejemplo, entre `1` y un valor `n`), cuya distancia entre elementos consecutivos sea uno, el comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Adem치s, si el elemento inicial es mayor que el final, `R` entender치 solo que la secuencia la queremo decreciente.

```{r}
n <- 21
1:n # secuencia desde 1 hasta n (21) de uno en uno
17:1 # secuencia decreciente de 17 a 1
```


&nbsp;

Tambi칠n podemos definir **otro tipo de distancia entre dos elementos consecutivos** (conocido como **paso de discretizaci칩n**), por ejemplo de 0.5 en 0.5, o bien definir una secuencia entre un valor inicial y un valor final con un n칰mero de elementos fijo (y que sea `R` el que decida la distancia entre elementos consecutivos).

```{r}
seq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5
```

```{r}
seq(1, 50, l = 11) # secuencia desde 1 a 100 de longitud 11
```

&nbsp;

Otro atajo que podemos usar para definir secuencias de n칰meros con un patr칩n es definir **vectores repetidos**, por ejemplo un vector lleno de 0, para luego ser rellenado (pero ya tenerlo definido). La funci칩n `rep()` nos permite repetir un elemento un n칰mero fijado de veces.

```{r}
rep(0, 7) # vector de 7 ceros
```

No solo podemos repetir un n칰mero sino que podemos repetir vectores enteros.

```{r}
rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces
```

Esa repetici칩n adem치s podemos definirla tambi칠n de forma **intercalada**: en lugar de repetir `c(0, 1, 2)` cuatro veces seguidas, queremos cuatro 0, despu칠s cuatro 1, y despu칠s cuatro 2.

```{r}
rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2
```


## Operaciones aritm칠ticas con vectores num칠ricos

Hemos dicho que un n칰mero es un vector de longitud 1, as칤 que **toda operaci칩n aritm칠tica** que podamos hacer con un n칰mero la vamos a poder a hacer con un vector de n칰meros, de forma que si hacemos por ejemplo la operaci칩n `2 * z`, lo que suceder치 es **CADA ELEMENTO del vector** ser치 multiplicado 2. De la misma manera se pueden definir sumas `z + x`, ra칤ces cuadradas `sqrt(z)` o elevar cada elemento al cuadrado `z^2`.


```{r}
z <- c(2, 4, 6)
2 * z
```


```{r}
x <- 1 + 2
z + x
```

```{r}
sqrt(z)
```

```{r}
z^2
```

Dado que la operaci칩n (por ejemplo, una suma) se realiza elemento a elemento, **쯤u칠 suceder치 si sumamos dos vectores de distinta longitud?** Prueba a definir un vector con los 4 primeros imparos y s칰male a z.


```{r}
y <- c(1, 3, 5, 7)
variable_suma <- z + y
variable_suma
```

Como ves, `R` intenta molestarte lo menos posible, as칤 que lo hace es reciclar: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que har치 ser치 **reciclar** elementos del vector con menor longitud: har치 `1+2`, `3+4`, `5+6` pero... `7+2` (vuelve al primer par).   


## Operaciones estad칤sticas con vectores num칠ricos

Al igual que podemos ejecutar operaciones aritm칠ticas, podemos realizar tambi칠n **operaciones estad칤sticas** con los vectores, como calcular su suma (`sum()`), su media (`mean()`), su mediana (`median()`), su suma acumulada (`cumsum()` cada elemento lo acumula al anterior) o percentiles (`quantiles()`).


```{r}
sum(y) # suma
```
```{r}
mean(y) # media
```


```{r}
median(y) # mediana
```


```{r}
cumsum(y) # suma acumulada
```

```{r}
y <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)
quantile(y, probs = c(0.15, 0.3, 0.7, 0.9)) # Percentiles p15, p30, p70 y p90
```

Ver conceptos b치sicos en \@ref(glosario3).

## Vectores de caracteres (texto)

Un error com칰n es asociar vectores solo a n칰meros: un **vector es una colecci칩n de elementos del mismo tipo** pero no tienen porque ser necesariamente n칰meros. Vamos a crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en `R` se llaman `char`): `"Mi"`, `"nombre"`, `"es"` `"Javier"`.

Como ves las variables de tipo `char` van entre comillas dobles, ya que es un **cadena de texto**.

```{r}
mi_nombre <- c("Mi", "nombre", "es", "Javier")
mi_nombre
```

Ya tenemos nuestro primer vector de texto de longitud 4. Las **cadenas de texto** son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritm칠ticas como la suma o la media, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la funci칩n `paste()`. Dicha funci칩n nos permite convertir un vector de 4 palabras en una frase, decidiendo que caracter queremos que vaya entre palabra con el argumento `collapse =`.


```{r}
paste(mi_nombre, collapse = "") # todo junto
paste(mi_nombre, collapse = " ") # separados por un espacio
paste(mi_nombre, collapse = ".") # separados por un punto .
```

Si queremos pegar los elementos de la cadena de texto sin ning칰n tipo de caracter, existe una forma m치s abreviada y limpia de ejecutar la orden `paste(mi_nombre, collapse = "")`, usando la funci칩n `paste0()` 

```{r}
paste0(mi_nombre) # todo junto sin nada separando
```

Esta funci칩n es muy 칰til si queremos definir variables de texto que compartan por ejemplo un prefijo (`variable_1`, `variable_2`, ...)

```{r}
paste0("variable", 1:7) # a la palabra 춺variable췉 le pegamos los n칰meros del 1 al 7
paste("variable", 1:7, sep = "_") # separado por una barra baja
```

&nbsp;

Otra **forma m치s intuitiva de trabajar con textos y variables num칠ricas** es usar el paquete `{glue}`, que nos permite pegar cadenas de texto a variables num칠ricas de **forma simb칩lica**.

```{r eval = FALSE}
install.packages("glue")
library(glue)
edad <- 10:15 # edades
glue("La edad es de {edad} a침os")
```

```{r echo = FALSE}
library(glue)
edad <- 10:15 # edades
glue("La edad es de {edad} a침os")
```


```{r}
# Otra forma sin definir variables a priori
glue("La edad es de {10:15} a침os")
```


&nbsp;

Ya sabemos trabajar con textos :) 

쯏 si queremos **pasar todo a may칰scula**? 쯆 **todo a min칰scula**? 쯏 si queremos **sustituir un caracter (por ejemplo `.`) por otro en todos los elementos**? `R` tambi칠n nos proporciona algunas funciones muy sencillas de usar para dichas tareas. Aqu칤 un ejemplo de algunas de ellas.

```{r}
texto <- c("Hola.", "qu칠", "ase?", "todo", "bien.", "y yo",
           "que", "ME", "ALEGRO")
toupper(texto) # todo a may칰scula
tolower(texto) # todo a min칰scula
gsub("o", "*", texto) # toda "o" en el texto ser치 sustituida por *
```

&nbsp;

```{r stringr2, echo = FALSE, fig.cap = "Paquete stringr para manejar cadenas de texto m치s complejas"}
knitr::include_graphics("./img/stringr.png")
```


## Vectores l칩gicos (TRUE/FALSE)

- [X] Variables num칠ricas (individuales)
- [X] Vectores de n칰meros
- [X] Vectores de caracteres
- [ ] Vectores l칩gicos

Veamos un 칰ltimo tipo de vectores importante en todo lenguaje de programaci칩n: los **vectores l칩gicos**. Un **valor l칩gico** puede tomar tres valores: `TRUE` (guardado internamente como un `1`), `FALSE` (guardado internamente como un `0`) o `NA` (dato ausente, son las siglas de _not available_). Estos valores son resultado de evaluar **condiciones l칩gicas**.

Por ejemplo, imaginemos que definimos un vector de n칰meros `x <- c(1.5, -1, 2, 4, 3, -4)`. 쯈u칠 numeros del vector son menores que 2? Basta con que ejecutemos la orden `x < 2`, que nos devolver치 `TRUE/FALSE` en cada hueco, en funci칩n de si cumple (`TRUE`) o no (`FALSE`) la condici칩n pedida.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 2
```

El primer, segundo y sexto elemento del vector son los 칰nicos elementos (estrictamente) menores que `2`, de ah칤 que en el primer, segundo y sexto elemento aparezca un `TRUE` y en el resto un `FALSE`. Es **importante** recordar que al **evaluar una condici칩n l칩gica sobre un vector** de longitud `n`, la **salida sigue siendo un vector** de longitud `n` pero con valores l칩gicos.

Dicha condici칩n l칩gica puede hacerse con otros operadores como `<=`, `>` o `>=`. 

```{r}
x <= 2
```

```{r}
x > 2
```

```{r}
x >= 2
```

&nbsp;

Tambi칠n podemos **comparar si es igual a otro elemento**, para lo que usaremos el operador `==`, pudiendo usar tambi칠n su opuesto `!=` (distinto de).

```{r}
x == 2
```

```{r}
x != 2
```

Las **condiciones pueden ser combinadas**, principalmente de dos maneras:

- **Intersecci칩n**: todas las condiciones concatenadas se deben cumplir (conjunci칩n `y`, operador `&`) para devolver un `TRUE`.

- **Uni칩n**: basta con que una de las condiciones concatenadas se cumpla (conjunci칩n `o`, operador `|`) para devolver un `TRUE`.

Por ejemplo, vamos a calcular qu칠 elementos del vector `c(1.5, -1, 2, 4, 3, -4)` sean menores que 3 pero (y) mayores que 0, y los elementos menores que 2 o mayores que 3.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 3 & x > 0 # Solo los que cumplen ambas condiciones
x < 2 | x > 3 # Los cumplen al menos una de ellas
```

Como hemos comentado anteriormente, los valores l칩gicos `TRUE/FALSE` son guardados internamente como `0/1` por lo que podemos usar **operaciones aritm칠ticas con ellos**. Por ejemplo, si queremos averiguar el n칰mero de elementos de un vector que cumplen una condici칩n l칩gica `< 2`, los que lo hagan tendr치n asignado un `1` y los que no un `0`, por lo que basta con sumar el vector l칩gico para obtener el n칰mero de elementos bajo dicha condici칩n.

```{r}
sum(x < 2) # sumamos el vector de TRUE/FALSE --> n칰mero de TRUE
```



## Datos ausentes: NA y NaN {#ausentes}

La vida no siempre es perfecta as칤 en muchas ocasiones nos encontraremos con lo que llamamos en estad칤stica un **dato ausente o _missing value_**, un **valor que no tenemos en nuestra variable**, y un ejemplo pr치ctico lo tenemos con los datos de vacunaci칩n de covid del Ministerio de Sanidad. Cada d칤a se publicaba un PDF (ya...mal) con los datos de vacunaci칩n PERO...no se publican datos los fines de semana: en dichas fechas hay datos que no tenemos, y en `R` se representan por `NA` (significa _not available_). Vamos a crear un vector de n칰meros con datos ausentes con la orden `x <- c(1, NA, 3, NA, NA, 5, 6)`: el vector tendr치 longitud 7 pero en el segundo, cuarto y quinto elemento tendremos un dato faltante, un lugar que no tenemos relleno (pero que no eliminamos).

```{r}
x <- c(1, NA, 3, NA, NA, 5, 6) # Vector num칠rico con datos faltante
length(x) # longitud del vector
x
``` 

**쯇uedes aventurar que sucede cuando multiplicamos ese vector por 2 por ejemplo?**

```{r}
2 * x # operaci칩n aritm칠tica con un vector con NA
``` 

Efectivamente: un dato que no tenemos, multiplicado por 2, sigue siendo un dato ausente. Es muy importante para evitar resultados err칩neos que entendamos que un **dato ausente no computa en una operaci칩n aritm칠tica, es un hueco vac칤o**. Si hacemos la suma del vector, estamos sumando n칰meros m치s datos ausentes, por lo que el resultado final ser치 tambi칠n un dato ausente. Si tenemos alg칰n dato ausente en nuestro vector, la suma final est치 a su vez ausente, 춰no podemos saber cu치nto vale!

```{r}
sum(x) # suma de un vector que contiene NA
``` 

Para evitar que un dato ausente en nuestros datos nos impida hacer ciertas operaciones, en muchas funciones de `R` podemos a침adir el argumento `na.rm = TRUE`: **primero elimina los datos ausentes**, y luego ejecuta la funci칩n.

```{r}
sum(x, na.rm = TRUE) # eliminando datos ausentes
``` 

Una manera de **localizar que elementos est치n ausentes** en nuestras variables es con la funci칩n `is.na()`, una funci칩n que nos devuelve un vector de valores l칩gico: `TRUE` si el elemento est치 ausente y `FALSE` si no lo est치.

```{r}
is.na(x) # TRUE si est치 ausente (NA), FALSE si no lo est치.
``` 

Dichos **datos ausentes se pueden eliminar** (sin necesidad de sumarlos) con la funci칩n `na.omit()` (aunque a veces lo que nos interesa es que no sea ausente, introduciendo el punto medio entre su valor anterior y su valor posterior, por ejemplo).

```{r}
na.omit(x)
``` 

&nbsp;

Hay un **tipo de dato muy particular, como resultado de operaciones no permitidas o cuyo resultado es indeterminado**, que en `R` lo veremos como `NaN`: _not a number_, un resultado fruto de una indeterminaci칩n, como por ejemplo la operaci칩n `0/0` (cuyo l칤mite no est치 definido). Importante saber que tambi칠n existe una forma de denotar al infinito como `Inf`, siendo el resultado de algunas operaciones como `1/0` (cuyo l칤mite si existe).

```{r}
1/0
0/0
sqrt(-1)
``` 

De la misma manera que podemos localizar valores `NA`, tenemos a nuestra disposici칩n las funciones `is.infinte()` y `is.nan()` para detectar que elementos de nuestro vector son `Inf` o `NaN`, respectivamente.

```{r}
x <- c(1, NA, 3, 4, Inf, 6, 7, Inf, NaN, NA)
is.na(x)
is.nan(x)
is.infinite(x)
``` 


## Seleccionar elementos de un vector

Ya sabemos definir variables que sean vectores (recuerda: colecci칩n de valores del mismo tipo).

**쯏 si del vector original queremos EXTRAER UN SUBCONJUNTO del mismo, por ejemplo, los primeros 10 elementos?**

`R` tiene varias formas de hacer esto pero la m치s sencilla es entendiendo que si yo quiero **acceder al elemento i** de un vector, deber칠 usar el **operador de selecci칩n `[i]`**. Veamos un ejemplo

```{r}
x <- 1:100 # Vector de longitud 100 (del 1 al 100)
y <- x[37] # Solo me interesa el elemento que ocupa el lugar 37
y
```

Dado que hemos visto que un n칰mero no es m치s que un vector de longitud uno, esta operaci칩n tambi칠n la podemos aplicar usando un vector de 칤ndices a seleccionar, de forma que le podemos indicar simultaneamente que valores que queremos

```{r}
x[c(1, 4, 51, 77)] # Solo queremos acceder a los elementos en la posici칩n 1, 4, 51, y 77
y <- c("hola", "qu칠", "tal", "todo", "ok", "?")
y[1:2] # Solo queremos acceder a los elementos en la posici칩n 1 y 2
c(1:2, length(y))
y[c(1:2, length(y))] # Solo accedemos a los elementos en la posici칩n 1, 2 y adem치s el que ocupa la 칰ltima posici칩n (recuerda: length(y) nos da la longitud total del vector)
```

Otras veces no querremos seleccionar un elemento en concreto sino **filtrar algunos elementos en concreto y no extraerlos**, para lo cual deberemos repetir la misma operaci칩n pero con el signo `-` delante: el operador `[-i]` no selecciona el elemento i-칠simo del vector sino que lo elimina en nuestro filtro.

```{r}
y
z <- y[-2] # Nos muestra todo y salvo el elemento que ocupa la segunda posici칩n
z
```

&nbsp;

Sin embargo, **lo habitual es que dicho filtro que hagamos de una variable lo hagamos en base a una condici칩n l칩gica**. Supongamos que `x <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)` y `y <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)` son las edades de dos grupos de personas y que queremos quedarnos solo con los mayores edad. 쯊enemos que andar averiguando en que posici칩n se encuentran para luego seleccionarlos? No, vamos a **seleccionar los elementos que cumplen una condici칩n dada**.

```{r}
x <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)
y <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)
x[x >= 18] # mayores de 18 a침os del conjunto x
y[x >= 18] # mayores de 18 a침os del conjunto y
```

Lo que hemos hecho ha sido pasarlo como 칤ndices un vector l칩gico `TRUE/FALSE`, de forma que solo filtrar치 los que tengan un `TRUE` asignado, aquellos que cumplen la condici칩n l칩gica introducida. Esto tambi칠n nos puede servir para limpiar de datos ausentes, combinando la funci칩n `is.na()`, que nos localiza el lugar que ocupan los ausentes, con el operador `!`, que lo que hace es negar lo que venga detr치s. Tambi칠n podemos probar a **combinar condiciones l칩gicas para nuestra selecci칩n**.

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[x >= 18] # mayores de 18 a침os del conjunto x
x[is.na(x)] # solo valores ausentes
x[!is.na(x)] # sin valores ausentes: ! es el s칤mbolo de la negaci칩n
!(x >= 18) # niega los mayores de 18 a침os, todo lo que no cumpla esa condici칩n
x[x >= 18 & x <= 25] # los valores que cumplen ambas (&): entre 18 y 25 a침os
```

Como ves si un valor es `NA`, la evaluaci칩n de una condici칩n l칩gica sobre 칠l (mayor o menor de 18 a침os) nos seguir치 devolviendo `NA`. Por 칰ltimo, `R` nos permite **dar significado l칠xico** a nuestros valores (significan algo, no solo n칰meros), pudiendo poner nombres a los elementos de un vector, permitiendo su selecci칩n por dichos nombres
```{r}
x <- c("edad" = 31, "tlf" = 613910687, "cp" = 33007) # cada n칰mero tiene un significado distinto
x
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

Con la funci칩n `names()` adem치s podemos, no solo consultar los nombres de una variable, sino cambiarlos a nuestro gusto.

```{r}
names(x) # Consultamos nombres
names(x) <- c("a침os", "m칩vil", "direcci칩n") # Cambiamos nombres
names(x) # Consultamos nuevos nombres
x
```


### which

Hemos visto como seleccionar elementos de un vector que cumplen una condici칩n, para a veces no queremos el elemento en s칤, sino el lugar que ocupa: **쯤u칠 valores de un vector cumplen una condici칩n l칩gica, qu칠 lugar ocupan?** Para obtener dicho 칤ndice tenemos a nuestro disposici칩n la funci칩n `which()`, que no nos devuelve el elemento en s칤 sino su lugar.

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[x >= 18] # Accedemos a los elementos que cumplen la condici칩n
which(x >= 18) # Obtenemos los lugares que ocupan los elementos que cumplen la condici칩n

```

Esta funci칩n es muy 칰til especialmente cuando queremos **averiguar el valor que ocupa el m치ximo/m칤nimo** de una colecci칩n de valores, con las funciones `which.max()` y `which.min()`.

```{r}
max(x, na.rm = TRUE) # m치ximo de x (si no eliminamos NA, nos devolver치 NA)
min(x, na.rm = TRUE) # m칤nimo de x (si no eliminamos NA, nos devolver치 NA)
which.max(x) # Lugar que ocupa el m치ximo
x[which.max(x)]
which.min(x) # Lugar que ocupa el m칤nimo
x[which.min(x)]
```

### NULL

A veces veremos que adem치s de `NA` y `NaN`, `R` nos muestra un dato llamado `NULL`. Cuando tenemos `NA` en alguna variable, el registro existe, pero no est치 relleno. Sin embargo, cuando tenemos un `NULL` significa que ese registro ni siquiera existe: no es un dato guardado pero cuyo valor desconocemos, es un dato que ni siquiera existe (por ejemplo, si guardamos datos de 7 personas, el dato de la octava persona no es `NA`, es que no hay octava persona directamente).

```{r}
x <- c(1, NA, 3, NA, NA, 5, 6)
x[2] # NA: el registro existe pero sin dato
names(x) # No hemos definido el nombre de las variables, as칤 que devuelve NULL
```



## Ordenar vectores

Una acci칩n habitual al trabajar con datos es **saber ordenarlos**: de menor a mayor edad, datos m치s recientes vs antiguos, etc. Para ello tenemos la funci칩n `sort()`, que podemos usar directamente para **ordenar de menor a mayor**, o con el argumento `decreasing = TRUE`, para **ordenar de mayor a menor**.

```{r}
x <- c(1, -3, 0, 10, 5, 2, 7, -13)
sort(x) # orden de menor a mayor
sort(x, decreasing = FALSE) # orden de mayor a menor
```


Otra forma de ordenar un vector es que `R` nos **devuelva los 칤ndices de los elementos ordenados**, y luego usar dichos 칤ndices para reorganizar los elementos, con la funci칩n `order()`.
```{r}
order(x) # el elemento m치s peque침o es el octavo, luego el segundo, luego el tercero, luego el primero, luego el sexto, etc.
x[order(x)] # accedemos a los 칤ndices ordenados, equivalente al sort(x)
```



## Fechas

Hay un tipo muy especial de datos que son los **datos tipo fecha**. Una fecha podr칤a ser a priori una simple cadena de texto `"2021-04-21"` pero podemos usar la funci칩n `as.Date()` para que `R` entienda que esa cadena de texto representa un instante temporal. F칤jate la diferencia entre una fecha en texto y una fecha con `as.Date()`.

```{r error = TRUE}
fecha_char <- "2021-04-21"
fecha_date <- as.Date(fecha_char, format = "%Y-%m-%d")
fecha_char + 1
fecha_date + 1
```

En el momento en que el convertimos la cadena de texto a fecha, aunque se visualice como tal, internamente es un n칰mero, por lo que podemos restar fechas (d칤as entre ambas), **podemos sumar n칰meros a fechas (fecha d칤as despu칠s)**, etc.


&nbsp;

Dentro del entorno `{tidyverse}`, el paquete `{lubridate}` tiene implementadas **m칰ltiples funciones para poder operar con fechas de forma sencilla e intuitiva**.

```{r lubridate-package, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://lubridate.tidyverse.org/', out.width = '100%'}
knitr::include_graphics('img/lubridate.png')
```


## 游닄 Glosario {#glosario3}

* `numeric`: variables de tipo num칠ricas (algunas veces vendr치n indicados como `int` o integer para enteros, y `dbl` o `double` para n칰meros con decimales).
* `character`: variables de tipo caracter.
* `Date`: variables de tipo fecha.


* **Media**: medida de centralizaci칩n que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. A pesar de ser la m치s conocida, la media es **muy poco robusta**: dado un conjunto, si se introducen **valores at칤picos o outliers** (valores muy grandes o muy peque침os), la media se perturbar con mucha facilidad. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $\overline{x}$.

$$\overline{x} = \frac{\displaystyle \sum_{i=1}^{n}x_i}{n}$$

* **Mediana**: medida de centralizaci칩n que consiste en, tras ordenar los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos n칰meros por debajo como por encima). M치s robusta que la media aunque menos la moda. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $Me_x$.

$$Me_x = \displaystyle \arg \min_{x_i} \left\lbrace F_i > 0.5 \right\rbrace, \quad F_i = \frac{\#\left\lbrace x_j \leq x_i \right\rbrace}{n}$$

* **Moda**: medida de centralizaci칩n que consiste en encontrar el valor m치s repetido (el valor _trending_). Es la medida de centralizaci칩n m치s robusta. Dado un vector de valores $x = (x_1, \ldots, x_n)$, se denota como $Mo_x$.

$$Mo_x = \displaystyle \arg \max_{x_i} f_i  , \quad f_i = \frac{\#\left\lbrace x_j = x_i \right\rbrace}{n}$$


## ![](img/logo_info.png){width=4%} Consejos y tips


<details>
  <summary><strong>Operaciones elemento a elemento (vectorial)</strong></summary>

Es importante recordar que cada operaci칩n con un vector es una **operaci칩n realizada en CADA elemento del vector, devolvi칠ndonos a su vez un vector** de salida de igual longitud que la variable con la que hemos operado.

</details>

&nbsp;

<details>
  <summary><strong>Diferencia de conjuntos</strong></summary>

Una funci칩n muy 칰til para ver las **diferencias entre dos conjuntos** es `setdiff()`, una funci칩n que nos devuelve los elementos distintos entre dos conjuntos.

```{r}
y <- 1:10
z <- c(1, 3, 7, 10)
setdiff(y, z) # Elementos en y que no est치n en z 
```

</details>

&nbsp; 

<details>
  <summary><strong>Argumentos por defecto</strong></summary>

La funci칩n `sort()` es un buen ejemplo de que las **funciones traen definidos argumentos por defecto** (aunque no los veamos a priori). La orden `sort(x)` en realidad est치 ejecutando `sort(x, decreasing = TRUE)`, pero como es su valor por defecto, nos podemos ahorrar incluirlo. Escribe `? help sort()` en la consola y ver치s como en la cabecera de la funci칩n ya hay preasignado un `decreasing = TRUE`.

</details>

&nbsp; 

<details>
  <summary><strong>Recuperar un comando y autocompletar</strong></summary>

Si haces click con el rat칩n en la consola y pulsas la flecha 춺arriba췉 del teclado, te ir치 apareciendo todo el **historial de 칩rdenes ejecutadas**. Es una manera de ahorrar tiempo para ejecutar 칩rdenes similares.


&nbsp; 

Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, si pulsas **tabulador**, `R` te **autocompletar치** solo (prueba a escribir solo `variab` y pulsa tabulador)

</details>  


&nbsp; 

<details>
  <summary><strong>all, any</strong></summary>
 

Existen dos funciones muy 칰tiles en `R` para saber si **TODOS** o **ALGUNO** de los elementos de un vector cumple una condici칩n. Las funciones `all()` y `any()` nos devolver치 un 칰nico valor l칩gico. Estas funciones son muy 칰tiles al final de los c칩digos para comprobar que las condiciones que tienen que verificar los datos se cumplen, y asegurarnos que el proceso se ha ejecutado correctamente (por ejemplo, que todos los datos sean positivos o no haya datos ausentes).

```{r}
x <- c(1, 2, 3, 4, 5, NA, 7)
all(x < 3)
any(x < 3)
all(x > 0)
all(na.omit(x) > 0)
all(is.na(x))
any(is.na(x))
```

</details>

&nbsp; 

<details>
  <summary><strong>Constantes: n칰mero pi</strong></summary>

`R` tiene una variable reservada al n칰mero $\pi$, lista para ser usada, por lo que se **recomienda no nombrar a ninguna variable con dicho nombre**.

```{r}
pi
```

</details>


&nbsp; 

<details>
  <summary><strong>Convertir tipos de datos</strong></summary>
 

A veces la lectura de variables num칠ricas de nuestros archivos puede hacer que un n칰mero, por ejemplo `1`, sea le칤do como la cadena de texto `"1"`, con la que no podemos operar como un n칰mero. Las funciones `as.numeric()`, `as.character()` y `as.logical()` nos permiten convertir una variable en tipo num칠rico, caracter o l칩gico, respectivamente.

```{r error = TRUE}
"1" + 1
as.numeric("1") + 1
as.character(1)
as.logical(c(0, 1))
```


</details> 


&nbsp; 

<details>
  <summary><strong>Optimizar nuestro c칩digo: eficiencia en tiempo de ejecuci칩n</strong></summary>
 

Aunque parezca un tema menor, si tu c칩digo tarda 1 milisegundo m치s de lo que podr칤a tardar de otra forma, si esa orden se repite muchas veces, ese milisegundo extra puede ser 5, 10 o 20 minutos m치s que tu c칩digo tardar치 en ejecutarse. Hay un paquete muy 칰til en `R` para medir tiempos de distintas 칩rdenes que hacen lo mismo (el paquete `{microbenchmark}`), vamos a instalarlo.

```{r eval = FALSE}
install.packages("microbenchmark")
library(microbenchmark)
```


```{r echo = FALSE}
library(microbenchmark)
```

Este paquete contiene una orden para comparar el tiempo de dos 칩rdenes: necesita como primeros argumentos las dos 칩rdenes cuyos tiempos vamos a comparar, y un argumento `times` en el que le indicamos el n칰mero de veces que ejecutar치 cada orden para realizar los tiempos medios. Vamos a comparar los comandos de ordenaci칩n `order()` y `sort()`.

```{r}
x <- rnorm(1e3) # 1000 elementos aleatorias de una normal N(0, 1)
microbenchmark(sort(x), # primera forma
               x[order(x)], # segunda forma
               times = 1e3) # se repetir치 1000 veces
```

S칤, est치s viendo bien: aunque a priori parezca contraintuitivo, es m치s corto obtener los 칤ndices ordenados de un vector, y luego reordenarlo en base a esos 칤ndices, que la ordenaci칩n directa a trav칠s del comando `sort()` (ya que usan algoritmos de ordenaci칩n distintos).

</details>

## 游닇 Ejercicios

<details>
  <summary>游닇<strong>Ejercicio 1</strong>: define un vector que contenga los n칰meros 1, 10, -1 y 2, y gu치rdalo en una variable llamada `vector_num`. Tras definirlo, calcula su suma y la versi칩n ordenada del vector definido como sumar 1 a cada elemento de `vector_num`. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Vector de n칰meros
vector_num <- c(1, 10, -1, 2)

# Suma
sum(vector_num)

# Ordenamos el vector + 1 (con sort)
sort(vector_num + 1)

# Ordenamos el vector + 1 (con order)
vector_num2 <- vector_num + 1
vector_num2[order(vector_num2)]
```

<!-- tocstop -->
</details>

<details>
  <summary>游닇<strong>Ejercicio 2</strong>: encuentra del vector `vector_num` original el lugar (el 칤ndice) que ocupa su m칤nimo y su m치ximo. Devuelve un vector l칩gico con los elementos que son mayores 1 y menores que 7. Piensa una manera de encontrar si todos son positivos. </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
vector_num <- c(1, 10, -1, 2)

# Encontrando el lugar que ocupa el m치ximo y m칤nimo
which.max(vector_num)
which.min(vector_num)

# Vector l칩gico: mayores que 1 y menores que 7
vector_num > 1 & vector_num < 7

# 쯉on todos positivos?
all(vector_num > 0)
```

<!-- tocstop -->
</details>

<details>
  <summary>游닇<strong>Ejercicio 3</strong>: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est칠 correctamente escrita en castellano. Tras hacerlo, a침ade "y tengo 30 a침os". </summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "츼lvarez", "Li칠bana")

# Pegamos
paste(vector_char, collapse = " ")

# A침adimos frase
paste0(paste(vector_char, collapse = " "), " y tengo 30 a침os.")
```

<!-- tocstop -->
</details>

<details>
  <summary>游닇<strong>Ejercicio 4</strong>: obten la fecha de hoy, define la fecha de tu cumplea침os, y calcula la diferencia de d칤as.</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Hoy
hoy <- Sys.Date()

# Cumple (diferentes formatos)
cumple <- as.Date("1989-09-10")
cumple <- as.Date("10-09-1989", "%d-%m-%Y")

# Diferencia
hoy - cumple
```

<!-- tocstop -->
</details>


