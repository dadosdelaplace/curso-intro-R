```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# Vectores {#vectores}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script06.R**](https://github.com/dadosdelaplace/courses-intro-R/blob/main/scripts/script06.R). Ver en <https://github.com/dadosdelaplace/courses-intro-R/blob/main/scripts/script06.R>

::::

Hemos visto ya como poder almacenar elementos individuales como la edad de una persona (`edad <- 32`) o su nombre (`nombre <- "Javi"`). ¬øY si en lugar de querer almacenar un solo elemento, por ejemplo , tenemos una <mark>**colecci√≥n de elementos**</mark> (las edades de toda nuestra familia, por ejemplo)?

En este cap√≠tulo vamos a ver un cl√°sico de cualquier lenguaje de programaci√≥n: los <mark>**vectores o arrays**</mark>, que no son m√°s que una <mark>**concatenaci√≥n de elementos del mismo tipo**</mark>. De hecho un n√∫mero individual (por ejemplo, `x <- 1`) es en realidad un vector de longitud uno (un solo elemento). Es el <mark>**tipo de dato que m√°s vas a usar**</mark> ya que las columnas de cualquier tabla funcionar√°n como una concatenaci√≥n de valores.

Un vector es lo que solemos representar como $\overrightarrow{x} = \left[1, 2, 3 \right]$ en matem√°ticas, pero no te preocupes si nunca has visto esta forma de representarlos. Vamos a empezar de cero.


## Vectores num√©ricos

La forma m√°s sencilla de **crear un vector** en `R` es con el comando `c()` (para acordarte: letra `c` de **Concatenar**), y basta con introducir sus elementos entre par√©ntesis, y separados por comas. Por ejemplo, supongamos que queremos <mark>**guardar la edad de 4 personas**</mark> (como si tuvieramos una columna `edad` en una tabla de 4 filas).

```{r}
edades <- c(32, 27, 60, 61)
edades
```

Como ves ahora en el <mark>**environment**</mark> (el entorno, **arriba a la derecha**) tenemos una colecci√≥n de elementos guardada, con cuatro elementos en concreto, almacenados en una misma variable `edades`.

```{r vectores-environment, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.cap = 'Vector en el enviroment', out.width = '75%'}
knitr::include_graphics("img/vectores_enviroment.jpg")
```

La <mark>**longitud de un vector**</mark> se puede calcular con el comando `length()` (nos devolver√° el n√∫mero de elementos de la variable que le pasemos como argumento).

```{r}
length(edades)
```

Adem√°s podemos <mark>**concatenar a su vez vectores**</mark> (uno tras otro): vamos a concatenar el vector `edades` consigo mismo, y a√±adi√©ndole al final un 8.

```{r}
c(edades, edades, 8)
```

Esta √∫ltima concatenaci√≥n lo que nos ha dado son, primero, los cuatro elementos que ya ten√≠amos en `edades`, despu√©s de nuevo los cuatro elementos, y por √∫ltimo un 8.


## Secuencias num√©ricas con un patr√≥n

En muchas ocasiones querremos <mark>**crear vectores num√©ricos de una forma mucho m√°s r√°pida**</mark>. Supongamos que queremos un vector que nos almacene el n√∫mero del mes, desde el 1 hasta el 31. Si construy√©ramos el vector como antes, tendr√≠amos que ejecutar el comando `c(1, 2, 3, 4, 5, ...)` hasta llegar al n√∫mero 31. ¬øUn poco largo, no?

Hay un atajo: el comando `seq()` nos permite crear una <mark>**secuencia desde un elemento inicial hasta un elemento final**</mark>, avanzando de uno en uno.

```{r}
seq(1, 31) # secuencia desde 1 hasta 31 de uno en uno
```

Es importante que no perdamos el foco: <mark>**programar es similar a escribir en un idioma**</mark>, por lo que si hay algo que se puede decir de una forma m√°s limpia y que se entienda mejor, ¬øpor qu√© no usarlo? Siempre que queramos definir secuencias entre dos n√∫meros naturales (por ejemplo, entre `1` y un valor `n`), cuya distancia entre elementos consecutivos sea uno, el comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Adem√°s, si el elemento inicial es mayor que el final, `R` entender√° solo que la secuencia la queremos **decreciente**.

```{r}
n <- 31
1:n # secuencia desde 1 hasta n (31) de uno en uno
n:1 # secuencia decreciente
```

&nbsp;

Tambi√©n podemos definir <mark>**otro tipo de distancia**</mark> entre dos elementos consecutivos (distancia conocida como <mark>**paso de discretizaci√≥n**</mark>), por ejemplo de 0.5 en 0.5, o de 1.7 en 1.7

```{r}
seq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5
seq(1, 21, by = 1.7) # secuencia desde 1 a 21 de 1.7 en 1.7
```

Otras veces nos interesar√° definir una secuencia entre un valor inicial y un valor final, pero nos dar√° igual la distancia entre cada elemento: solo nos importa que tenga un <mark>**n√∫mero concreto de elementos**</mark> (y que sea `R` el que decida la distancia entre elementos consecutivos para conseguirlo).

```{r}
seq(1, 50, l = 11) # secuencia desde 1 a 50 de longitud 11
seq(1, 50, l = 8) # secuencia desde 1 a 50 de longitud 8
```

&nbsp;

Otro atajo que podemos usar para definir secuencias de n√∫meros con un patr√≥n es definir <mark>**vectores de elementos repetidos**</mark>, por ejemplo un vector lleno de ceros. La funci√≥n `rep()` nos permite repetir un elemento un n√∫mero fijado de veces.

```{r}
rep(0, 7) # vector de 7 ceros
```

No solo podemos repetir un n√∫mero sino que podemos **repetir vectores enteros**.

```{r}
rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces
```

Esa repetici√≥n adem√°s podemos definirla tambi√©n de forma **intercalada**: en lugar de repetir `c(0, 1, 2)` cuatro veces seguidas, queremos cuatro 0, despu√©s cuatro 1, y despu√©s cuatro 2.

```{r}
rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2
```


## Vectores de caracteres (texto)

Un error com√∫n es asociar el concepto de vectores solo a n√∫meros: un <mark>**vector es una colecci√≥n o concatenaci√≥n de elementos del mismo tipo**</mark>, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en `R` se llaman `char`): `"Mi"`, `"nombre"`, `"es"` `"Javier"`.

Como antes, las variables de tipo `char` o `character` van entre comillas dobles, ya que es un <mark>**cadena de texto**</mark>.

```{r}
mi_nombre <- c("Mi", "nombre", "es", "Javier")
mi_nombre
```

F√≠jate la diferencia entre tenerlo guardado en un vector o tenerlo como una cadena unida

```{r}
variable <- "Mi nombre es Javier"
class(variable)
str_length(variable)

vector <- c("Mi", "nombre", "es", "Javier")
class(vector)
str_length(vector)
```

Cuando aplicamos la funci√≥n `str_length()` a un vector de caracteres, del paquete `{stringr}` que hemos visto en el tema anterior, la funci√≥n se aplica <mark>**A CADA ELEMENTO**</mark> del vector (d√°ndonos un vector de longitudes, de cada cadena que tenemos concatenada en el vector). Lo veremos con m√°s detalle en el pr√≥ximo tema.

```{r}
str_to_lower(vector)
str_detect(vector, "i") # TRUE --> si tiene letra i
```

&nbsp;

Ya tenemos nuestro primer vector de texto de longitud 4, y en cada elemento tenemos un texto. Cuando usamos la funci√≥n `paste()` con variables diferentes, us√°bamos `sep = ...` para decidir el caracter con el que pegamos dichas cadenas texto. Cuando la funci√≥n `paste()` la aplicamos a un vector de caracteres, decidiremos que **caracter queremos que vaya entre palabra con el argumento `collapse =`**.


```{r}
paste(mi_nombre, collapse = "") # todo junto
paste(mi_nombre, collapse = " ") # separados por un espacio
paste(mi_nombre, collapse = ".") # separados por un punto .
paste0(mi_nombre) # todo junto sin nada separando
```

Ahora que sabemos lo que es un vector de n√∫meros, por ejemplo el vector `1:7` (el conjunto de naturales desde el 1 hasta el 7), podemos definir cadenas de texto que compartan por ejemplo un prefijo (`persona_1`, `persona_2`, ...)

```{r}
paste0("persona", 1:7) # a la palabra ¬´persona¬ª le pegamos los n√∫meros del 1 al 7
paste("persona", 1:7, sep = "_") # separado por una barra baja
```

De igual manera podemos hacer uso del ya conocido paquete `{glue}`, combinando cadenas de texto y vectores num√©ricos, obteniendo vectores de frases.

```{r}
library(glue)
edad <- 10:13 # edades
glue("La edad es de {edad} a√±os")

# Otra forma sin definir variables a priori
glue("La edad es de {10:13} a√±os")
```


## Vectores l√≥gicos (TRUE/FALSE)

[X] Variables num√©ricas (individuales)
[X] Vectores de n√∫meros
[X] Vectores de caracteres
[ ] Vectores l√≥gicos

Veamos un √∫ltimo tipo de vectores muy importante en todo lenguaje de programaci√≥n: los <mark>**vectores de valores l√≥gicos**</mark>. Un <mark>**valor l√≥gico**</mark> puede tomar tres valores:

* `TRUE` (guardado internamente como un 1).
* `FALSE` (guardado internamente como un 0).
* `NA` (<mark>**dato ausente**</mark>, son las siglas de _not available_, cuando pretendemos aplicar una comparaci√≥n a un dato ya de por si ausente).

Los valores l√≥gicos suelen ser <mark>**resultado de evaluar condiciones l√≥gicas**</mark>, de hacerle preguntas a los datos. Por ejemplo, imaginemos que definimos un vector de temperaturas `x <- c(15, 20, 23, 31, 27, 7, 29, 10)`. <mark>**¬øQu√© d√≠as hizo menos de 22 grados?**</mark> Basta con que ejecutemos la orden `x < 22`, que nos devolver√° `TRUE` o `FALSE` en cada hueco, en funci√≥n de si cumple (`TRUE`) o no (`FALSE`) la condici√≥n pedida.

```{r}
x <- c(15, 20, 23, 31, 27, 7, 29, 10)
x < 22
```

El primer, segundo, sexto y octavo d√≠a, la temperatura fue inferior (estrictamente) a 22, de ah√≠ que en el primer, segundo, sexto y octavo d√≠a elemento aparezca un `TRUE` y en el resto un `FALSE`. Es importante recordar que al evaluar una condici√≥n l√≥gica sobre un vector, la salida sigue siendo un vector de la misma longitud pero con valores l√≥gicos.

Dicha condici√≥n l√≥gica puede hacerse con otros operadores como `<=` (menor o igual), `>` (mayor) o `>=` (mayor igual).

```{r}
x <= 22
x > 30
x >= 15
```

Tambi√©n podemos comparar si es <mark>**igual a otro elemento**</mark>, para lo que usaremos el operador `==`, pudiendo usar tambi√©n su opuesto `!=` (¬´distinto de¬ª).

```{r}
x == 15
x != 15
```

Si tuvi√©ramos un dato ausente (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a ausente

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

Las <mark>**condiciones pueden ser combinadas**</mark>, principalmente de dos maneras:

* <mark>**Intersecci√≥n**</mark>: todas las condiciones concatenadas se deben cumplir (conjunci√≥n y, operador `&`) para devolver un `TRUE`.

* <mark>**Uni√≥n**</mark>: basta con que una de las condiciones concatenadas se cumpla (conjunci√≥n o, operador `|`) para devolver un `TRUE`.

Por ejemplo, vamos a calcular qu√© elementos del vector de temperaturas sean menores que 30 pero (y) mayores que 15

```{r}
x < 30 & x > 15
```

F√≠jate lo que sucede si no lo pedimos como intersecci√≥n (ambas deben cumplirse) sino como uni√≥n (basta con que alguna se cumple)

```{r}
x < 30 | x > 15
```


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Expresiones regulares", "#20935E")`**

Dentro del entorno de paquetes `{tidyverse}`, el paquete `{stringr}` permite un manejo m√°s complejo de cadenas de texo (como el uso de expresiones regulares).

```{r stringr2, echo = FALSE, fig.cap = "Paquete stringr para manejar cadenas de texto m√°s complejas"}
knitr::include_graphics("./img/stringr.png")
```

&nbsp;


## üìù Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: modifica el c√≥digo inferior para crear un vector de nombre `vector_num` que contenga los n√∫meros 1, 5 y -7.
  

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 5, -7)
vector_num
```

<!-- tocstop -->
</details>

```{r eval = FALSE}
# Vector de n√∫meros
vector_num <- c(1)
vector_num
```

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 2</strong>: define un vector que contenga los n√∫meros 1, 10, -1 y 2, y gu√°rdalo en una variable llamada `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Vector de n√∫meros
vector_num <- c(1, 10, -1, 2)
vector_num
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: obt√©n la longitud del vector anterior `vector_num`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Longitud del vector
length(vector_num)
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 4</strong>: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est√© correctamente escrita en castellano. Tras hacerlo, a√±ade "y tengo 30 a√±os". </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "√Ålvarez", "Li√©bana")

# Pegamos
frase <- paste(vector_char, collapse = " ")
frase

# A√±adimos frase
glue("{frase} y tengo 30 a√±os.")

# Otra forma
paste0(frase, " y tengo 30 a√±os.")

# Otra forma
paste(frase, "y tengo 30 a√±os.")
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 5</strong>: el c√≥digo inferior crea una secuencia de n√∫meros, que empieza en `-1`, que acaba en `32`, y que va saltando de 2 en 2. Mod√≠ficalo para que haga el salto de 3 en 3 y gu√°rdalo en una variable llamada `secuencia`
  

</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
secuencia <- seq(-1, 32, by = 3)
secuencia
length(secuencia) # longitud de la secuencia
```

<!-- tocstop -->
</details>

```{r eval = FALSE}
seq(-1, 32, by = 2)
```

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 6</strong>: crea una secuencia de n√∫meros, que empiece en `-1`, que acabe en `32`, y que tenga longitud 12. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
secuencia <- seq(-1, 32, l = 12)
secuencia
length(secuencia) # longitud de la secuencia
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 7</strong>: crea una secuencia que empiece en 1 y recorra todos los naturales hasta el 10. Despu√©s crea otra secuencia de longitud 7 que todos los n√∫meros sean `3`.  </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
1:10
rep(3, 7) # secuencia repetida
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 8</strong>: crea una secuencia que repita 5 veces el patr√≥n `1, 2, 3`. Despu√©s crea otra que repita dicho patr√≥n pero de forma intercalada, con 5 veces `1`, despu√©s 5 veces `2` y despu√©s 5 veces `3`.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
rep(c(1, 2, 3), 5) # repetimos patr√≥n (1, 2, 3) 5 veces
rep(c(1, 2, 3), each = 5) # repetimos patr√≥n alternado
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 9</strong>: crea una variable `x <- c("oso pardo", "oso polar", "ballena", "grillo", "oso panda", "perro")`. Haciendo uso de `str_length()` calcula la longitud de cada cadena de texto. Haciendo uso de `str_detect()` detecta los animales que son un oso.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
x <- c("oso pardo", "Oso polar", "ballena", "grillo", "OSO panda", "perro")
str_length(x) # longitud

# OJO! antes hay que pasar todo a may√∫scula o min√∫scula, nos da igual que sea oso, OSO, Oso, etc
str_detect(str_to_lower(x), "oso") 
```

<!-- tocstop -->
</details>




