```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```


# Explorando los datos: incursi√≥n a tidyverse {#tidyverse}

Empezamos a tener ciertas **herramientas** para trabajar con los datos:

* Intentaremos que nuestros datos sean [Tidy data](#tidy_data)
* Conocemos un **formato amable** de almacenar los datos como son los `data.frame` de tipo `tibble`

Sin embargo muchas veces los datos no los tenemos en el formato deseado, o directamente queremos realizar algunas transformaciones en los mismos, crear nuevas variables u obtener res√∫menes num√©ricos. En esta secci√≥n **aprenderemos a explorar, procesar, depurar, transformar y analizar num√©ricamente los datos**, haciendo uso principalmente de los paquetes `{tidyverse}` y `{skimr}`

```{r}
library(tidyverse)
library(skimr)
```

El entorno `{tidyverse}` es una de las **herramientas m√°s importantes en el manejo de datos en `R`**, una **colecci√≥n de paquetes** pensada para el manejo, la exploraci√≥n, el an√°lisis y la visualizaci√≥n de datos, compartiendo una misma filosof√≠a y gram√°tica. Puedes ver su documentaci√≥n en <https://www.tidyverse.org/>. Esta secci√≥n pretende ser una **introducci√≥n a dicho entorno**, y lo haremos principalmente con el conjunto de datos `starwars`, del paquete `{dplyr}` (ya cargado en `{tidyverse}`).

```{r}
starwars
```

Dicho **conjunto de datos**, extra√≠da de la [Star Wars API](https://swapi.dev), recopila diferentes datos y caracter√≠sticas de los personajes de la **saga Star Wars**. Como habr√°s advertido, `starwars` es una tabla en un formato ya conocido, un `tibble`, en el que se nos especifica al inicio de la tabla de qu√© tipo son cada columna:

* `int`: n√∫meros enteros.
* `dbl`: n√∫meros reales (o racionales).
* `chr`: cadenas de texto.
* `lgl`: valores l√≥gicos (`TRUE` o `FALSE`).
* `fct`: factores, variables cualitativas (categor√≠as).
* `date`: fechas.

Las **funciones** que veremos a lo largo de esta secci√≥n **siempre van a compartir una misma metodolog√≠a**: primero escribimos el nombre una tabla (`data.frame` o `tibble`), despu√©s **lo que queremos hacer** a dicho conjunto de datos (con las variables SIN comillas) encandenando √≥rdenes con `%>%` (lo que se conoce como _pipes_), y **obtenemos una nueva tabla** en el mismo formato de entrada.

```{r}
# Tipo de datos
class(starwars)

# Dimensi√≥n de los datos
dim(starwars)

# Resumen por columnas
glimpse(starwars)
```

Los datos podemos verlos escribiendo el nombre de la tabla en la consola (recuerda que si es un `tibble`, para evitar saturar la consola, te saca un extracto, no todas las columnas y filas) o bien con la funci√≥n `print()`, indic√°ndole n√∫mero de filas (`n = 15` por ejemplo) y n√∫mero de columnas (`width = Inf` si queremos mostrar todas).

```{r}
# Imprimir personalizado
print(starwars, n = 5, width = Inf)
```

F√≠jate que las **3 √∫ltimas variables son de tipo lista** (echa un vistazo a [Listas y Factores](#otros-datos)). Por ejemplo, en `starwars$films` se **guardan para cada personaje la colecci√≥n de pel√≠culas de la saga** en las que aparece (algunos tendr√°n 1 solo nombre, otros 7).

```{r dplyr, echo = FALSE,  out.width = "80%", fig.align = "center", fig.cap = "Cheet sheet de las opciones del paquete dplyr para la manipulaci√≥n de datos extra√≠da de <https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf>"}
knitr::include_graphics("./img/dplyr.png")
``` 



## Operaciones con filas

Empecemos por **c√≥mo seleccionar filas**. Principalmente tenemos tres opciones: seleccionarlas en base a alg√∫n **filtro o condici√≥n** (solo los mayores de tal edad, por ejemplo), **extraer filas por su √≠ndice** de fila o **extraer filas aleatoriamente**.

### Seleccionar filas (filter, slice)

La funci√≥n `filter()` nos permite **seleccionar filas en base a que se cumpla una o varias condiciones** respecto a las variables. Para usarla basta con que introduzcamos como argumento el conjunto de condiciones que debe cumplir (recuerda: nombre de columnas sin comillas). Supongamos que queremos por ejemplo **seleccionar solo los personajes con ojos marrones**.

```{r}
starwars %>% filter(eye_color == "brown") # con ojos marrones
```

En tan solo una l√≠nea hemos hecho m√°s de lo que parece: `R` ha ¬´recorrido¬ª cada una de las filas y ha ido comprobando que fila cumple la condici√≥n y cual no. Con la misma l√≥gica podemos **seleccionar los personajes que NO TIENEN ojos marrones**, cambiando `==` por `!=`

```{r}
starwars %>% filter(eye_color != "brown") # NO tengan ojos marrones
```

Tambi√©n se pueden **seleccionar los personajes que tienen los ojos de una serie de colores permitidos**.

```{r}
starwars %>% # con ojos marrones, azules o rojos
  filter(eye_color %in% c("brown", "blue", "red"))
```

Si es una **variable num√©rica** tambi√©n podemos **seleccionar por rango** con `between()`, por ejemplo, los personajes cuya altura est√° entre 120 y 160 cm.

```{r}
# Con between filtramos por rango
starwars %>% filter(between(height, 120, 160))
```


Las **condiciones se pueden concatenar** y complejizar todo lo que queramos, pudiendo en pocas l√≠neas realizar un filtro complejo

```{r}
starwars %>% # humanos con ojos marrones
  filter(eye_color == "brown", species == "Human")

# humanos con ojos marrones, azules o rojos, que no sean humanos, y menos de 50a
starwars %>% 
  filter(eye_color %in% c("brown", "blue", "red"),
         species != "Human", birth_year < 50)
```

Muchas veces querremos **extraer filas simplemente por el lugar que ocupan**, sin hacer que dependa de ninguna condici√≥n. Vamos a extraer las filas quinta, sexta, s√©ptima, octava, novena y d√©cima.

```{r}
# slice: extramos filas por √≠ndice de fila.
starwars %>% slice(5:10) # filas de la 5 a la 10
```

Podemos **combinar los √≠ndices** para extraer por ejemplo solo los pares o filas concretas separadas por los espacios que queramos.

```{r}
starwars %>% slice(seq(2, nrow(starwars), by = 2)) # filas pares
starwars %>% slice(c(3, 4, 10, 20, 33)) # filas 3, 4, 10, 20 y 33
```

Tambi√©n hay opciones por defecto para extraer directamente **las primeras o √∫ltimas filas** con `slice_head()` y `slice_tail()`.

```{r}
# Podemos extraer directamente las primeras o √∫ltimas filas
starwars %>% slice_head(n = 7) # 7 primeras filas 
starwars %>% slice_tail(n = 3) # 3 √∫ltimas filas 
```

Una opci√≥n tambi√©n habitual es querer **extraer un n√∫mero de filas pero AL AZAR**, pudiendo hacerlo sin reemplazamiento (una vez extra√≠da, no se puede volver a extraer) o con reemplazamiento (`replace = TRUE`).

```{r}
# Tambi√©n podemos hacer una extracci√≥n al azar de filas
starwars %>% slice_sample(n = 5) # 5 al azar
starwars %>% slice_sample(n = 100, replace = TRUE) # 100 con reemplazamiento
```

Por √∫ltimo, tenemos `slice_min()` y `slice_max()` que nos permite **extraer filas en funci√≥n del m√≠nimo y m√°ximo de una variable**. Por defecto, si hay empate, mostrar√° todas las filas (aunque supere el n√∫mero `n` indicado), salvo que `with_ties = FALSE`, que decidir√° en caso de empate cual mostrarte

```{r}
# Podemos extraer filas en funci√≥n del m√≠n/m√°x de una variable
starwars %>% slice_min(height, n = 5) # los 5 m√°s bajitos
starwars %>% # los 5 m√°s bajitos (sin empates, exactamente 5)
  slice_min(height, n = 5, with_ties = FALSE) 
starwars %>% slice_max(mass, n = 7) # los 7 m√°s pesados
```


### Reordenar filas (arrange)

Muchas veces necesitamos las **filas ordenadas en funci√≥n del valor de alguna de las variables**. Para ello tenemos la funci√≥n `arrange()` sin m√°s que pasarle como argumento el nombre de la variable que usaremos para la ordenaci√≥n

```{r}
# Con arrange ordenamos en base al orden de la variable que introduzcamos
starwars %>% arrange(height) # de bajitos a altos, yoda al poder
```

Por defecto la ordenaci√≥n es de menor a mayor pero **podemos invertirlo** usando `desc()`.

```{r}
# Por defecto lo hace ascendente pero podemos cambiarlo
starwars %>% arrange(desc(height))
```

La ordenaci√≥n puede realizarse **en base al valor de dos o m√°s variables**: ordenar√° las filas en base a la primera, en caso de empate usar√° la segunda, en caso de empate la tercera, y as√≠ sucesivamente.

```{r}
# Podemos combinar varios criterios: ordenados de bajitos a altos,
# y en caso de empate, de pesados a ligeros. Un dato NA va siempre al final
starwars %>% arrange(height, desc(mass))
```

&nbsp;

**`r colorize("WARNING: valores ausentes", "#ffc107")`**

Si te fijas los **`r colorize("valores ausentes van siempre al final", "#ffc107")`** de la ordenaci√≥n. Luego veremos como eliminarlos si quisi√©ramos.

&nbsp;

Como estar√°s imaginando **podemos combinar varias acciones en pocas l√≠neas**, filtrando datos a la vez que ordenamos el filtro resultante.

```{r}
# Podemos combinar varias acciones en pocas l√≠neas:
# seleccionamos humanos, hombres, de ojos marrones
# y en orden altura descendente y peso ascendente
starwars %>%
  filter(eye_color == "brown", species == "Human", sex == "male") %>%
  arrange(height, desc(mass))
```

### Eliminar filas. Eliminar duplicados

La misma l√≥gica que hemos usado para **seleccionar filas podemos usarla para eliminar filas**, simplemente negando la condici√≥n de filtrado. Por ejemplo, vamos a **eliminar las 5 primeras filas**.

```{r}
# Eliminamos por √≠ndices
starwars %>% slice(-(1:5)) # eliminamos las 5 primeras filas
```

Otra opci√≥n a la hora de eliminar filas es **eliminar filas duplicadas (o filas con valores duplicados en alguna columna)**. Para ello deberemos aplicar la funci√≥n `distinct()`, con argumentos el nombre de las variables que usaremos para quitar duplicados.

```{r}
# Eliminamos duplicados
starwars %>% # Eliminamos registros con igual par (color_pelo, color_ojos)
  distinct(hair_color, eye_color)
```

Si te fijas adem√°s nos ha extra√≠do las dos columnas en base a las cuales hemos eliminado duplicados. Si queremos que nos mantenga toda la tabla deberemos explicitarlo con `.keep_all = TRUE`.

```{r}
# Eliminamos duplicados
starwars %>% # Eliminamos registros con igual par (color_pelo, color_ojos)
  distinct(hair_color, eye_color,
           .keep_all = TRUE) # .keep_all = TRUE mantiene todas columnas
```

Si no incluimos ning√∫n nombre de columna nos eliminar√° solo los registros que tengan TODOS los campos duplicados.

```{r}
# Duplicamos el conjunto para probarlo
duplicado_starwars <- rbind(starwars, starwars)
dim(duplicado_starwars)

# Eliminamos duplicados (filas exactamente iguales)
duplicado_starwars %>% distinct()
dim(duplicado_starwars %>% distinct())
```

## Operaciones con columnas

Ya hemos visto algunas opciones para manejar filas. Pasemos a  **seleccionar columnas** o **construir columnas/variables nuevas** en base a las ya existentes.


### Seleccionar (select) y extraer (pull) columnas

La opci√≥n m√°s sencilla es usar la funci√≥n `select()` pas√°ndole como argumentos los nombres de columnas (¬°SIN COMILLAS!) queremos seleccionar.

```{r}
# select: columnas a seleccionar sin comillas
starwars %>% # seleccionamos solo 3 columnas: pelo, piel y ojos
  select(hair_color, skin_color, eye_color)
```

Si las columnas a seleccionar sabemos que son consecutivas, podemos indicarle que las seleccionemos desde una **columna inicial hasta una columna inicial** pasando por todas.

```{r}
# Podemos seleccionar columnas en orden: desde nombre hasta a√±o nacim.
starwars %>% select(name:birth_year)
```

Una de las mejores opciones en este entorno es que las columnas las podemos seleccionar a trav√©s de expresiones regulares, por ejemplo, **seleccionando solo aquellas columnas que compartan un sufijo com√∫n en el nombre**, con `ends_with()` dentro de √≥rdenes como `select()`

```{r}
# Podemos seleccionar columnas por sufijo y prefijo
starwars %>% select(ends_with("color")) # acaban en "color"
```

De una manera similar podemos **seleccionar columnas cuyo nombre empiecen o contengan** alguna cadena de texto concreta

```{r}
starwars %>% select(starts_with("h")) # empiezan por h
starwars %>% select(contains("h")) # contienen la h
```

Todo lo que hemos usado para seleccionar lo podemos usar para **eliminar columnas**

```{r}
starwars %>% # seleccionamos todas menos 3 columnas: pelo, piel y ojos
  select(-c(hair_color, skin_color, eye_color))


```

Incluso nos permite **seleccionar aquellas columnas que son del mismo tipo** (imagina que necesitamos solo las columnas num√©ricas para calcular ciertas estad√≠sticas).

```{r}
# Seleccionamos solo la columnas num√©ricas
starwars %>% select(where(is.numeric))
```

Por √∫ltimo, podemos no tanto seleccionar sino **extraer columnas**: las saca fuera de la tabla y las convierte en un vector fuera del `tibble`, con la funci√≥n `pull()`.

```{r}
starwars %>% pull(name)
```

### Renombrar (rename) y reordenar (relocate) columnas

A veces tambi√©n podemos querer **modificar la ¬´metainformaci√≥n¬ª de la tabla**, no modificando los datos sino **renombrando el orden de las columnas**. Para ello debremos usar la funci√≥n `rename()` poniendo primero el nombre nuevo y luego el antiguo

```{r}
# rename: renombrar columnas, primero el nuevo y luego el antiguo
starwars %>% rename(nombre = name, altura = height, peso = mass)
```

De la misma manera podemos **reordenar las columnas**, indicando el nombre de columnas que queremos mover, y con `.after` y/o `.before` para indicar antes o despu√©s de que columnas queremos moverlas.

```{r}
starwars %>% # altura y masa detr√°s de color de piel
  relocate(height, mass, .after = skin_color) 
starwars %>% # color de piel, pelo y ojos antes de peso
  relocate(hair_color, skin_color, eye_color,
           .before = mass) 
```

Otra opci√≥n es hacerlo con `select()`, indic√°ndole el orden de las columnas manualmente, pudiendo hacer uso de `everything()` para **incluir el resto de columnas no mencionadas anteriormente**.

```{r}
starwars %>% select(name, homeworld, everything())
```


## Crear nuevas variables (mutate)

en breve 


A veces no queremos modificar variables ya existentes sino **crear nuevas variables/columnas** en base a variables ya existentes. Para ello tenemos la opci√≥n de `mutate()` que nos permite crear una nueva variable en funci√≥n de las existentes.

```{r}
# Mutate: nos a√±ade nuevas columnas usando funciones
# aplicadas a nuestras variables
starwars %>% mutate(height_m = height / 100) # altura en metros
``` 

Recuerda que para **ver todas las columnas** debes indicarle que quieres imprimir todas.

```{r}
print(starwars %>% mutate(height_m = height / 100), width = Inf)
``` 

Otra opci√≥n es **quedarnos solo con las columnas nuevas creadas** con `transmute()`

```{r}
starwars %>% transmute(height_m = height / 100)
``` 

Si queremos a√±adir **varias variables** en funci√≥n de las ya existentes podemos hacerlo ya que permite incorporar los datos de forma secuencial sin duplicar √≥rdenes de `mutate()` para cada una.

```{r}
print(starwars %>%
  # Calculamos altura en metros y el IMC
  mutate(height_m = height / 100,
         BMI = mass / (height_m^2)), width = Inf)
```

Como ves **por defecto a√±ade las columnas al final** pero podemos **reordenar las columnas** como ya hemos visto
```{r}
starwars %>%
  mutate(height_m = height / 100,
         BMI = mass / (height_m^2)) %>%
  relocate(height_m, BMI, .after = name)
```

Tambi√©n podemos pasarle una **funci√≥n propia que queramos definir**, no solo funciones de `R`. Vamos a definir la funci√≥n que nos calcula el IMC, a la que llamaremos `BMI_fun`, que necesita solo de dos argumentos: la altura en metros y el peso.

```{r}
BMI_fun <- function(m, h) {
  
  return(m / h^2)
}
BMI_fun(90, 1.6)
```

La funci√≥n definida como `BMI_fun()` podemos ahora aplicarla dentro de `mutate()`.

```{r}
starwars %>%
  mutate(height_m = height / 100,
         BMI = BMI_fun(mass, height_m)) %>%
  # Las movemos al inicio (por defecto las mete al final)
  relocate(height_m, BMI, .after = name)
```

Tambi√©n se pueden aplicar funciones m√°s complejas como la funci√≥n `map()` del paquete `{purrr}`: dado que las listas no se pueden vectorizar, esta funci√≥n nos permite **aplicar operaciones a listas, elemento a elemento de cada una de ellas**. Veamos un ejemplo: imagina que queremos calcular el n√∫mero de pel√≠culas en las que sale cada personaje de la saga.

```{r}
# Pel√≠culas de los 5 primeros personajes
starwars$films[1:5]
```

Las pel√≠culas de cada personaje est√°n en **modo lista**: no pod√≠amos guardarlo en un `data.frame` ya que cada personaje ha podido participar en un n√∫mero distinto (en una tabla, todas las columnas tienen la misma longitud). Para saber la cantidad de pel√≠culas en las que ha participado el primer personaje basta con usar el comando `length()` (nos dar√° el n√∫mero de elementos de la lista).

```{r}
length(starwars$films[1])
```

**¬øC√≥mo aplicar dicha a funci√≥n a cada personaje?** Con `map()` y la funci√≥n a aplicar en cada elemento de la lista.

```{r}
# Mapeamos la lista con length
(starwars$films %>% map(length))[1:10]
```

Si te fijas con los 10 primeros, lo que nos devuelve por defecto a su vez una lista, cuando a nosotros **nos gustar√≠a que nos devolviera un vector que poder incluir como columna**. Para ello existen diversas funciones como `map_chr()`, `map_dbl()` para devolverlo en un formato concreto

```{r}
# Mapeamos la lista con length pero devolvemos un vector de n√∫meros enteros
starwars$films %>% map_int(length)
```

Ya solo nos falta incorporar dicha operaci√≥n a una nueva columna con `mutate()`
```{r}
starwars %>%
  mutate("n_peliculas" = map_int(films, length)) %>%
  select(c(name, homeworld, n_peliculas))
```



### Recategorizar columnas

Una operaci√≥n tambi√©n muy habitual es querer **recategorizar nuestras variables**: tenemos categor√≠as ya existentes o variables num√©ricas que queremos convertir a categor√≠a (factores en `R`). Supongamos por ejemplo que queremos **crear una categor√≠a para cada registro** en funci√≥n de su altura: menos de 120, entre 120 y 180, y m√°s de 180. Para ello podemos hacer uso de la funci√≥n `cut()`, a la que en el argumento `breaks` le debemos indicar los **¬´cortes¬ª o saltos de la variable**.

```{r}
print(starwars %>% mutate("estat_categoria" = cut(height, breaks = c(-Inf, 120, 180, Inf))), width = Inf)
```

Recuerda que si quieres **mostrar solo las nuevas columnas** creadas puedes usar `transmute()`

```{r}
starwars %>% transmute("estat_categoria" = cut(height, breaks = c(-Inf, 120, 180, Inf)))
```

Si queremos que la categor√≠a tenga un nombre expl√≠cito (y no el intervalo en s√≠), podemos indic√°rselo en `labels = ` el vector de nombres de las categor√≠as.

```{r}
starwars %>%
  transmute("estat_categoria" = cut(height, breaks = c(-Inf, 120, 180, Inf),
                                    labels = c("bajos", "medios", "altos")))
```

Otra opci√≥n es hacerlo con la funci√≥n `factor` que nos transforma una variable en categor√≠a.

```{r}
# Vamos a categorizar en bajitos a los que miden menos de 180 cm
starwars %>%
  mutate(talla = factor(height < 180, labels = c("bajos", "altos")))
```

## Datos ausentes y outliers



Como ya vimos en [Tipos de datos I: vectores](#vectores), los datos ausentes en `R` pueden venir representados por valores `NA` o por valores `NaN` (en realidad este no ser√≠a ausente siendo estrictos, es simplemente un resultado no num√©rico dentro de los reales). **¬øQu√© hacer con dichos valores?**

Una primera opci√≥n puede ser **eliminar los registros que contengan campos ausentes en alguna de sus variables**, haciendo uso de la funci√≥n `drop_na()`.

```{r}
starwars %>% drop_na()
```

Como ves solo 6 de los 87 registros tienen todos los campos completos. Como quiz√°s **no todos los campos sean igual de importantes** en nuestros, podemos indicarle que nos elimine aquellos registros que tengan datos ausentes **algunos campos en concreto** (o una coelcci√≥n de ellos)

```{r}
starwars %>% drop_na(mass, height, sex, gender, birth_year)
```

Otra opci√≥n es **imputar su valor** en el caso de variables cuantitativas por, por ejemplo, la **media de la variable sin datos ausentes**, y  **recategorizar las cuantitaivas creando un categor√≠a** per se de ausentes.

```{r}
starwars %>%
  # Variables cuanti
  mutate(across(where(is.numeric),
                ~replace(.x, is.na(.x), mean(.x, na.rm = TRUE)))) %>%
  # Variables cuali: pasamos NA y "none" a "unknown"
  mutate(across(where(is.character),
                ~replace(.x, is.na(.x) | .x == "none", "unknown")))
  
```

&nbsp;

Muchas veces tendremos variables con **valores muy alejados de la centralidad**, centralidad normalmente entendida como media o mediana, valores muy extremos (conocidos como **valores at√≠picos o outliers**).

* **Respecto a la mediana/percentiles (iqr)**: una definici√≥n de outlier muy habitual es definirlo como un **valor muy alejado del primer/tercer cuartil**. La definici√≥n que se suele usar es que el dato sea interior/superior al primer/tercer cuartil una amplitud de X veces el **rango intercuart√≠lico** (conocido como **IQR, calculado como el tercer cuartil menos el primer cuartil**) por debajo/encima.

* **Respecto a la media (gesd)**: el criterio utilizado suele ser el conocido como GESD (Generlized Extreme Studentized Deviate Test), un contraste de hip√≥tesis cuya hip√≥tesis nula es que no hay at√≠picos en los datos. Puedes ver la formulaci√≥n matem√°tica en <https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm>

Para su localizaci√≥n autom√°tica usaremos el paquete `{anomalize}`, y la funci√≥n hom√≥nima de dicho paquete, indic√°ndole la columna individual en la que queremos detectar outliers y el m√©todo a usar. Con el m√©todo `method = "gesd"` realizaremos el contraste dato a dato de forma secuencial (si hay outlier lo quita individualmente y vuelve a ejecutarlo). Con `method = "iqr"`, ese factor `X` que nos distanciamos del primer y tercer cuartil es calculado como `0.15/alpha`, de forma que con `alpha = 0.05` (por ejemplo), dicho factor ser√≠a `X = 3`. Es **MUY IMPORTANTE** quitar antes los valores ausentes (para que pueda ejecutarse correctamente).

```{r}
library(anomalize)
# Importante: quitar antes missings
starwars %>% drop_na(mass) %>% anomalize(mass, method = "gesd")
``` 

En las columnas `mass_l1` y `mass_l2` se nos han guardado los l√≠mites para considerar o no outlier, y en `anomaly` tendremos si el valor es un outlier o no. Podemos renombrar dicha columna y recategorizarlo con `TRUE/FALSE`

```{r}
print(starwars %>%
        drop_na(mass) %>%
        anomalize(mass, method = "gesd") %>%
        rename(outlier = anomaly) %>%
        # Eliminamos la variables auxiliares creadas
        select(-c(mass_l1, mass_l2)) %>%
        mutate(outlier = (outlier == "Yes")), width = Inf)
```

Dicha variable auxiliar la podremos usar para **decidir si incluir o no el registro** en futuros pasos, pero tambi√©n **podemos usarla para imputarle un valor** (por ejemplo, la media).

```{r}
print(starwars %>%
        drop_na(mass) %>%
        anomalize(mass, method = "gesd") %>%
        rename(outlier = anomaly) %>%
        # Eliminamos la variables auxiliares creadas
        select(-c(mass_l1, mass_l2)) %>%
        mutate(outlier = (outlier == "Yes"),
               mass = ifelse(outlier, mean(mass), mass)),
      width = Inf)
```


## üìù Ejercicios

en breve


