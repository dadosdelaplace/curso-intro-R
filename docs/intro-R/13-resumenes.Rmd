```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```


# Resumiendo y relacionado los datos {#resumenes}

Ahora que **ya sabemos depurar y transformar los datos** con pocas l√≠neas de c√≥digo, as√≠ como extraer la informaci√≥n que nos interese, en esta secci√≥n vamos a aprender dos cosas b√°sicas a la hora de trabajar con datos:

* Realizar **res√∫menes num√©ricos** de los datos, de forma general pero tambi√©n cuando queremos calcular estad√≠sticas desagregadas por grupos.
* **Relacionar tablas** entre s√≠ (los famosos _join_).


## Tablas de frecuencias

Una de las **primeras cosas** que uno aprende en la asignatura de estad√≠stica **descriptiva** es **saber resumir nuestros datos** cuando tenemos muchos, y adem√°s **muchos valores repetidos**. Vamos a construir la **tabla de frecuencias** de la variable `n_films` de nuestro ya conocido conjunto `starwars` (una variable que vamos a crear contando en cu√°ntas pel√≠culas aparece cada personaje)

```{r}
library(purrr)
library(tidyverse)
starwars_nueva <- starwars %>%
  mutate(n_films = map_int(films, length))
```

Y lo primero es **contar**: ¬øcu√°ntos registros hay de cada una de las clases? Para ello usaremos la funci√≥n `count()`

```{r}
starwars_nueva %>% count()
```

Como ves si aplicamos la **funci√≥n directamente** simplemente nos **cuenta el n√∫mero de filas** de la tabla, as√≠ que vamos a **usar la misma funci√≥n pero indic√°ndole la variable**.

```{r}
tabla_freq <- starwars_nueva %>% count(n_films)
tabla_freq
```

Esa columna `n` es lo que conocemos como **frecuencias absolutas**, el **n√∫mero de veces** que la variable toma dicha valor. Tambi√©n es posible **calcular las frecuencias absolutas** por varias variables a la vez (algo similar a una **tabla de contigencia** aunque en otro formato).

```{r}
starwars_nueva %>% count(sex, gender)
```

**¬øC√≥mo seguir construyendo nuestra tabla de frecuencias en `tabla_freq`?** Necesitamos a√±adir una columna `N_i` de **frecuencia absoluta acumulada**, una columna que nos diga el **n√∫mero de personajes que han hecho un n√∫mero de pel√≠culas igual o menor** que el indicado.


```{r}
# Construimos de cero
tabla_freq <- starwars_nueva %>%
  # n: frecuencia absoluta
  count(n_films) %>%
  # N_i: frecuencia absoluta acumulada
  mutate(N_i = cumsum(n)) # cumsum calcula la suma acumulada
tabla_freq
```

Tambi√©n **necesitamos otras dos columnas** `f_i` y `F_i`, de **frecuencias relativas** (no acumulada y acumulada, respectivamente), que nos indica lo mismo que las dos primeras columnas pero en **proporci√≥n** respecto a los datos.

```{r}
# Construimos de cero
tabla_freq <- starwars_nueva %>%
  # n: frecuencia absoluta
  count(n_films) %>%
  # N_i: frecuencia absoluta acumulada
  mutate(N_i = cumsum(n)) %>% # cumsum calcula la suma acumulada
  mutate(f_i = prop.table(n), # prop.table nos devuelve proporciones
         F_i = cumsum(f_i))
tabla_freq
```

Esas **frecuencias relativas** quiz√°s querramos tenerlas expresadas en **porcentajes** en lugar de en proporciones.

```{r}
# Pasamos frecuencias relativas a porcentajes
tabla_freq %>% mutate(f_i = f_i * 100,
                      F_i = F_i * 100)
```

Por √∫ltimo, con la tabla `tabla_freq` expresando las frecuencias relativas en proporciones, vamos a cambiar el nombre de las columnas para que tengan los **t√≠picos nombres de una tabla de frecuencias**.

```{r}
# Renombramos
tabla_freq <- tabla_freq %>%
  rename(n_i = n, x_i = n_films)
tabla_freq
```

```{r, echo = FALSE, message = FALSE}
library(DT)
datatable(options =
            list(pageLength = 10, scrollX = TRUE,
                 fixedColumns = list(leftColumns = 1),
                 headerCallback = DT::JS(
                   "function(thead) {",
                   "  $(thead).css('font-size', '0.95em');",
                   "}"
                   ),
                 language =
                   list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')),
          tabla_freq, rownames = FALSE,
          caption = "Tabla de frecuencias del n√∫mero de pel√≠culas en las que aparecen los personajes de la saga.") %>%
   formatRound(c("f_i", "F_i"), digits = 3, mark = ".",
                 dec.mark = getOption("OutDec"))
```

Con esta tabla podemos **calcular por ejemplo la media** $\overline{x}$ **usando el resumen que tenemos guardado** (como se suele - o sol√≠a - hacer cuando se tiene que realizar ¬´a mano¬ª un ejercicio de este tipo en los primeros cursos de estad√≠stica).

$$\overline{x} = \frac{1}{N} \sum_{i=1}^{k} n_i x_i = \sum_{i=1}^{k} f_i x_i$$

```{r}
library(glue)

# Renombramos
tabla_freq <- tabla_freq %>% mutate(f_i_x_i = f_i * x_i)
media <- sum(tabla_freq$f_i_x_i)
print(glue("La media de pel√≠culas es {round(media, 3)}"))
```

&nbsp;

**¬øC√≥mo construir una tabla similar para variables continuas?** La metodolog√≠a ser√≠a la misma solo que antes debemos **agrupar los datos** (por ejemplo, de la variable `height`) en **subintervalos**.

```{r}
# Construimos de cero
tabla_freq_continua <-
  starwars %>%
  # agrupamos los datos en tramos de 20 en 20
  mutate(intervalo = cut(height, breaks = seq(65, 265, by = 20))) %>%
  # n: frecuencia absoluta
  count(intervalo) %>%
  # N_i: frecuencia absoluta acumulada
  mutate(N_i = cumsum(n)) %>% # cumsum calcula la suma acumulada
  mutate(f_i = prop.table(n), # prop.table nos devuelve proporciones
         F_i = cumsum(f_i))
tabla_freq_continua
```

El problema es que **cuando agrupamos los datos de una varibale continua en subintervalos**, aunque nos sirva como **resumen** para tener una idea de como se comporta nuestra variable (y sea **algo necesario para, por ejemplo, construir un ¬´histograma discretizado¬ª**), a la hora de calcular sus estad√≠sticas perdemos informaci√≥n ya que todos los elementos que cae en un intervalo se les **imputar√° un √∫nico valor: la marca de clase, que normalmente es el punto medio del intervalo**.

Vamos a **calcular res√∫menes num√©ricos** de las variables sin agrupar aprovechando que `R` el trabajo por nosotros/as.

## Res√∫menes num√©ricos (summarise y skimr) y por grupos (group_by)

Antes de pasar a ver **c√≥mo generar nuestras propias estad√≠sticas de los datos**, veamos la funcionalidad de un maravilloso paquete llamado `{skimr}`, que nos permite tener en un vistazo un **resumen num√©rico** muy completo de nuestros datos, con **histograma/diagrama de barras incluido**.

```{r}
library(skimr)
starwars %>% skim()
```

Dicho resumen nos proporciona:

- Variables de tipo **caracter**: `n_missing` (n√∫mero de ausentes), `complete_rate` (proporci√≥n de datos sin ausentes), `min/max` y `n_unique` (n√∫mero de valores √∫nicos).

- Variables de tipo **lista**: `n_missing` (n√∫mero de ausentes), `complete_rate` (proporci√≥n de datos sin ausentes), `n_unique` (n√∫mero de valores √∫nicos) y `min_length/max_length` (longitud m√≠nimo/m√°xima de las listas).

- Variables de tipo **num√©rico**: `n_missing` (n√∫mero de ausentes), `complete_rate` (proporci√≥n de datos sin ausentes), `mean/sd` (media y cuasidesviaci√≥n t√≠pica), `p0/p25/p50/p75/p100` (cuartiles, percentiles 0%-25%-50%-75%-100%, valores que nos dividen nuestro conjunto en 4 trozos) e `hist` (una especie de histograma/barras sencillo).

Este resumen no solo podemos visualizarlo sino que podemos guardarlo para exportarlo por ejemplo en un `.csv`.

```{r}
library(skimr)
resumen_skim <- starwars %>% skim()
```

Sin embargo, aunque el resumen es bastante completo, muchas veces **querremos generar nuestras propias estad√≠sticas o res√∫menes num√©ricos**, y para eso vamos a aplicar `summarise()`, que nos calcular√° estad√≠sticas de nuestros datos. Por ejemplo, vamos a **calcular las medidas de centralizaci√≥n (media-mediana-moda)**. Para las dos primeras basta con aplicar las funciones correspondientes.

```{r}
starwars %>% summarise(media = mean(mass),
                       mediana = median(mass))
```

Como ves nos **devuelve un dato ausente** ya que al existir datos ausentes en la variables, **la media tambi√©n lo es**. Para evitar ese problema **podemos hacer dos cosas**: eliminar antes los ausentes o indicarle en la propia media y mediana que haga el c√°lculo ignorando los valores `NA`.

```{r}
# Primero eliminamos NA
starwars %>% drop_na(mass) %>%
  summarise(media = mean(mass), mediana = median(mass))

# Al realizar el c√°lculo los ignora
starwars %>%
  summarise(media = mean(mass, na.rm = TRUE),
            mediana = median(mass, na.rm = TRUE))
```

La **media** es una medida de centralizaci√≥n basada en el valor que nos **minimiza el promedio de desviaciones al cuadrado (varianza)** y solo se puede calcular para **variables cuantitativas (discretas o continuas)**.

```{r}
# Media de todas las cuantitativas
starwars_nueva %>%
  summarise(media = across(where(is.numeric), mean, na.rm = TRUE))
```

La **mediana** se define como el **valor que ocupa el centro de los datos CUANDO LOS ORDENAMOS de menor a mayor**, un valor que nos deja por debajo al menos el 50% y por encima al menos el 50%.

```{r}
# Media y mediana de todas las cuantitativas
starwars_nueva %>%
  summarise(media = across(where(is.numeric), mean, na.rm = TRUE),
            mediana = across(where(is.numeric), median, na.rm = TRUE))
```

La **mediana tambi√©n se puede calcular para variables cualitativas ordinales (categor√≠as que se puedan ordenar)**. Vamos a construir una variable que sea ¬´muy bajo-bajo-medio-alto-muy alto¬ª seg√∫n la estatura, y calcular la mediana para dichas categor√≠as.

```{r}
categorias <- c("muy bajo", "bajo", "medio", "alto", "muy alto")
starwars_talla <- 
  starwars %>%
  mutate(talla =
           cut(height, breaks = c(-Inf, 80, 120, 160, 190, Inf),
               labels = categorias))

# Mediana (hay que pas√°rselo como n√∫mero)
starwars_talla %>%
  summarise(mediana =
              categorias[median(as.numeric(talla), na.rm = TRUE)])
```

Para la **moda tenemos alg√∫n problema mayor** ya que no hay un funci√≥n en los paquetes `{base}` para su c√°lculo, as√≠ que para ello **usaremos el paquete `{modeest}`**: la funci√≥n `mfv()` nos calcula la **moda exacta** de una variable num√©rica discreta o cuantitativa (busca los valores m√°s repetidos), la funci√≥n `mlv()` nos calcula la **moda estimada** de una variable num√©rica continua.


```{r, warning = FALSE}
library(modeest)

# Media y mediana y moda de mass y n_films
resumen <- 
  starwars_nueva %>%
  summarise(media = across(c(mass, n_films), mean, na.rm = TRUE),
            mediana = across(c(mass, n_films), median, na.rm = TRUE),
            moda_n_films = mfv(n_films, na_rm = TRUE),
            moda_mass = mlv(mass, na.rm = TRUE))
resumen
```

F√≠jate que el resumen ha agrupado todas las modas y medianas que hemos calculado a la vez: **la salida de nuestro resumen es una lista, con tablas a su vez dentro**.

De la misma manera podemos pedirle que nos calcule **medidas de dispersi√≥n (varianza, desv. t√≠pica y cv, c√≥mo de dispersos est√°n los datos respecto a un centro, normalmente la media)** y **medidas de localizaci√≥n (percentiles)**.

```{r, warning = FALSE}
starwars %>%
  summarise(media = mean(mass, na.rm = TRUE),
            mediana = median(mass, na.rm = TRUE),
            moda = mlv(mass, na.rm = TRUE),
            var = var(mass, na.rm = TRUE),
            sd = sd(mass, na.rm = TRUE),
            cv = sd / abs(media),
            p13 = quantile(mass, probs = c(0.13), na.rm = TRUE),
            p87 = quantile(mass, probs = c(0.87), na.rm = TRUE))
``` 

Haciendo uso de cosas ya vistas podemos, por ejemplo, **calcular el coeficiente de variaci√≥n (CV)** de todas las variables num√©ricas para poder decidir cual es m√°s o meno dispersa.

```{r, warning = FALSE}
resumen <- 
  starwars %>%
  summarise(media = across(where(is.numeric), mean, na.rm = TRUE),
            var = across(where(is.numeric), var, na.rm = TRUE),
            cv = sqrt(var) / abs(media))
resumen$media
resumen$var
resumen$cv # m√°s homog√©nea la altura por tener menos CV.
``` 

### Agrupando datos: group_by

Una de las **funcionalidades m√°s potentes es la opci√≥n de a√±adir antes una agrupaci√≥n** con `group_by()`. Esta funci√≥n per se no cambia los datos sino que cambia la forma en la que se aplicar√°n las funciones posteriores, realiz√°ndose por **desagregadas grupos**.

Imagina que queremos calcular la **media de altura y peso** de cada personaje PERO desagregada por cada una de las clases que tenemos en la variable `sex`.

```{r}
starwars %>% group_by(sex) %>%
  summarise(media_altura = mean(height, na.rm = TRUE),
            media_peso = mean(mass, na.rm = TRUE)) %>%
  ungroup()
```

Lo que obtenemos no es la media de todos los personajes sino la **media desagregada por grupo**, grupo marcado por la variable `sex`. Las **agrupaciones pueden estar en funci√≥n de varias variables** a la vez.

```{r}
starwars %>% group_by(sex, gender) %>%
  summarise(media_altura = mean(height, na.rm = TRUE),
            media_peso = mean(mass, na.rm = TRUE)) %>%
  ungroup()
```

Dicha funci√≥n tambi√©n es muy √∫til cuando queremos **realizar un filtro de registros en base al n√∫mero de cada clase**: por ejemplo, vamos a filtrar los registros que pertenezcan a una clase de `sex` que tenga al menos 10 individuos dentro de dicho grupo.

```{r}
starwars %>%
  group_by(sex) %>%
  count() %>%
  ungroup()
```

Si te fijas solo deber√≠amos filtrar los registros que sean `female` y `male`. Vamos a hacerlo de forma autom√°tica en base a dicho **umbral**.

```{r}
# Podemos filtrar por grupos solo aquellos que superen un
# un umbral m√≠nimo
starwars %>% 
  group_by(sex) %>% 
  filter(n() > 10) %>%
  ungroup()
```

Para comprobar r√°pidamente que efectivamente solo ha filtrado aquellos grupos con m√°s de 10 elementos en ellos podemos **a√±adir `count()`**.

```{r}
starwars %>% 
  group_by(sex) %>% 
  filter(n() > 10) %>%
  count() %>%
  ungroup()
```

Los res√∫menes y las agrupaciones podemos **combinarlas de todas las formas que nos imaginemos**, por ejemplo, calculando la media desagregada por sexo y g√©nero pero solo de las variables num√©ricas.

```{r}
starwars %>% # doble agrupaci√≥n
  group_by(sex, gender) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  ungroup()
```

### Rowwise: operaciones por filas

Por √∫ltimo veamos un ejemplo de una **opci√≥n muy √∫til usada antes de una operaci√≥n que es** `rowwise()`: toda operaci√≥n que venga despu√©s se aplicar√° **en cada fila por separado**. Para el ejemplo vamos a definir un fichero _dummy_ de notas en mates, lengua y dibujo de 50 alumnos. Para ello usamos la funci√≥n `sample()`: le decimos que seleccione aleatoriamente `size = 50` notas de un conjunto de notas posibles (`0:10`), y que lo haga con reemplazamiento (`replace = TRUE`, es decir, que dos alumnos puedan tener la misma nota)

```{r}
notas <- tibble("mates" = sample(0:10, size = 50, replace = TRUE),
                "lengua" = sample(0:10, size = 50, replace = TRUE),
                "dibujo" = sample(0:10, size = 50, replace = TRUE))
notas
```

Una vez que tenemos 3 notas aleatorias por cada uno de los 50 alumnos, **¬øqu√© sucede si yo quiero calcular la nota media del curso?**

```{r}
notas %>% mutate(media_curso = mean(c(mates, lengua, dibujo)))
```

Como ves si aplicamos la media de las tres variables, en cada fila el valor de `media_curso` es id√©ntico ya que nos ha hecho la **media global**: ha tomado las 50 filas, las 3 columnas, y ha hecho la media de 150 datos. Cuando en realidad a nosotros nos gustar√≠a **sacar una media por registro**, que para cada alumno tengamos la media de las asignaturas.

```{r}
# Aplicado por fila
notas %>% rowwise() %>%
  mutate(media_curso = mean(c(mates, lengua, dibujo)))
```

Solos nos falta poner la guinda a lo aprendido a esta introducci√≥n: **vamos a ver como podemos relacionar dos conjuntos de datos distintos entre s√≠**.

## Relacionar datos (joins)

Una de las **opciones m√°s comunes para trabajar con datos** es tener a nuestra disposici√≥n diversas tablas, con alguno o varios de los campos en com√∫n, y nos interesa a veces **cruzar datos** de ambos para tener una informaci√≥n m√°s completa con el conjunto de las tablas. Es lo que se conoce en ciencia de datos e inform√°tica como **hacer un _join_ de tablas**. Para ese cruce ser√° **indispensable que haya uno o varios campos clave**, campos que sirvan para identificar un√≠vocamente cada registro (por ejemplo, DNI).

```{r joins, echo = FALSE, fig.cap = "Esquema con los principales tipos de join, extra√≠do de <https://estradawebgroup.com/Post/-Que-es-y-para-que-sirve-SQL-Joins-/4278>"}
knitr::include_graphics("./img/sql-joins.jpg")
```

Existen principalmente **cuatro tipos de cruces** si pensamos en cruzar un conjunto `A` con otro conjunto `B`:

- **Inner join**: solo nos quedamos con las **filas que tengan correspondencia en ambas tablas** (personas cuyo DNI aparezca en ambas tablas, por ejemplo).

- **Left (outer) join**: nos quedamos con **todas las filas de `A`**, buscando que registros de dicha tabla est√°n tambi√©n en `B`, completando los datos de esta tabla para esos registros.

- **Right (outer) join**: nos quedamos con **todas las filas de `B`**, buscando que registros de dicha tabla est√°n tambi√©n en `A`, completando los datos de esta tabla para esos registros.

- **Full join**: nos quedamos con **todas las filas de `A` y `B`**, tengan o no correspondencia en la otra tabla (si no est√° en una de ellas, las columnas correspondientes quedar√°n como campo ausente).


Esos **campos clave (keys)** ser√°n las columnas que usaremos para definir los cruces. Para los ejemplos usaremos las tablas del paquete `{nycflights13}`.

```{r}
library(nycflights13)
```

Dicho paquete cuenta con las siguientes **tablas**:

* `airlines`:	nombre de la aerol√≠nea (con su abreviatura).
* `airports`: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* `flights`: datos de vuelos (con `tailnum` como marca de idenfiticaci√≥n).
* `planes`:	datos de los aviones.
* `weather`: datos meteorol√≥gicos horarios de las estaciones LGA, JFK y  EWR.

Veamos un ejemplo: imagina que queremos **completar en la tabla de vuelos los datos de cada una de las aerol√≠neas que operan dichos vuelos**. Vamos a seleccionar unas pocas columnas para que sea m√°s f√°cil de visualizar.

```{r}
# Seleccionamos antes columnas para que sea m√°s corto
flights_filtrada <- flights %>%
  select(year:day, arr_time, carrier:dest)
flights_filtrada
```

Queremos **TODAS las filas de los vuelos**, todos sus registros, pero **a√±adiendo la informaci√≥n** que tenemos de la aerol√≠nea que opere los vuelos, as√≠ que haremos un **LEFT JOIN** de `flights` vs `airlines`. El campo com√∫n que nos permite cruzarla, la **clave (key)** es el c√≥digo abreviado de las aerol√≠neas (variable `carrier`).

```{r}
# Mismas filas pero con una nueva columna: siempre que sea
# posible el cruce tendr√° la info de la aerol√≠nea
l_join_flights_airlines <-
  flights_filtrada %>% left_join(airlines, by = "carrier")
l_join_flights_airlines
```

Si te fijas ahora tenemos en `l_join_flights_airlines` las mismas 336776 filas pero con una columna m√°s: la tabla `airlines` ten√≠a 2 columnas, una la com√∫n con `flights` y en otra la nueva que se ha incorporado a la tabla. **¬øY si en `flights` hab√≠a alg√∫n vuelo operado por alguna aerol√≠nea que no estuviese en `airlines`?**

```{r}
# Filtramos
l_join_flights_airlines %>% filter(is.na(name))
```

En este caso todos los registros de la primera tabla ten√≠an su correspondencia en la segunda tabla. Veamos un ejemplo donde suceda eso, quit√°ndole algunas filas a `airlines`, quitando las aerol√≠neas con c√≥digos `"B6"`.

```{r}
airlines_filtrada <- airlines %>% 
  filter(!(carrier %in% c("B6")))
l_join <- flights_filtrada %>% left_join(airlines_filtrada, by = "carrier")
dim(l_join %>% filter(is.na(name)))
```

En el anterior ejemplo tenemos 54 635 filas que cuyo nombre est√° ausente, es decir, 54 635 filas de `flights` que no tienen correspondencia en la tabla filtrada `airlines_filtrada`. Ahora las **filas que no han encontrado su _match_ en la segunda tabla est√°n como campo ausente**.

```{r}
l_join
```

```{r left-join, echo = FALSE, fig.cap = "Esquema del left join, extra√≠do de <https://r4ds.had.co.nz/relational-data.html#mutating-joins>"}
knitr::include_graphics("./img/left_join.jpg")
```

La misma l√≥gica para los **RIGHT JOIN** y los **FULL JOIN**. En este √∫ltimo tendremos bastantes datos ausentes, ya que todos los registros que no est√©n en ambas tablas tendr√°n una parte de sus variables como `NA`


```{r}
tabla1 <- tibble("key_1" = 1:7, "valor_1" = paste0("x", 1:7))
tabla2 <- tibble("key_2" = c(0, 1, 2, 5, 6, 9, 10),
                 "valor_2" = paste0("x", c(0, 1, 2, 5, 6, 9, 10)))

# Left
tabla1 %>% left_join(tabla2, by = c("key_1" = "key_2"))

# Right
tabla1 %>% right_join(tabla2, by = c("key_1" = "key_2"))

# Full
tabla1 %>% full_join(tabla2, by = c("key_1" = "key_2"))
```

```{r right-join, echo = FALSE, fig.cap = "Esquema del right join, extra√≠do de <https://r4ds.had.co.nz/relational-data.html#mutating-joins>"}
knitr::include_graphics("./img/right_join.jpg")
```

```{r full-join, echo = FALSE, fig.cap = "Esquema del full join, extra√≠do de <https://r4ds.had.co.nz/relational-data.html#mutating-joins>"}
knitr::include_graphics("./img/full_join.jpg")
```

Un tipo de join especial son los **INNER JOIN**. Hasta ahora la tabla resultante ten√≠a al menos tantas filas como tuviese la tabla m√°s peque√±a en el cruce. En el caso de los **INNER JOIN** vamos a **reducir el tama√±o** ya que solo nos quedaremos con **aquellos registros que podamos encontrar en ambas**, de forma que **el cruce nunca generar√° datos ausentes**.

```{r}
# Inner
tabla1 %>% inner_join(tabla2, by = c("key_1" = "key_2"))
```



```{r inner-join, echo = FALSE, fig.cap = "Esquema del inner join, extra√≠do de <https://r4ds.had.co.nz/relational-data.html#mutating-joins>"}
knitr::include_graphics("./img/inner_join.png")
```

## üìù Ejercicios

en breve

