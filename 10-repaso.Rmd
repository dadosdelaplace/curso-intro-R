```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```


# (PART) Alto en el camino {-}


# 쯈u칠 sabemos hacer? {#resumen-1}

**Hasta aqu칤 el aperitivo**

::: {.rmdnote}

**`r colorize("쯈u칠 datos hemos aprendido a manejar?", "#4197D2")`**


```{r echo = FALSE}
library(knitr)
paquetes <-
  data.frame("tipo de dato" = c("x <- 1 (dato num칠rico)",
                                "x <- c(1, 2, 3) (vector de n칰meros)",
                                "x <- c('a', 'b', 'c') (vector de caracteres)",
                                "x <- matrix(1:6, nrow = 2)",
                                "x <- data.frame('a' = 1:3, 'b' = c('a', 'b', 'c'), 'c' = c(TRUE, TRUE, FALSE))",
                                "x <- list(1:3, c('a'), c(TRUE, FALSE))"),
             "descripci칩n" = c("vector de longitud 1",
                               "vector (mismo tipo)",
                               "vector (mismo tipo)",
                               "matriz (mismo tipo, misma longitud)",
                               "data.frame (distinto tipo, misma longitud)",
                               "lista (distinto tipo, distinta longitud)"))
kable(paquetes, col.names = c("paquetes", "descripci칩n"), align = "ll",
      caption = "Tipos de datos mencionados hasta ahora")
``` 
:::

::: {.rmdnote}

**`r colorize("쯈u칠 paquetes hemos usado ya?", "#4197D2")`**

Como ves, hemos podido hacer bastantes cosas ya en `R` con muy pocos paquetes, y ocupando el m칤nimo espacio y tiempo en nuestro ordenador.


```{r echo = FALSE}
library(knitr)
paquetes <-
  data.frame("paquetes" = c("{base}", "{bookdown}", "{glue}",
                            "{stringr}", "{lubridate}", "{microbenchmark}",
                            "{tibble}", "{datasets}", "{readr}", "{tidyverse}",
                            "{readxl}", "{rvest}"),
             "descripci칩n" = c("utilidades b치sicas",
                               "creaci칩n de libros, manuales e informes en R",
                               "manejo de texto literal",
                               "manejo complejo de cadenas de texto",
                               "manejo de fechas",
                               "comparativa de tiempos de ejecuci칩n",
                               "data.frames eficientes",
                               "conjuntos de datos",
                               "lectura de datos rectangulares (tablas)",
                               "entorno de paquetes para el manejo de datos",
                               "lectura de datos en formato excel",
                               "lectura de datos web"))
kable(paquetes, col.names = c("paquetes", "descripci칩n"), align = "ll",
      caption = "Paquetes mencionados hasta ahora")
``` 
:::


Quiz치s creas que te queda un mundo por aprender:

- 쮺칩mo **manejo datos de forma m치s profunda** (filtrar, operar con ellos, etc)?
- 쮺칩mo realizo **an치lisis estad칤sticos**?
- 쮺칩mo **visualizo datos**?
- 쮺칩mo **generar informes** con los resultados (ver [@xie2015])?
- 쮺칩mo **crear webs interactivas** para la visualizaci칩n y an치lisis de datos?

No te voy a mentir: no tendr칤as d칤as de tu vida para ir investigando todos los paquetes que hay hechos en `R` (ni t칰 ni nadie). Pero la idea de estos primeros cap칤tulos no era que fueses experto en `R` sino que vieses que, **con pocas l칤neas de c칩digo y con cierta pr치ctica**, se puede empezar a tener herramientas para **comenzar nuestra andadura** en el an치lisis estad칤stico a trav칠s de este software. No te obsesiones con saberte todos los comandos de todos los paquetes o acabar치s loco/a.

```{r echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Cuando intentas aprenderte todos los paquetes."}
knitr::include_graphics("./img/stanley_kubrick.jpg")

```

Estos primeros cap칤tulos de un lenguaje de programaci칩n suelen ser un poco 춺aburridos췉

* **Si sabes programar**, te habr치n parecido triviales (m치s all치 de conocer la sintaxis propia de `R`).
* **Si no sab칤as programar**, han sido de repente un pu침ado de conceptos y cosas a recordar, que hasta que nos los vayas practicando tendr치s que acudir a este manual (u otros recursos). **No te obsesiones con memorizar**: yo consulto cada d칤a cosas que aparecen en este tutorial porque se me olvidan.

**Lo importante es entender, no memorizar comandos**

Pero aunque sean m치s aburridos estos primeros conceptos, **son necesarios para empezar a caminar**: el inicio de aprender un idioma siempre es un poco meh, pero sin las reglas b치sicas de gram치tica y un m칤nimo de l칠xico nunca podr치s empezar.

## Recursos extras {#recursos}

Ahora que ya sabes lo b치sico para poder empezar a trabajar en un entorno amigable, aunque la idea es que este manual tenga m치s cap칤tulos (쯟os tiene?) para seguir avanzando, por si se me olvida, te dejo una **lista de recursos 칰tiles** para que puedas ir viendo el abanico de opciones que tienes

* **C칩digo de este manual**: este manual est치 programado en s칤 mismo en `R` y los c칩digos pueden ser consultados libremente en el repositorio de [GitHub](https://github.com/dadosdelaplace/docencia) (hablaremos m치s adelante de como gestionar versiones de nuestro c칩digo en dicha plataforma).

```{r github, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://github.com/dadosdelaplace/docencia', out.width = '70%'}
knitr::include_graphics('img/me_github.jpg')
```

* [Cursos y selecci칩n de paquetes](https://dadosdelaplace.com): **recopilatorio y selecci칩n de tutoriales y cursos de `R`** en distintos campos.

* [Incursi칩n a los modelos de regresi칩n en `R`](https://bookdown.org/roback/bookdown-BeyondMLR/): manual sobre el uso de distintos modelos predictivos basados los Modelos Lineales Generalizados (GLM).

* **Paquete para aprender `R`**: el paquete `{swirl}` permite ir aprendiendo de forma sencilla (con preguntas tipo test) algunos conceptos b치sicos de `R` (muchos de ellos vistos en este manual). Puedes consultar la documentaci칩n en su [p치gina web](https://swirlstats.com/)

```{r swirl, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://swirlstats.com/', out.width = '60%'}
knitr::include_graphics('img/swirl.png')
```


* **Manejo de datos**: probablemente el conjunto de herramientas m치s usadas en `R` sean los paquetes agrupados en {`tidyverse`} (y que veremos en cap칤tulos sucesivos si los hubiese), un [conjunto de paquetes integrados para un manejo intuitivo de los datos](https://www.tidyverse.org/), tanto en su preprocesamiento, como en la generaci칩n de estad칤sticas y gr치ficas.

* [Tidyverse cookbook](https://rstudio-education.github.io/tidyverse-cookbook/)
* [Tidyverse skills for data science](https://jhudatascience.org/tidyversecourse/)

```{r tidyverse-png, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://www.tidyverse.org/', out.width = '60%'}
knitr::include_graphics('img/tidyverse.jpg')
```

* **Visualizaci칩n de datos en Twitter**: una de las **fortalezas de `R`** es su versatilidad para la visualizaci칩n de datos. Y al igual que un escritor necesita leer mucho para tomar ideas, hay dos recursos en Twitter que te recomiendo encarecidamente:
  - El **hashtag #TidyTuesday** es una etiqueta en la que cada semana se plantea el reto de proponer la mejor visualizaci칩n para un conjunto de datos dado, donde no solo puedes participar con la comunidad sino [ver las visualizaciones de otros usuarios](https://github.com/rfordatascience/tidytuesday) de `R`.
  - Adem치s he elaborado una [lista de Twitter](https://twitter.com/i/lists/1324478481338683392?s=20) de usuarios que se dedican a la visualizaci칩n de datos.
  
* **Paquetes para la visualizaci칩n de datos**: los paquetes `{ggplot2}` y `{plotly}` son probablemente los paquetes por excelencia en `R` para la visualizaci칩n de datos. El **primero es uno de los paquetes m치s potentes de `R`, dentro del entorno `{tidyverse}`**, que no solo nos permite crear gr치ficos muy limpios y elegantes con pocas l칤neas sino que su sintaxis es muy intuitiva respecto a los datos visualizados. La idea inicial es poder aprender algo de `{ggplot2}` en futuros cap칤tulos pero puedes empezar si quieres echando un vistazo a su [web oficial](https://ggplot2.tidyverse.org/). Tambi칠n te recomiendo el [tutorial de C칠dric Scherer](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/). El segundo paquete, `{plotly}` puede llegar a tener las mismas funcionalidades pero su programaci칩n es m치s tediosa. Su principal ventaja es que **genera gr치ficos interactivos: gr치ficos HTML (como si fuera una p치gina web)** (no una imagen est치tica) que permite al usuario interactuar con los datos pasando el rat칩n (incluso permite crear men칰s). Un ejemplo es la [web de visualizaci칩n covid de Asturias](https://dgspasturias.shinyapps.io/panel_de_indicadores_asturias/) que elabor칠 durante la pandemia para el Gobierno de Asturias (la web en s칤 est치 elaborada con `{shiny}`, un paquete de `R` que [permite crear aplicaciones web](https://shiny.rstudio.com/tutorial/)).

* **Generaci칩n de informes desde R**: el paquete `{rmarkdown}` permite [generar directamente informes](https://rmarkdown.rstudio.com/) que mezclen texto, f칩rmulas matem치ticas, gr치ficas y c칩digo `R` (como este mismo manual), sin necesidad de importarlos a otras herramientas de Office.

* **Comunidad de R hispano**: tenemos un [grupo de Discord](https://discord.gg/7ueKQqeaGr) y [grupo de Telegram](https://t.me/hispanoverse) varios usuarios de R en Espa침a para compartir recursos.



## Incursi칩n aleatoria {#aleatorio-1}

Antes de acabar esta breve introducci칩n a `R` merece la pena hablar de **춺lo aleatorio췉** y su generaci칩n en `R`.


**쮺칩mo se define la aleatoriedad?**

Si alguna vez has interactuado con matem치ticos o estad칤sticos (Dios te libre), seguramente es una palabra que les hayas escuchado mentar: **aleatoriedad**. Existen m칰ltiples definiciones, y este manual tampoco pretende ser un tratado de filosof칤a de la ciencia, pero podemos definir la aleatoriedad de la siguiente manera:

::: {.rmdnote}

**`r colorize("Aleatoriedad", "#4197D2")`**

Propiedad de todo proceso cuyo resultado final no se puede conocer con exactitud - a nivel individual  o particular - antes de que se realice, aunque las condiciones iniciales se mantengan constantes (ejemplo: lanzar un dado).

**쯈u칠 NO significa la palabra 춺aleatorio췉?**

游띔 **NO** tiene que implicar algo **ca칩tico**.  
游띔 **NO** significa que no se pueda **predecir** a nivel de conjunto.  
游띔 **NO** significa que **carezca de un patr칩n** de comportamiento.
:::


El ejemplo perfecto para **entender las implicaciones de algo aleatorio es un dado**, ya que no podemos saber con exactitud cu치l ser치 la siguiente tirada, pero tiene un patr칩n: si tiramos un mill칩n de veces, aproximadamente un sexto del total de tiradas ser치n un 1.

&nbsp;

En el an치lisis estad칤stico y en la programaci칩n en `R` nos vamos a encontrar con m칰ltiples situaciones en las que **lo aleatorio juega un papel importante**, y aunque este sea un tutorial muy b치sico e introductorio, creo que es interesante conocer **algunas formas muy sencillas de generar n칰meros aleatorios** (o...no tanto, ahora llegamos a la Secci칩n \@ref(pseudoaleatorio)).

Empecemos por lo m치s simple: vamos a **simular tiradas de una moneda**, asumiendo que solo tenemos dos opciones (eliminando la opci칩n de caer de canto). Cuando tiramos una moneda es un experimento aleatorio, ya que no sabemos el resultado exacto de la siguiente tirada, pero s칤 sabemos que la probabilidad te칩rica es de 50-50, y que las 칰nicas opciones a elegir son `cara` y `cruz`.

Una forma de ver el experimento de lanzar una moneda es pensar que tenemos una **urna con dos bolas (cara y cruz)**, y empezamos a sacar bolas de la urna (**permitiendo que al sacar una bola, se pueda devolver a la urna de nuevo**). Eso es precisamente lo que hace la funci칩n `sample()`, una funci칩n que nos seleccionar치 춺aleatoriamente췉 elementos de una urna.

* `x`: los elementos distintos que tiene para elegir, que en nuestro caso ser치n `"cara"` y `"cruz"`.
* `size`: el n칰mero de bolas que queremos sacar de la urna.
* `replace`: si tras extraer devolvemos la bola a la urna (`replace = TRUE`) o si se queda fuera (`replace = FALSE`, valor por defecto).
* `prob`: la probabilidad que tiene cada elemento en caso de no ser equiprobables (valor por defecto).

```{r moneda}
# Tiramos 20 veces una moneda
sample(x = c("cara", "cruz"), size = 20, replace = TRUE)
```

F칤jate que hemos indicado expl칤citamente `replace = TRUE` para decirle que aunque solo tengamos dos opciones, vamos a permitir que tras extraer una bola, la apuntemos, y la volvamos a introducir (puede salir de nuevo). 쯈u칠 sucede si `replace = FALSE` (su valor por defecto)?

```{r moneda2, error = TRUE}
# Tiramos 20 veces una moneda SIN reemplazamiento
sample(x = c("cara", "cruz"), size = 20)
```

**Al tener solo dos opciones**, y no permitir que al extraer bolas vuelvan a la urna, tras extraer las dos 칰nicas bolas, **el proceso no puede continuar** hasta los 20 lanzamientos.

Como seguramente te hayas percatado, lanzar una moneda es un experimento dicot칩mico, y dichos experimentos tienen una gran ventaja en programaci칩n y es que podemos escribirlo en binario: `0` para lo que llamemos fracaso (cara, por ejemplo), `1` para lo que llamemos 칠xito (cruz).

Generar experimentos dicot칩micos de forma binario nos permite hacer c치lculos sobre las tiradas de forma muy sencilla e intuitiva, ya que nos permite pasar de tener cadenas de texto a n칰meros.

```{r}
# Tiramos 50 veces una moneda: 0 es cara, 1 es cruz
n_tiradas <- 50
tiradas <- sample(x = 0:1, size = n_tiradas, replace = TRUE)
tiradas

# Cantidad de cruces: sumamos los 1's
sum(tiradas)

# Cantidad de caras: lo que son cruces
n_tiradas - sum(tiradas)

# % de caras
cat(paste0(100 * sum(tiradas) / n_tiradas, "% de cruces"))
```

El argumento `prob = ...` nos permite generar experimentos que sean dicot칩micos pero que **no sean equiprobables**, algo similar a **lanzar una moneda trucada** (por ejemplo, 30% caras y 70% cruces). N칩tese como dichas probabilidades deben ser introducidas como proporciones (divididas entre 100).

```{r}
# Tiradas de una moneda trucada
tiradas <- sample(x = 0:1, size = n_tiradas, replace = TRUE, prob = c(0.3, 0.7))

# % de caras
cat(paste0(100 * sum(tiradas) / n_tiradas, "% de cruces"))
```

<details>
  <summary>游닇<strong>Ejercicio</strong>: 쯖칩mo simular칤as 200 tiradas de un dado?</summary>
  
<!-- toc -->
- Soluci칩n:

```{r}
# Lo 칰nico que cambia son las opciones en la urna
sample(x = 1:6, size = 200, replace = TRUE)
```

<!-- tocstop -->
</details>


## Pseudoaleatoriedad {#pseudoaleatorio}

Si has hecho varias pruebas con los c칩digos de arriba quiz치s ya hayas visto que **cada vez que lanzas el c칩digo, el resultado es distinto**, algo similar a lo que suceder칤a si lanzas una moneda. Prueba a ejecutar este c칩digo varias veces.

```{r}
sample(0:1, size = 20, replace = TRUE)
```

```{r}
sample(0:1, size = 20, replace = TRUE)
```

```{r}
sample(0:1, size = 20, replace = TRUE)
```


**쯏 si quisi칠ramos generar toda la clase la misma tirada de moneda?**

Lo primero que quiz치s pienses es que es **imposible**, ya que al tirar una moneda en la vida real, nunca vamos a tener forma de garantizar que salgan las mismas tiradas a diferentes personas. Y **efectivamente eso ser칤a cierto si nuestros procesos generados hubiesen sido aleatorios**, como en la vida real pero...no lo son.

Mientras esperamos a que lleguen al mainstream los ordenadores cu치nticos, **TODO lo que hay en tu ordenador es determ칤nistico**, ya que cualquier proceso se reduce a una **secuencia de bits (`0's` y `1's`)** y un **algoritmo** (sin azar, cuyo resultado siempre ser치 el mismo bajo las mismas condiciones iniciales). He aqu칤 la decepci칩n de tu vida: un ordenador 춺normal췉 NO puede generar procesos aleatorios, sino **procesos y n칰meros PSEUDOALEATORIOS**, basados en **cadenas pseudoaleatorias** generadas por un algoritmo determin칤stico.

Dichas secuencias aparentan ser aleatorias pero no lo son, y de hecho muchas son **peri칩dicas**: si generamos el n칰mero suficiente de elementos de la cadena pseudoaleatoria volveremos al inicio. Muchos de los algoritmos disponibles para generar n칰meros aleatorios dependen, entre otros factores, de un **valor inicial llamada semilla** (normalmente obtenida a partir del reloj interno del ordenador): misma semilla, mismo resultado 춺aleatorio췉. Para **fijar la semilla** usaremos `set.seed()`, pas치ndole como argumento una secuencia de n칰meros (todos la misma).

```{r}
set.seed(1234567)
sample(0:1, size = 20, replace = TRUE)
```

```{r}
set.seed(1234567)
sample(0:1, size = 20, replace = TRUE)
```


```{r}
set.seed(1234567)
sample(0:1, size = 20, replace = TRUE)
```

**Siempre la misma tirada si la semilla inicial es la misma** ya que las cadenas pseudoaleatorias que usa el ordenador para simular nuestras tiradas son id칠nticas.














