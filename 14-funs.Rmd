```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```


# Funciones {#funs}

:::: {.blackbox data-latex=""}

Scripts usados:

* [**script13.R**](https://github.com/dadosdelaplace/courses-intro-R/blob/main/scripts/script13.R). Ver en <https://github.com/dadosdelaplace/courses-intro-R/blob/main/scripts/script13.R>

::::


En `R` no solo podemos usar las funciones predeterminadas que vienen ya cargadas, o las de los paquetes que instalamos, como `sum()`  o `mean()`. Adem谩s podemos <mark>**crear nuestras propias funciones**</mark> para automatizar tareas que vayamos a repetir a lo largo de nuestro c贸digo.

<mark>**驴C贸mo crear nuestra propia funci贸n?**</mark> Veamos su esquema b谩sico. Para crear una funci贸n necesitamos

* Un <mark>**nombre**</mark>, por ejemplo `nombre_funcion` (sin espacios ni caracteres extra帽os)
* A dicho nombre le asignamos `<-` la palabra reservada `function()`.
* Dentro de `function()` definimos los <mark>**argumentos de entrada**</mark> que usar谩 la funci贸n.
* Dentro de `{}` incluiremos la 贸rdenes.
* Finalizaremos la funci贸n con `return()` indicando los <mark>**argumentos de salida**</mark>

```{r}
# No ejecutar --> esquema conceptual
nombre_funcion <- function(argumento_1, argumento_2, ... ) {
  
  # C贸digo que queramos ejecutar en la funci贸n
  c贸digo
  
  # Salida
  return(variable_salida)
}
``` 

En el esquema anterior

- <mark>**argumento_1, argumento_2, ...**</mark>: ser谩n los <mark>**argumentos de entrada**</mark>, los argumentos que toma la funci贸n para ejecutar el c贸digo que tiene dentro
- <mark>**c贸digo**</mark>: l铆neas de c贸digo que queramos que ejecute la funci贸n. **IMPORTANTE**: todas las variables que definamos dentro de la funci贸n son variables locales, solo existir谩n dentro de la funci贸n salvo que especifiquemos lo contrario.
- <mark>**`return(variable_salida)`**</mark>: dentro del comando `return()` se introducir谩n los <mark>**argumentos de salida**</mark>, que puede ser un n煤mero, un ` data.frame`, un caracter, una gr谩fica, una matriz...


## Primera funci贸n

Veamos un **ejemplo muy simple de funci贸n** para <mark>**calcular el 谩rea de un rect谩ngulo**</mark>.

<mark>**驴Qu茅 se necesita para calcular el 谩rea?**</mark> Dado que el 谩rea de un rect谩ngulo se calcula como el producto de sus lados, necesitaremos precisamente eso, sus lados: esos ser谩n los argumentos de entrada (`lado_1` y  `lado_2`).  el valor a devolver ser谩 justo su 谩rea, calculada como `lado_1 * lado_2`.

1. Nombre --> `calcular_area`
2. Argumentos --> `lado_1, lado_2`
3. C贸digo --> `area <- lado_1 * lado_2`
4. Salida --> `return(area)`

```{r}
# Definici贸n del nombre de funci贸n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  # Cuerpo de la funci贸n (lo que hace)
  area <- lado_1 * lado_2
  
  # Resultado (lo que devuelve)
  return(area)
  
}
```

Tambi茅n podemos hacer una definici贸n directa, sin almacenar variables por el camino

```{r}
# Definici贸n del nombre de funci贸n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {

  # Resultado que devolvemos
  return(lado_1 * lado_2)
  
}
```

<mark>**驴C贸mo aplicar la funci贸n?**</mark> Haciendo uso del nombre y los valores de los argumentos, usamos `calcular_area()` y le pasamos los dos argumentos de entrada.

```{r}
# Aplicaci贸n de la funci贸n con los par谩metros por defecto
calcular_area(5, 3) # 谩rea de un rect谩ngulo 5 x 3 
calcular_area(1, 5) # 谩rea de un rect谩ngulo 1 x 5
calcular_area(3, 3) # 谩rea de un rect谩ngulo 3 x 3 
```

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funci贸n para calcular el 谩rea de un cuadrado (es decir, solo necesitamos un argumento, un lado, ya que en un cuadrado `lado_1 = lado_2`). Para ello, `R` nos permite definir <mark>**argumentos por defecto en la funci贸n**</mark> (tomar谩n dicho valor salvo que le asignemos otro, como nos ha pasado con el argumento `na.rm` para operar con datos ausentes). 驴**Por qu茅 no asignar `lado_2 = lado_1` por defecto**, para ahorrar l铆neas de c贸digo y tiempo? 

```{r}
# Definici贸n del nombre de funci贸n y argumentos de entrada
# por defecto lado_2 = lado_1
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci贸n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

Ahora, si no indicamos nada, por defecto el segundo lado ser谩 igual al primero (un cuadrado), y si se lo a帽adimos usar谩 ambos.

```{r}
calcular_area(lado_1 = 5) # cuadrado: si no indicamos nada, lado_2 = lado_1
calcular_area(lado_1 = 5, lado_2 = 7) # rect谩ngulo
``` 

&nbsp;

Compliquemos un poco la funci贸n y a帽adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, <mark>**empaquetando la salida en una lista**</mark>.

```{r}
# Definici贸n del nombre de funci贸n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci贸n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

Veamos que nos devuelve ahora

```{r}
salida <- calcular_area(5, 3)
salida
salida["area"]
salida["lado_1"]
salida["lado_2"]
```

Antes nos daba igual el orden de los argumentos pero ahora no, ya que en la salida incluimos `lado_1` y `lado_2`. Es **altamente recomendable** hacer la llamada a la funci贸n indicando expl铆citamente los argumentos `argumento_1 = valor_1` para **mejorar la legibilidad e interpretabilidad de nuestro c贸digo** (recuerda: programa como escribir铆as en castellano).

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

Parece una tonter铆a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de <mark>**consumir conocimiento**</mark> (c贸digo de otros paquetes, elaborado por otros/as), a <mark>**generar conocimiento**</mark>, creando nuestras propias funciones. En este caso no ganaremos el Nobel por nuestro aporte, pero en un futuro... Si la Uni贸n Europea lo gan贸, hay opciones :)

## Variables locales/globales

Un <mark>**aspecto importante sobre el que reflexionar**</mark> con las funciones: 驴qu茅 sucede si nombramos a una variable dentro de una funci贸n que se nos ha olvidado asignar un valor dentro de la misma? Debemos ser cautos al usar funciones en `R`, ya que debido a la <mark>**芦regla lexicogr谩fica禄**</mark>, si una variable no se define dentro de la funci贸n, `R` buscar谩 dicha variable en el entorno de variables. 

Construyamos una funci贸n de ejemplo que no toma ning煤n argumento de entrada: solo imprime el valor de `x`. Como dentro de la funci贸n `x` no est谩 definida, usar谩 el valor definido fuera de la funci贸n.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada per se, solo realiza la acci贸n de imprimir en consola
}
funcion_ejemplo()
```

Si una **variable ya est谩 definida fuera de la funci贸n (entorno global)**, y adem谩s es usada dentro de la misma cambiando su valor, el valor de dicha variable solo cambia dentro de la funci贸n pero no en el entorno global.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
funcion_ejemplo() # lo que vale dentro
print(x) # lo que vale fuera
```

Si queremos que **adem谩s de cambiar localmente lo haga globalmente** deberemos usar la **doble asignaci贸n** (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  x <- 3 # no cambia globalmente, solo localmente
  y <<- 0 # cambia globalmente
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```


##  Ejercicios

(haz click en las flechas para ver soluciones)


<details>
  <summary><strong>Ejercicio 1</strong>: modifica el c贸digo inferior para definir una funci贸n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.
  

</summary>
  
- Soluci贸n:

```{r}
# Definimos funci贸n
funcion_suma <- function(x, y) {
  
  # Sumamos
  suma <- x + y
  
  # Devolvemos la salida
  return(suma)
}

# Aplicamos la funci贸n
funcion_suma(3, 7)
```

</details>

```{r eval = FALSE}
# Definimos funci贸n
nombre <- function(x, y) {
  
  # Sumamos
  suma <- # c贸digo a ejecutar
  
  # 驴Qu茅 devolvemos?
  return()
}

# Aplicamos la funci贸n
suma(3, 7)
```

&nbsp;

<details>
  <summary><strong>Ejercicio 2</strong>: modifica el c贸digo inferior para definir una funci贸n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto.
  

</summary>
  
- Soluci贸n:

```{r}
# Definimos funci贸n
funcion_producto <- function(x, y) {
  
  # Multiplicamos
  producto <- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la funci贸n
funcion_producto(3, -7)
```

</details>

```{r eval = FALSE}
# Definimos funci贸n
nombre <- function(x, y) {
  
  # Multiplicamos
  producto <- # c贸digo de la multiplicaci贸n
  
  # 驴Qu茅 devolvemos?
  return()
}

# Aplicamos la funci贸n
producto(3, -7)
```

&nbsp;

<details>
  <summary><strong>Ejercicio 3</strong>: modifica el c贸digo inferior para definir una funci贸n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado (es decir, por defecto un solo argumento, y el resultado sea el n煤mero por s铆 mismo)
  

</summary>
  
- Soluci贸n:

```{r}
# Definimos funci贸n
funcion_producto <- function(x, y = x) {
  
  # Multiplicamos
  producto <- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la funci贸n
funcion_producto(3) # por defecto x = 3, y = 3
funcion_producto(3, -7)
```

</details>

```{r eval = FALSE}
# Definimos funci贸n
nombre <- function(x, y) {
  
  # Multiplicamos
  producto <- # c贸digo de la multiplicaci贸n
  
  # 驴Qu茅 devolvemos?
  return()
}

# Aplicamos la funci贸n solo con un argumento
producto(3)

# Aplicamos la funci贸n con dos argumentos
producto(3, -7)
```

&nbsp;

<details>
  <summary><strong>Ejercicio 4</strong>: define una funci贸n llamada `igualdad_nombres` que, dados dos nombres `persona_1` e `persona_2`, nos diga si son iguales o no. Hazlo considerando importantes las may煤sculas, y sin que importen las may煤sculas. Recuerda que con `toupper()` podemos pasar todo un texto a may煤scula. </summary>
  
- Soluci贸n:

```{r}
# Distinguiendo may煤sculas
igualdad_nombres <- function(persona_1, persona_2) {
  
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc铆a")

# Sin importar may煤sculas
igualdad_nombres <- function(persona_1, persona_2) {
  
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc铆a")
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 5</strong>: define una funci贸n llamada `pares` que, dados dos n煤meros `x` e `y`, nos diga si la suma de ambos es par o no.
  
Recuerda que con `%%` podemos obtener el resto de un n煤mero al dividir entre 2.

```{r}
2 %% 2 # par, resto 0
3 %% 2 # impar, resto 1
```
</summary>
  
- Soluci贸n:

```{r}
# Definimos funci贸n
pares <- function(x, y) {
  
  # Sumamos
  suma <- x + y
  
  # Comprobamos si es par
  par <- suma %% 2 == 0
  
  # Devolvemos la salida
  return(par)
}

# Aplicamos la funci贸n
pares(1, 3) # suma 4 (par)
pares(2, 7) # suma 9 (impar)
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 6</strong>: define una funci贸n llamada `pasar_a_celsius` que, dada una temperatura $x$ en Fahrenheit, la convierta a grados Celsius ($潞C = (潞F - 32) * \frac{5}{9}$). Aplica la funci贸n a la columna `Temp` del conjunto `airquality`, e incorp贸rala al fichero en una nueva columna `Temp_Celsius`.
</summary>
  
- Soluci贸n:

```{r}
# Definimos funci贸n
pasar_a_celsius <- function(x) {
  
  # Temperatura en Celsius
  x_celsius <- (x - 32) * (5 / 9)
  
  # Devolvemos la salida
  return(x_celsius)
}

# Aplicamos la funci贸n
pasar_a_celsius(0)
pasar_a_celsius(80)

# Aplicamos
data.frame(airquality,
           "Temp_Celsius" = pasar_a_celsius(airquality$Temp))
```

</details>




