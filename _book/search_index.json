[["index.html", "Aprendiendo R sin morir en el intento Prefacio", " Aprendiendo R sin morir en el intento Javier √Ålvarez Li√©bana √öltima actualizaci√≥n: 08-09-2021 Prefacio Este manual ha sido dise√±ado para la asignatura de Descripci√≥n y Exploraci√≥n de Datos del grado de Estad√≠stica Aplicada (UCM, curso acad√©mico 2021-2022), y est√° elaborado por Javier √Ålvarez Li√©bana. Dicho manual ha sido elaborado a su vez en R con {bookdown}. Puedes ver un resumen de las funcionalidades algunos paquetes documentados por el equipo de R Studio en sus esquemas resumen. El c√≥digo de dicho manual se encuentra en GitHub (https://github.com/dadosdelaplace/cursoR_intro_2021_2022). Para elaborar informes o libros con una estructura similar, de forma nativa en R, el paquete {bookdown} puede ser instalado desde la plataforma CRAN o desde su versi√≥n en desarrollo actualizada en Github: install.packages(&quot;bookdown&quot;) # o desde su versi√≥n en desarrollo actualizada # devtools::install_github(&quot;rstudio/bookdown&quot;) "],["prop√≥sito.html", "Prop√≥sito", " Prop√≥sito El objetivo de este tutorial es introducir a la programaci√≥n y an√°lisis estad√≠stico en R a toda aquella persona que nunca se haya iniciado en √©l, sin necesitar conocimientos previos de programaci√≥n (aunque siempre ayuda, obviamente). Con este manual no se pretende que adquieras un vasto y experto conocimiento de R, pero si lo suficiente como para lograr 5 objetivos: No tener miedo a programar. Ser capaces de abordar desde la programaci√≥n (ya sea en R o en otro lenguaje) peque√±os problemas, con el fin de saber conceptualizarlos. Entender los usos y costumbres del lenguaje R Darte pinceladas de sus posibilidades que te sirvan de trampol√≠n para ir investigando por tu cuenta en el campo en el que lo vayas a aplicar. Algunos trucos sencillos para que el trabajo sea m√°s r√°pido, tanto en tiempo de escritura como de ejecuci√≥n. Hacer enf√°sis en la importancia de la visualizaci√≥n de datos en estad√≠stica. "],["requisitos.html", "Requisitos", " Requisitos Conexi√≥n a internet: se necesitar√° tener una conexi√≥n a internet disponible para la descarga de algunos datos y paquetes. Instalar R (ver 1). R ser√° nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortograf√≠a para poder ¬´comunicarnos¬ª con el ordenador. https://cran.r-project.org/ Instalar RStudio (ver 1.1). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programaci√≥n podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea m√°s c√≥modo. Nosotros trabajaremos con RStudio. Todo lo necesario para seguir este curso es de descarga gratuita: viva el software libre, abajo Excel. "],["emojis.html", "Emojis", " Emojis Info: siempre que veas el icono de la bombilla encontrar√°s consejos o tips para ampliar y facilitar tu programaci√≥n. Adem√°s en cada cajita de c√≥digo, si pasas el rat√≥n, encontrar√°s un bot√≥n en la esquina superior derecha de la caja para copiar el c√≥digo directamente a tu consola. üìù Ejercicios: siempre que veas el icono de un documento escrito encontrar√°s ejercicios con soluciones para que vayas afianzando conceptos (una de las soluciones, normalmente siempre habr√° muchas formas distintas de realizar la misma tarea, prioriza la m√°s sencilla y limpia). üìÑüìÑ Copiar c√≥digo: siempre que veas el icono de dos documentos en las cajas de c√≥digo (aparecen al pasar el rat√≥n), podr√°s hacer click para copiar directamente el c√≥digo que haya dentro. üìö Glosario: siempre que veas la pila de libros encontrar√°s una secci√≥n de glosario con algunos t√©rminos estad√≠sticos y conceptos b√°sicos. "],["sobre-el-autor.html", "Sobre el autor", " Sobre el autor Esto de presentarse a s√≠ mismo es siempre un poco raro pero vamos a intentarlo. Mi nombre es Javier √Ålvarez Li√©bana, soy matem√°tico, nacido en 1989 en Carabanchel (Madrid), pasando por Bologna (Italia). Tras terminar licenciatura y M√°ster en Ingenier√≠a Matem√°tica, recib√≠ en julio de 2018 el t√≠tulo de Doctor en Estad√≠stica (por la Universidad de Granada, con dos estancias en Universit√© Pierre et Marie Curie) Adem√°s de investigador (con plaza y acreditaci√≥n de Ayudante Doctor en la Facultad de Estudios Estad√≠sticos de la Universidad Complutense de Madrid, tras ocupar dicha plaza en la Universidad de Oviedo), soy docente en dicha facultad y ando intentando eso de la divulgaci√≥n en estad√≠stica y dataviz (visualizaci√≥n de datos) en redes sociales üê¶ Twitter üì∏ Instagram "],["licencia.html", "Licencia", " Licencia Este documento es publicado bajo licencia p√∫blica general GNU, una licencia libre de copyleft que garantiza a los usuarios finales (personas, organizaciones, compa√±√≠as) la libertad de usar, estudiar, compartir (copiar) y modificar el software, citando adecuadamente al autor del mismo. "],["instalacionR.html", "Cap√≠tulo 1 Instalaci√≥n", " Cap√≠tulo 1 Instalaci√≥n Vamos a necesitar solo 3 pasos (y conexi√≥n a internet). Paso 1: entra en la web https://cran.r-project.org/ y en la pantalla de inicio selecciona la instalaci√≥n acorde a tu sistema operativo (ver imagen 1.1) Imagen/gr√°fica 1.1: Pantalla inicial de la plataforma CRAN de R. Paso 2: para sistemas operativos Mac basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado (ver imagen 1.2) Imagen/gr√°fica 1.2: Pantalla de instalaci√≥n de R en Mac OS. Para sistemas operativos Windows, debemos clickar en install R for the first time (ver imagen 1.3) y en la siguiente pantalla hacer click en Download R for Windows (ver imagen 1.4). Una vez descargado, abrirlo como cualquier archivo. Imagen/gr√°fica 1.3: Pantalla previa de instalaci√≥n de R en Windows. Imagen/gr√°fica 1.4: Pantalla final de instalaci√≥n de R en Windows. Paso 3: tras su instalaci√≥n tendr√°s en tu escritorio (Windows) o en tu Launchpad (Mac Os) un ejecutable de R para abrir. En Windows puede que tengas dos ejecutables i386 y x64 (como todo programa en Windows est√° la versi√≥n de 32 y de 64 bits, haz click preferiblemente - si lo tienes - en el de x64). Te saldr√° algo parecido a lo que observas en la imagen 1.5. Imagen/gr√°fica 1.5: Primera pantalla al abrir el ejecutable de R. Para comprobar que est√° correctamente instalado, prueba a escribir en la consola el siguiente c√≥digo (recuerda: los c√≥digos puedes copiarlos directamente de la cajita en la que est√° haciendo click en el bot√≥n de la esquina superior derecha) a &lt;- 1 b &lt;- 2 a + b ## [1] 3 Imagen/gr√°fica 1.6: Primera suma en la consola de R. ¬°Enhorabuena! Si te ha devuelto [1] 3, ya has hecho m√°s de lo que parece: has definido dos variables a y b, has asignado un valor num√©rico a cada variable y las hemos usado. Ya sabemos usar R como calculadora. Asignaci√≥n: como habr√°s advertido, en R usaremos &lt;- para asignar valores en lugar de =, como una flecha. L√≠nea de consola: como habr√°s advertido, en R usaremos &lt;- para asignar valores en lugar de =, como una flecha. Bonita esta interfaz no es, as√≠ que la cerraremos y no la abriremos m√°s. Tenemos nuestro lenguaje instalado, vamos a instalar nuestro Word para poder programar de forma c√≥moda. "],["instalacionRStudio.html", "1.1 Instalaci√≥n de RStudio", " 1.1 Instalaci√≥n de RStudio Para instalar RStudio deberemos ir a la web https://www.rstudio.com/products/rstudio/download/#download y seleccionar el ejecutable que te aperezca acorde a tu sistema operativo (ver imagen 1.7). Tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que termine la instalaci√≥n. Imagen/gr√°fica 1.7: Descargar el ejecutable de RStudio para su posterior instalaci√≥n. Tras instalar tendremos en el escritorio o Launchpad un ejecutable de RStudio que abriremos. Se nos aparecer√° una pantalla similar a esta: Imagen/gr√°fica 1.8: Primer recibimiento de nuestro mejor amigo RStudio. Consola: es el nombre para llamar a esa ventana grande que te ocupa la mayor parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes en ella (es el equivalente a la consola de R que hemos abierto al principio). a &lt;- 1 b &lt;- 2 a + b Imagen/gr√°fica 1.9: Lanzando a consola nuestras primeras √≥rdenes en RStudio. La consola ser√° donde ejecutaremos √≥rdenes y mostraremos resultados Environment (entorno): la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha se denomina environment o entorno de variables, donde como puedes ver, tras ejecutar el peque√±o c√≥digo en la consola, nos informa de que tenemos dos variables num√©ricas y su valor asignado. Nos mostrar√° las variables que tenemos definidas, el tipo y su valor. Imagen/gr√°fica 1.10: Environment de variables. Panel multiusos: la ventana que tenemos en la parte inferior derecha no servir√° para buscar ayuda de comandos y √≥rdenes, adem√°s de para visualizar gr√°ficos. Lo veremos cuando sea necesario. Imagen/gr√°fica 1.11: Panel multiusos. WTF ¬øY D√ìNDE PROGRAMAMOS? ¬øEst√°s emocionado/a? Vamos a abrir nuestro primer script (script = documento en el que programamos, nuestro .doc, pero aqu√≠ ser√° un archivo .R). Haz click en el men√∫ superior en File &lt;&lt; New File &lt;&lt; R Script como se muestra en la imagen 1.12 Imagen/gr√°fica 1.12: Abriendo nuestro primer script de R. Tras abrirlo tendremos una cuarta ventana: esta ser√° la ventana de nuestros c√≥digos, la ventana m√°s importante ya que es donde escribiremos lo que queremos ejecutar. Escribe el c√≥digo de arriba en ese script y guarda el archivo haciendo click en el bot√≥n Save current document Imagen/gr√°fica 1.13: Escribiendo y guardando nuestro primer script. Ese c√≥digo no se ejecuta salvo que se lo digamos. Tenemos dos opciones para ello: o copiamos el trozo de c√≥digo que queramos y lo pegamos en la consola (como hemos hecho al principio), o activamos el cuadrado Source on save a la derecha del bot√≥n de guardar y volvemos a hacer click en el bot√≥n de guardar: siempre que esa opci√≥n est√© activada, al guardar no solo es nos guarda el archivo .R sino que adem√°s se ejecuta solo y nos devuelve los resultados por consola. Listo, tienes instalado (casi) todo correctamente. "],["instalacionpaquetes.html", "1.2 Instalaci√≥n de paquetes", " 1.2 Instalaci√≥n de paquetes El lenguaje R tiene 3 ventajas principales: Es un lenguaje creado por y para estad√≠sticos/as, por lo que est√° pensado para optimizar al m√°ximo los recursos, y poder hacer un an√°lisis estad√≠stico de calidad Es software libre (como C, C++, Python, Fortran, y otros tantos lenguajes). El software libre no solo tiene una ventaja evidente (es gratis, ok) en su instalaci√≥n sino que permite acceder al c√≥digo en el que est√°n programados los comandos y permite hacer uso de trozos de c√≥digo de otras personas. Es un lenguaje modular: en la instalaci√≥n no se instalan todas las funcionalidades sino que instala un m√≠nimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de c√≥digo hechos por otras personas llamados paquetes, que podemos ir instalando a nuestro gusto seg√∫n los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante, con m√°s de 17 000 paquetes: ¬°hay m√°s de 17 000 trozos de c√≥digo validados por la comunidad y la plataforma, de forma gratuita! Imagen/gr√°fica 1.14: Paquetes disponibles en R. Esto nos ahorra much√≠simo tiempo ya el 90% de lo que querramos hacer ya lo habr√° querido hacer otra persona y podemos usar o adaptar su c√≥digo para no empezar de cero. Vamos a instalar un paquete gr√°fico ({ggplot2}) que necesitaremos. Para ello, escribe en tu consola el siguiente c√≥digo y pulsa enter. install.packages(&quot;ggplot2&quot;) Dicha orden (puede tardar un poco la primera vez, depende de tu conexi√≥n a internet) lo que har√° ser√° acceder a la web de R, bajarse a tu ordenador los trozos de c√≥digo incluidos en el paquete llamado {ggplot2} (para realizar gr√°ficas), y dejarlos para siempre en √©l: la instalaci√≥n de paquetes SOLO ES NECESARIO la primera vez que se usa dicho paquete en la vida del ordenador, no hace falta hacerlo cada vez que lo usas. Una vez que tenemos los trozos de c√≥digo (el paquete) en nuestro ordenador, en cada sesi√≥n de R que abramos (cada vez que cierres y abras RStudio) deberemos (si queremos) llamar a ese paquete que tenemos instalado, escribiendo el siguiente comando en consola library(ggplot2) Welcome to software libre "],["consejos-y-tips.html", "1.3 Consejos y tips", " 1.3 Consejos y tips ¬øC√≥mo saber cuando la orden lanzada en consola ha terminado? A veces R y RStudio son tan silenciosos que no sabemos si ha acabado la orden que acabamos de lanzar en la consola o no. Truco: siempre que veas este s√≠mbolo &gt; como √∫ltima l√≠nea en la consola significa que est√° listo para que le escribamos otra orden (es la forma cari√±osa de decirte que ya ha acabado, ver imagen 1.15) Imagen/gr√°fica 1.15: Ejemplo de que la orden lanzada ha acabado. ¬øC√≥mo prevenir la fatiga visual programando? Estar delante de una pantalla de ordenador, con la vista muy fija mientras se programa, puede que acabes teniendo cierta fatiga visual en el trabajo. Truco: te aconsejo que cambies en tu RStudio la tonalidad del fondo de tu programa, en tonos oscuros y no blancos (¬øte has fijado que mis capturas tienen un azul cobalto oscuro de fondo mientras el tuyo es un blanco nuclear? Echa un vistazo las imagenes 1.16 y 1.17) Imagen/gr√°fica 1.16: Men√∫ de opciones de nuestro editor Imagen/gr√°fica 1.17: Personalizar el color de fondo de nuestro editor, la letra y el tama√±o de fuente Entender los paquetes Haciendo una met√°fora con la colecci√≥n de libros que tengas en casa: con la instalaci√≥n hemos comprado el libro y lo tenemos en nuestra estanter√≠a (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estanter√≠a, cuales queremos llevarnos de viaje (en cada maleta que hagamos). Los paquetes usados los ver√°s denotados como {nombre_paquete} a lo largo del manual. "],["primeros-pasos.html", "Cap√≠tulo 2 Primeros pasos", " Cap√≠tulo 2 Primeros pasos ¬øEmpezamos? Veamos antes un poco de historia sobre nuestro deidad. All√° por 1975, los laboratorios Bell (los que inventaron la radio moderna tal y como la conocemos), necesitaban una alternativa a los lenguajes m√°s ¬´rudos¬ª y antiguos como C++ o Fortran, lenguajes r√°pidos en la ejecuci√≥n pero complejos en su uso, con una gran curva de aprendizaje y con muy poca capacidad en la visualizaci√≥n de datos que se empezaba a necesitar. As√≠ que en 1976 sacaron la primera versi√≥n del lenguaje conocido S (hasta entonces estaba de moda lo de llamar a los lenguajes con una sola inicial). En 1980 se empez√≥ a distribuir la primera versi√≥n p√∫blica de S, m√°s all√° de los laboratorios Bell, y en 1988 se a√±adieron bastantes funcionalidades nuevas como poder aplicar funciones a otras funciones (los famosos apply() que ya veremos). A√±os m√°s tarde, en 1991, dicho lenguaje se simplific√≥, reescribiendo muchas subrutinas de otros lenguajes m√°s primitivos, para tener una versi√≥n muy parecida al actual R, permitiendo el usod de operadores, data.frames (que veremos) y otro tipo de objetos, sencillos en la programaci√≥n pero muy versatiles. Sin embargo, salvo uso docente, S ten√≠a licencia as√≠ que en 1992 Ross Ihaka y Robert Gentleman se lanzaron a crear una versi√≥n de S libre y gratuita, un trabajo de casi 8 a√±os hasta que en el a√±o 2000, ambos investigadores de la Universidad de Auckland en Nueva Zelanda lanzaron la primera versi√≥n estable del lenguaje. Tras dicho lanzamiento, se cre√≥ un equipo de expertos en estad√≠stica computacional (el conocido como R Development Core Team) que es el que se encarga de mantener toda la aerquitectura de R y los que se encargar de actualizar y mejorar el paquete {base}, una librer√≠a motor sobre la que se construye el resto de funciones. "],["excel-no-es-tu-amigo.html", "2.1 Excel no es tu amigo", " 2.1 Excel no es tu amigo R es un lenguaje de programaci√≥n, de alto nivel para el usuario y modular. Los lenguajes de alto nivel como R, Python (curso interactivo de Python en https://checkio.org/) o Matlab, facilitan la programaci√≥n al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una menor curva de aprendizaje aunque suelen ser m√°s lentos en su ejecuci√≥n en comparaci√≥n con lenguajes de bajo nivel (C, C++ o Fortran), lenguajes muy r√°pidos en su ejecuci√≥n pero cuya programaci√≥n requiere un mayor tiempo y formaci√≥n, teniendo que adem√°s estar pendiente del tipo de variables, espacio en memoria, etc. Por su arquitectura, R es un lenguaje que puede ser usado para un prop√≥sito general pero que est√° especialmente dise√±ado para el an√°lisis estad√≠stico de datos. Su modularidad nos da la ventaja de que podemos instalar las funcionalidades que vayamos necesitando de forma progresiva. ¬øPor qu√© no es recomendable usar Excel? Software de pago: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. A nivel individual, todos hemos tenido una versi√≥n que no hemos pagado, pero dicha evasi√≥n no se la puede permitir una empresa o administraci√≥n, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que no ser√≠a necesario si los investigadores y trabajadores tuvieran formaci√≥n (remunerada) en otras herramientas de software libre. Software cerrado: no solo es de pago sino que es cerrado, as√≠ que solo podemos hacer lo que Excel ha cre√≠do que interesante que podamos hacer. Incluso con la programaci√≥n de MACROS, las funcionalidades de Excel siguen siendo mucho m√°s limitadas ya que viene ¬´programadas¬ª de antemano Alto consumo de memoria: dicha programaci√≥n predeterminada hace que Excel ocupe much√≠simo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas a la vez en tu ordenador). No es universal: no solo es de pago sino que adem√°s, dependiendo de la versi√≥n que tengas de Excel, tendr√° un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo .xls abierto por un Excel moderno puede provocar errores en la carga. ¬°ES SOLO UNA HOJA DE C√ÅLCULO!: el propio Microsoft desaconseja el uso de Excel para el an√°lisis de grandes vol√∫menes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de c√°lculo: llevar las cuentas de tu familia, de tu peque√±o negocio, una declaraci√≥n de la Renta sencilla, planificar viajes, etc. Pero el programa NO EST√Å DISE√ëADO para ser una base de datos ni para an√°lisis detallado, y muchos menos pensado para generar un entorno flexible para el an√°lisis estad√≠stico y la visualizaci√≥n de datos. ¬øPuedes ser el mejor partiendo un filete con una cuchara? Seguramente puedas (en Excel puedes hasta programar con macros), y si siempre lo hiciste as√≠, acabar√°s normaliz√°ndolo, pero seguir√°s siendo una persona comiendo filete con cuchara. ¬øQu√© sucede si usamos la herramienta equivocada? Tres ejemplos: Problemas para codificar fechas: en 2016 se public√≥ una revisi√≥n de art√≠culos en gen√©tica, descubriendo que 1 de cada 5 art√≠culos conten√≠an errores debido a una mala codificaci√≥n de las fechas, conviertiendo por ejemplo los genes Septin-2 (conocido como SEPT2) en fechas, y al rev√©s (Ziemann, Eren, and El-Osta 2016). Imagen/gr√°fica 2.1: Excel en una noche loca. Problemas de memoria: un Excel permite por defecto una cantidad m√°xima de filas. Aunque dicha cantidad se puede ampliar, sigue siendo finita, por lo que cuando superas el umbral de filas, al a√±adir filas Excel te borra registros sin avisarte de que lo est√° haciendo. Esto es lo que sucedi√≥ con los registros de casos covid en Reino Unido. Imagen/gr√°fica 2.2: Cuando Excel dice basta. Problemas para codificar edades: una variable de tipo fecha, aunque nosotros la veamos con letras, en realidad es una variable num√©rica que representa los d√≠as que han pasado desde una fecha origen. En funci√≥n de las distintas versiones de Excel, dicha fecha origen cambia. Adem√°s, si se codifica mal la fecha en formato dd-mm-YY, dicho formato cuando se exporta a otro excel en texto, no permite distinguir a un nacido en 1918 y a un nacido en 2018, as√≠ que podemos estar confundiendo personas de 103 a√±os con ni√±os de 3 a√±os (y es lo que sucedi√≥ en Espa√±a, observando unas tasas de mortalidad en ni√±os muy peque√±os equivalentes a personas mayores). Imagen/gr√°fica 2.3: Los centenarios con biber√≥n. Bibliograf√≠a "],["primeros-pasos-calculadora.html", "2.2 Primeros pasos: calculadora", " 2.2 Primeros pasos: calculadora ¬øTe acuerdas de lo que era la consola? Vamos a trabajar de momento en esa ventana que tienes en la ventana inferior. Imagen/gr√°fica 2.4: Lanzando a consola nuestras primeras √≥rdenes en RStudio. Lo que ya hemos descubierto en los pasos de la instalaci√≥n (ver imagen 2.4) es que la consola de R tiene una funci√≥n muy b√°sica y evidente: nos sirve de calculadora. Un ejemplo muy simple: si escribimos 3 en la consola y pulsamos ENTER, la consola nos mostrar√° el resultado de la suma 1 + 2 ## [1] 3 ¬øPero cu√°l es la diferencia entre una calculadora y un lenguaje de programaci√≥n? Imagina que dicha suma 3 la quisi√©ramos utilizar para un segundo c√°lculo: ¬øy si en lugar de lanzarlo a la consola sin m√°s lo almacenamos en alguna variable? Como hemos visto en la instalaci√≥n de RStudio, para asignar variables lo haremos con la orden x &lt;- 1 + 2: una variable de nombre x va a tener asignada &lt;- lo que valga la suma 1 + 2 x &lt;- 1 + 2 Como puedes comprobar, en tu parte superior derecha (nuestro entorno de variables), podr√°s ver como una nueva variable x es ahora visualizada, con su valor asignado (no se mostrar√° en consola salvo que escribas 3 en ella: R asume que no quer√≠as visualizarla en consola sino solo guardarla). Imagen/gr√°fica 2.5: Environment. Dicha variable x adem√°s podemos reciclarla para definir una variable y, rest√°ndole una constante. De la misma manera que hemos hecho restas, sumas y multiplicaciones, R tiene todas las operaciones cl√°sicas que podr√≠as tener en una calculadora. Prueba a ejecutar en la consola las √≥rdenes x^2, sqrt(x) o abs(y): R calcular√° las operaciones elevar al cuadrado, ra√≠z cuadrada y valor absoluto de la variable que tengan entre par√©ntesis x^2 ## [1] 9 sqrt(x) ## [1] 1.732051 y &lt;- x - 5 abs(y) ## [1] 2 "],["tipos_errores.html", "2.3 Tipos de errores", " 2.3 Tipos de errores Durante tu aprendizaje en R va a ser muy habitual que las cosas no salgan a la primera, apareciendo en consola mensajes en un color rojo. Un miedo muy habitual cuando se empieza a programar es pensar que si haces algo mal o aparece alg√∫n mensaje de error, el ordenador puede explotar en cualquier momento. A programar se aprende programando, as√≠ que haz las pruebas que quieres, lo peor que puede pasar es que necesites cerrar sesi√≥n en R Studio y abrirlo de nuevo. Dado que el 99.99999% de veces tu c√≥digo tendr√° errores que deber√°s ir solventando, no est√° de m√°s conocer los tipos de mensajes que R puede sacarte por consola: Errores: los mensajes de error ir√°n precedidos de la frase ¬´Error in‚Ä¶¬ª, d√°ndote a veces incluso el tipo de error y la l√≠nea de c√≥digo en la que se ha producido. Veamos un ejemplo intentando sumar un n√∫mero a una cadena de texto. &quot;a&quot; + 1 ## Error in &quot;a&quot; + 1: argumento no-num√©rico para operador binario Los errores son aquellos fallos que seguramente impidan la ejecuci√≥n del c√≥digo. Un error muy habitual es intentar acceder a alguna funci√≥n de alg√∫n paquete que, o bien no tenemos instalado, o bien no hemos llamado haciendo uso del library(): est√°s intentando leerte un libro de tu biblioteca pero ni siquiera has ido a la tienda a ¬´comprarlo¬ª. Warnings: los mensajes de warning ir√°n precedidos de la frase ¬´Warning:‚Ä¶¬ª, y son los fallos m√°s delicados ya que son posibles errores o incoherencias que R detecta en tu c√≥digo pero que no van a hacer que tu c√≥digo deje de ejecutarse, aunque probablemente no lo haga como a ti te gustar√≠a. Un ejemplo es cuando tratamos de hacer la raiz cuadrada de un n√∫mero negativo. sqrt(-1) ## Warning in sqrt(-1): Se han producido NaNs ## [1] NaN ¬øHa ejecutado la orden? S√≠, pero te **advierte de que el resultado de la operaci√≥n es un NaN, un valor que no existe (al menos dentro de los n√∫meros reales), un Not A Number (ver Secci√≥n 3.6). Mensajes de control: los mensajes de control ser√°n aquellos que aparecer√°n por consola sin empezar por ¬´Error in‚Ä¶¬ª ni ¬´Warning:‚Ä¶¬ª. Dichos mensajes, que puedes incluir t√∫ mismo en tu c√≥digo con funciones como cat() para monitorizar la ejecuci√≥n de c√≥digos largos, no son errores ni problemas, son simplemente informaci√≥n que R considera √∫til aportarte. "],["consejos-y-tips-1.html", "2.4 Consejos y tips", " 2.4 Consejos y tips Argumentos de una funci√≥n Las √≥rdenes sqrt(x) y abs(y) se llaman funciones, y la variable que tienen entre par√©ntesis se llama argumento de la funci√≥n: una variable que toma de entrada la funci√≥n y con la que opera internamente. Panel de ayuda Si escribes en la consola ? nombre_funcion (por ejemplo, escribe en la consola ? sqrt), en el panel inferior derecho te aparecer√° una documentaci√≥n de ayuda de la funci√≥n para saber que argumentos necesita, como puedes usar la funci√≥n, qu√© es lo que te devuelve, ejemplos de uso, etc. ? sqrt Imagen/gr√°fica 2.6: Panel de ayuda. "],["ejercicios.html", "2.5 üìù Ejercicios", " 2.5 üìù Ejercicios üìùEjercicio 1: calcula en consola la suma de 3 m√°s 4, y todo ello multiplicado por 10, y as√≠gnalo a una variable x. Soluci√≥n: x &lt;- (3 + 4) * 10 üìùEjercicio 2: usando la variable x ya definida, calcula x - 5 y gu√°rdalo en una nueva variable y. Soluci√≥n: y &lt;- x - 5 y ## [1] 65 üìùEjercicio 3: usando las variables x e y ya definidas, calcula la ra√≠z cuadrada del m√°ximo entre ambas, y gu√°rdalo en una nueva variable z. Soluci√≥n: z &lt;- sqrt(max(x, y)) # No hace falta gastar una l√≠nea por cada orden (cada asignaci√≥n que hagas es una variable guardada que consume memoria en tu ordenador) z ## [1] 8.3666 "],["tipos-de-datos-i-vectores.html", "Cap√≠tulo 3 Tipos de datos I: vectores", " Cap√≠tulo 3 Tipos de datos I: vectores Bien, ya controlamos la calculadora. Vamos a ir m√°s all√°: ¬øy si en lugar de tener un solo n√∫mero tenemos un CONJUNTO de elementos? En este cap√≠tulo vamos a ver un cl√°sico de cualquier lenguaje de programaci√≥n: los vectores o arrays. "],["vectores-num√©ricos.html", "3.1 Vectores num√©ricos", " 3.1 Vectores num√©ricos Un conjunto de elementos del mismo tipo se llama vector (en este caso de n√∫meros), y de hecho un n√∫mero individual (por ejemplo, 1) es en realidad un vector de longitud uno (un solo elemento). La forma m√°s sencilla de crear un vector en R es con el comando c() (de concatenar elementos), y basta con introducir sus elementos entre par√©ntesis, y separados por comas. Vamos a crear el vector con los tres primeros n√∫meros naturales pares (el 0 no es natural, no seas b√°rbaro/a). z &lt;- c(2, 4, 6) z ## [1] 2 4 6 Como ves ahora en el environment tenemos una colecci√≥n de elementos, tres en concreto, guardados en una misma variable. La longitud de un vector se puede calcular con el comando length(). length(z) ## [1] 3 Adem√°s podemos concatenar a su vez vectores: vamos a concatenar el vector z consigo mismo, y a√±adi√©ndole al final un 8. c(z, z, 8) ## [1] 2 4 6 2 4 6 8 La √∫ltima concatenaci√≥n lo que nos ha dado son los tres primeros pares, despu√©s de nuevo los tres primeros pares, y por √∫ltimo un 8. 3.1.1 Secuencias con un patr√≥n Muchas veces nos gustar√≠a crear vectores de una forma mucho m√°s r√°pida, por ejemplo, para tener un vector de √≠ndices que queramos recorrer. Supongamos que queremos el vector de los primeros 21 n√∫meros naturales. Si construy√©ramos el vector como antes, tendr√≠amos ejecutar el comando c(1, 2, 3, 4, 5, ...) hasta el n√∫mero 21. ¬øUn poco largo, no? El comando seq() nos permite crear una secuencia desde un elemento inicial hasta un elemento final, avanzando de uno en uno. seq(1, 21) # secuencia desde 1 hasta 21 de uno en uno ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Es importante que no perdamos el foco de que programar es similar a escribir en un idioma, por lo que si hay algo que se puede decir de una forma m√°s limpia y que se entienda mejor, ¬øpor qu√© no usarlo? Siempre que queramos definir secuencias entre dos n√∫meros naturales (por ejemplo, entre 1 y un valor n), cuya distancia entre elementos consecutivos sea uno, el comando 1:n nos devuelve lo mismo que la orden seq(1, n). Adem√°s, si el elemento inicial es mayor que el final, R entender√° solo que la secuencia la queremo decreciente. n &lt;- 21 1:n # secuencia desde 1 hasta n (21) de uno en uno ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 17:1 # secuencia decreciente de 17 a 1 ## [1] 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Tambi√©n podemos definir otro tipo de distancia entre dos elementos consecutivos (conocido como paso de discretizaci√≥n), por ejemplo de 0.5 en 0.5, o bien definir una secuencia entre un valor inicial y un valor final con un n√∫mero de elementos fijo (y que sea R el que decida la distancia entre elementos consecutivos). seq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5 ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 ## [16] 8.5 9.0 9.5 10.0 seq(1, 50, l = 11) # secuencia desde 1 a 100 de longitud 11 ## [1] 1.0 5.9 10.8 15.7 20.6 25.5 30.4 35.3 40.2 45.1 50.0 Otro atajo que podemos usar para definir secuencias de n√∫meros con un patr√≥n es definir vectores repetidos, por ejemplo un vector lleno de 0, para luego ser rellenado (pero ya tenerlo definido). La funci√≥n rep() nos permite repetir un elemento un n√∫mero fijado de veces. rep(0, 7) # vector de 7 ceros ## [1] 0 0 0 0 0 0 0 No solo podemos repetir un n√∫mero sino que podemos repetir vectores enteros. rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces ## [1] 0 1 2 0 1 2 0 1 2 0 1 2 Esa repetici√≥n adem√°s podemos definirla tambi√©n de forma intercalada: en lugar de repetir c(0, 1, 2) cuatro veces seguidas, queremos cuatro 0, despu√©s cuatro 1, y despu√©s cuatro 2. rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2 ## [1] 0 0 0 0 1 1 1 1 2 2 2 2 "],["operaciones-aritm√©ticas-con-vectores-num√©ricos.html", "3.2 Operaciones aritm√©ticas con vectores num√©ricos", " 3.2 Operaciones aritm√©ticas con vectores num√©ricos Hemos dicho que un n√∫mero es un vector de longitud 1, as√≠ que toda operaci√≥n aritm√©tica que podamos hacer con un n√∫mero la vamos a poder a hacer con un vector de n√∫meros, de forma que si hacemos por ejemplo la operaci√≥n 2 * z, lo que suceder√° es CADA ELEMENTO del vector ser√° multiplicado 2. De la misma manera se pueden definir sumas z + x, ra√≠ces cuadradas sqrt(z) o elevar cada elemento al cuadrado z^2. z &lt;- c(2, 4, 6) 2 * z ## [1] 4 8 12 x &lt;- 1 + 2 z + x ## [1] 5 7 9 sqrt(z) ## [1] 1.414214 2.000000 2.449490 z^2 ## [1] 4 16 36 Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si sumamos dos vectores de distinta longitud? Prueba a definir un vector con los 4 primeros imparos y s√∫male a z. y &lt;- c(1, 3, 5, 7) variable_suma &lt;- z + y ## Warning in z + y: longitud de objeto mayor no es m√∫ltiplo de la longitud de uno ## menor variable_suma ## [1] 3 7 11 9 Como ves, R intenta molestarte lo menos posible, as√≠ que lo hace es reciclar: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que har√° ser√° reciclar elementos del vector con menor longitud: har√° 1+2, 3+4, 5+6 pero‚Ä¶ 7+2 (vuelve al primer par). "],["operaciones-estad√≠sticas-con-vectores-num√©ricos.html", "3.3 Operaciones estad√≠sticas con vectores num√©ricos", " 3.3 Operaciones estad√≠sticas con vectores num√©ricos Al igual que podemos ejecutar operaciones aritm√©ticas, podemos realizar tambi√©n operaciones estad√≠sticas con los vectores, como calcular su suma (sum()), su media (mean()), su mediana (median()), su suma acumulada (cumsum() cada elemento lo acumula al anterior) o percentiles (quantiles()). sum(y) # suma ## [1] 16 mean(y) # media ## [1] 4 median(y) # mediana ## [1] 4 cumsum(y) # suma acumulada ## [1] 1 4 9 16 y &lt;- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29) quantile(y, probs = c(0.15, 0.3, 0.7, 0.9)) # Percentiles p15, p30, p70 y p90 ## 15% 30% 70% 90% ## 5.0 8.5 14.0 23.5 Ver conceptos b√°sicos en 3.10. "],["vectores-de-caracteres-texto.html", "3.4 Vectores de caracteres (texto)", " 3.4 Vectores de caracteres (texto) Un error com√∫n es asociar vectores solo a n√∫meros: un vector es una colecci√≥n de elementos del mismo tipo pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en R se llaman char): &quot;Mi&quot;, &quot;nombre&quot;, &quot;es&quot; &quot;Javier&quot;. Como ves las variables de tipo char van entre comillas dobles, ya que es un cadena de texto. mi_nombre &lt;- c(&quot;Mi&quot;, &quot;nombre&quot;, &quot;es&quot;, &quot;Javier&quot;) mi_nombre ## [1] &quot;Mi&quot; &quot;nombre&quot; &quot;es&quot; &quot;Javier&quot; Ya tenemos nuestro primer vector de texto de longitud 4. Las cadenas de texto son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritm√©ticas como la suma o la media, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la funci√≥n paste(). Dicha funci√≥n nos permite convertir un vector de 4 palabras en una frase, decidiendo que caracter queremos que vaya entre palabra con el argumento collapse =. paste(mi_nombre, collapse = &quot;&quot;) # todo junto ## [1] &quot;MinombreesJavier&quot; paste(mi_nombre, collapse = &quot; &quot;) # separados por un espacio ## [1] &quot;Mi nombre es Javier&quot; paste(mi_nombre, collapse = &quot;.&quot;) # separados por un punto . ## [1] &quot;Mi.nombre.es.Javier&quot; Si queremos pegar los elementos de la cadena de texto sin ning√∫n tipo de caracter, existe una forma m√°s abreviada y limpia de ejecutar la orden paste(mi_nombre, collapse = &quot;&quot;), usando la funci√≥n paste0() paste0(mi_nombre) # todo junto sin nada separando ## [1] &quot;Mi&quot; &quot;nombre&quot; &quot;es&quot; &quot;Javier&quot; Esta funci√≥n es muy √∫til si queremos definir variables de texto que compartan por ejemplo un prefijo (variable_1, variable_2, ‚Ä¶) paste0(&quot;variable&quot;, 1:7) # a la palabra ¬´variable¬ª le pegamos los n√∫meros del 1 al 7 ## [1] &quot;variable1&quot; &quot;variable2&quot; &quot;variable3&quot; &quot;variable4&quot; &quot;variable5&quot; &quot;variable6&quot; ## [7] &quot;variable7&quot; paste(&quot;variable&quot;, 1:7, sep = &quot;_&quot;) # separado por una barra baja ## [1] &quot;variable_1&quot; &quot;variable_2&quot; &quot;variable_3&quot; &quot;variable_4&quot; &quot;variable_5&quot; ## [6] &quot;variable_6&quot; &quot;variable_7&quot; Otra forma m√°s intuitiva de trabajar con textos y variables num√©ricas es usar el paquete {glue}, que nos permite pegar cadenas de texto a variables num√©ricas de forma simb√≥lica. install.packages(&quot;glue&quot;) library(glue) edad &lt;- 10:15 # edades glue(&quot;La edad es de {edad} a√±os&quot;) ## La edad es de 10 a√±os ## La edad es de 11 a√±os ## La edad es de 12 a√±os ## La edad es de 13 a√±os ## La edad es de 14 a√±os ## La edad es de 15 a√±os # Otra forma sin definir variables a priori glue(&quot;La edad es de {10:15} a√±os&quot;) ## La edad es de 10 a√±os ## La edad es de 11 a√±os ## La edad es de 12 a√±os ## La edad es de 13 a√±os ## La edad es de 14 a√±os ## La edad es de 15 a√±os Ya sabemos trabajar con textos :) ¬øY si queremos pasar todo a may√∫scula? ¬øO todo a min√∫scula? ¬øY si queremos sustituir un caracter (por ejemplo .) por otro en todos los elementos? R tambi√©n nos proporciona algunas funciones muy sencillas de usar para dichas tareas. Aqu√≠ un ejemplo de algunas de ellas. texto &lt;- c(&quot;Hola.&quot;, &quot;qu√©&quot;, &quot;ase?&quot;, &quot;todo&quot;, &quot;bien.&quot;, &quot;y yo&quot;, &quot;que&quot;, &quot;ME&quot;, &quot;ALEGRO&quot;) toupper(texto) # todo a may√∫scula ## [1] &quot;HOLA.&quot; &quot;QU√â&quot; &quot;ASE?&quot; &quot;TODO&quot; &quot;BIEN.&quot; &quot;Y YO&quot; &quot;QUE&quot; &quot;ME&quot; ## [9] &quot;ALEGRO&quot; tolower(texto) # todo a min√∫scula ## [1] &quot;hola.&quot; &quot;qu√©&quot; &quot;ase?&quot; &quot;todo&quot; &quot;bien.&quot; &quot;y yo&quot; &quot;que&quot; &quot;me&quot; ## [9] &quot;alegro&quot; gsub(&quot;o&quot;, &quot;*&quot;, texto) # toda &quot;o&quot; en el texto ser√° sustituida por * ## [1] &quot;H*la.&quot; &quot;qu√©&quot; &quot;ase?&quot; &quot;t*d*&quot; &quot;bien.&quot; &quot;y y*&quot; &quot;que&quot; &quot;ME&quot; ## [9] &quot;ALEGRO&quot; Imagen/gr√°fica 3.1: Paquete stringr para manejar cadenas de texto m√°s complejas "],["vectores-l√≥gicos-truefalse.html", "3.5 Vectores l√≥gicos (TRUE/FALSE)", " 3.5 Vectores l√≥gicos (TRUE/FALSE) [X] Variables num√©ricas (individuales) [X] Vectores de n√∫meros [X] Vectores de caracteres [ ] Vectores l√≥gicos Veamos un √∫ltimo tipo de vectores importante en todo lenguaje de programaci√≥n: los vectores l√≥gicos. Un valor l√≥gico puede tomar tres valores: TRUE (guardado internamente como un 1), FALSE (guardado internamente como un 0) o NA (dato ausente, son las siglas de not available). Estos valores son resultado de evaluar condiciones l√≥gicas. Por ejemplo, imaginemos que definimos un vector de n√∫meros x &lt;- c(1.5, -1, 2, 4, 3, -4). ¬øQu√© numeros del vector son menores que 2? Basta con que ejecutemos la orden x &lt; 2, que nos devolver√° TRUE/FALSE en cada hueco, en funci√≥n de si cumple (TRUE) o no (FALSE) la condici√≥n pedida. x &lt;- c(1.5, -1, 2, 4, 3, -4) x &lt; 2 ## [1] TRUE TRUE FALSE FALSE FALSE TRUE El primer, segundo y sexto elemento del vector son los √∫nicos elementos (estrictamente) menores que 2, de ah√≠ que en el primer, segundo y sexto elemento aparezca un TRUE y en el resto un FALSE. Es importante recordar que al evaluar una condici√≥n l√≥gica sobre un vector de longitud n, la salida sigue siendo un vector de longitud n pero con valores l√≥gicos. Dicha condici√≥n l√≥gica puede hacerse con otros operadores como &lt;=, &gt; o &gt;=. x &lt;= 2 ## [1] TRUE TRUE TRUE FALSE FALSE TRUE x &gt; 2 ## [1] FALSE FALSE FALSE TRUE TRUE FALSE x &gt;= 2 ## [1] FALSE FALSE TRUE TRUE TRUE FALSE Tambi√©n podemos comparar si es igual a otro elemento, para lo que usaremos el operador ==, pudiendo usar tambi√©n su opuesto != (distinto de). x == 2 ## [1] FALSE FALSE TRUE FALSE FALSE FALSE x != 2 ## [1] TRUE TRUE FALSE TRUE TRUE TRUE Las condiciones pueden ser combinadas, principalmente de dos maneras: Intersecci√≥n: todas las condiciones concatenadas se deben cumplir (conjunci√≥n y, operador &amp;) para devolver un TRUE. Uni√≥n: basta con que una de las condiciones concatenadas se cumpla (conjunci√≥n o, operador |) para devolver un TRUE. Por ejemplo, vamos a calcular qu√© elementos del vector c(1.5, -1, 2, 4, 3, -4) sean menores que 3 pero (y) mayores que 0, y los elementos menores que 2 o mayores que 3. x &lt;- c(1.5, -1, 2, 4, 3, -4) x &lt; 3 &amp; x &gt; 0 # Solo los que cumplen ambas condiciones ## [1] TRUE FALSE TRUE FALSE FALSE FALSE x &lt; 2 | x &gt; 3 # Los cumplen al menos una de ellas ## [1] TRUE TRUE FALSE TRUE FALSE TRUE Como hemos comentado anteriormente, los valores l√≥gicos TRUE/FALSE son guardados internamente como 0/1 por lo que podemos usar operaciones aritm√©ticas con ellos. Por ejemplo, si queremos averiguar el n√∫mero de elementos de un vector que cumplen una condici√≥n l√≥gica &lt; 2, los que lo hagan tendr√°n asignado un 1 y los que no un 0, por lo que basta con sumar el vector l√≥gico para obtener el n√∫mero de elementos bajo dicha condici√≥n. sum(x &lt; 2) # sumamos el vector de TRUE/FALSE --&gt; n√∫mero de TRUE ## [1] 3 "],["ausentes.html", "3.6 Datos ausentes: NA y NaN", " 3.6 Datos ausentes: NA y NaN La vida no siempre es perfecta as√≠ en muchas ocasiones nos encontraremos con lo que llamamos en estad√≠stica un dato ausente o missing value, un valor que no tenemos en nuestra variable, y un ejemplo pr√°ctico lo tenemos con los datos de vacunaci√≥n de covid del Ministerio de Sanidad. Cada d√≠a se publicaba un PDF (ya‚Ä¶mal) con los datos de vacunaci√≥n PERO‚Ä¶no se publican datos los fines de semana: en dichas fechas hay datos que no tenemos, y en R se representan por NA (significa not available). Vamos a crear un vector de n√∫meros con datos ausentes con la orden x &lt;- c(1, NA, 3, NA, NA, 5, 6): el vector tendr√° longitud 7 pero en el segundo, cuarto y quinto elemento tendremos un dato faltante, un lugar que no tenemos relleno (pero que no eliminamos). x &lt;- c(1, NA, 3, NA, NA, 5, 6) # Vector num√©rico con datos faltante length(x) # longitud del vector ## [1] 7 x ## [1] 1 NA 3 NA NA 5 6 ¬øPuedes aventurar que sucede cuando multiplicamos ese vector por 2 por ejemplo? 2 * x # operaci√≥n aritm√©tica con un vector con NA ## [1] 2 NA 6 NA NA 10 12 Efectivamente: un dato que no tenemos, multiplicado por 2, sigue siendo un dato ausente. Es muy importante para evitar resultados err√≥neos que entendamos que un dato ausente no computa en una operaci√≥n aritm√©tica, es un hueco vac√≠o. Si hacemos la suma del vector, estamos sumando n√∫meros m√°s datos ausentes, por lo que el resultado final ser√° tambi√©n un dato ausente. Si tenemos alg√∫n dato ausente en nuestro vector, la suma final est√° a su vez ausente, ¬°no podemos saber cu√°nto vale! sum(x) # suma de un vector que contiene NA ## [1] NA Para evitar que un dato ausente en nuestros datos nos impida hacer ciertas operaciones, en muchas funciones de R podemos a√±adir el argumento na.rm = TRUE: primero elimina los datos ausentes, y luego ejecuta la funci√≥n. sum(x, na.rm = TRUE) # eliminando datos ausentes ## [1] 15 Una manera de localizar que elementos est√°n ausentes en nuestras variables es con la funci√≥n is.na(), una funci√≥n que nos devuelve un vector de valores l√≥gico: TRUE si el elemento est√° ausente y FALSE si no lo est√°. is.na(x) # TRUE si est√° ausente (NA), FALSE si no lo est√°. ## [1] FALSE TRUE FALSE TRUE TRUE FALSE FALSE Dichos datos ausentes se pueden eliminar (sin necesidad de sumarlos) con la funci√≥n na.omit() (aunque a veces lo que nos interesa es que no sea ausente, introduciendo el punto medio entre su valor anterior y su valor posterior, por ejemplo). na.omit(x) ## [1] 1 3 5 6 ## attr(,&quot;na.action&quot;) ## [1] 2 4 5 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; Hay un tipo de dato muy particular, como resultado de operaciones no permitidas o cuyo resultado es indeterminado, que en R lo veremos como NaN: not a number, un resultado fruto de una indeterminaci√≥n, como por ejemplo la operaci√≥n 0/0 (cuyo l√≠mite no est√° definido). Importante saber que tambi√©n existe una forma de denotar al infinito como Inf, siendo el resultado de algunas operaciones como 1/0 (cuyo l√≠mite si existe). 1/0 ## [1] Inf 0/0 ## [1] NaN sqrt(-1) ## Warning in sqrt(-1): Se han producido NaNs ## [1] NaN De la misma manera que podemos localizar valores NA, tenemos a nuestra disposici√≥n las funciones is.infinte() y is.nan() para detectar que elementos de nuestro vector son Inf o NaN, respectivamente. x &lt;- c(1, NA, 3, 4, Inf, 6, 7, Inf, NaN, NA) is.na(x) ## [1] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE is.nan(x) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE is.infinite(x) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE "],["seleccionar-elementos-de-un-vector.html", "3.7 Seleccionar elementos de un vector", " 3.7 Seleccionar elementos de un vector Ya sabemos definir variables que sean vectores (recuerda: colecci√≥n de valores del mismo tipo). ¬øY si del vector original queremos EXTRAER UN SUBCONJUNTO del mismo, por ejemplo, los primeros 10 elementos? R tiene varias formas de hacer esto pero la m√°s sencilla es entendiendo que si yo quiero acceder al elemento i de un vector, deber√© usar el operador de selecci√≥n [i]. Veamos un ejemplo x &lt;- 1:100 # Vector de longitud 100 (del 1 al 100) y &lt;- x[37] # Solo me interesa el elemento que ocupa el lugar 37 y ## [1] 37 Dado que hemos visto que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un vector de √≠ndices a seleccionar, de forma que le podemos indicar simultaneamente que valores que queremos x[c(1, 4, 51, 77)] # Solo queremos acceder a los elementos en la posici√≥n 1, 4, 51, y 77 ## [1] 1 4 51 77 y &lt;- c(&quot;hola&quot;, &quot;qu√©&quot;, &quot;tal&quot;, &quot;todo&quot;, &quot;ok&quot;, &quot;?&quot;) y[1:2] # Solo queremos acceder a los elementos en la posici√≥n 1 y 2 ## [1] &quot;hola&quot; &quot;qu√©&quot; c(1:2, length(y)) ## [1] 1 2 6 y[c(1:2, length(y))] # Solo accedemos a los elementos en la posici√≥n 1, 2 y adem√°s el que ocupa la √∫ltima posici√≥n (recuerda: length(y) nos da la longitud total del vector) ## [1] &quot;hola&quot; &quot;qu√©&quot; &quot;?&quot; Otras veces no querremos seleccionar un elemento en concreto sino filtrar algunos elementos en concreto y no extraerlos, para lo cual deberemos repetir la misma operaci√≥n pero con el signo - delante: el operador [-i] no selecciona el elemento i-√©simo del vector sino que lo elimina en nuestro filtro. y ## [1] &quot;hola&quot; &quot;qu√©&quot; &quot;tal&quot; &quot;todo&quot; &quot;ok&quot; &quot;?&quot; z &lt;- y[-2] # Nos muestra todo y salvo el elemento que ocupa la segunda posici√≥n z ## [1] &quot;hola&quot; &quot;tal&quot; &quot;todo&quot; &quot;ok&quot; &quot;?&quot; Sin embargo, lo habitual es que dicho filtro que hagamos de una variable lo hagamos en base a una condici√≥n l√≥gica. Supongamos que x &lt;- c(7, 20, 18, 3, 19, 9, 13, 3, 45) y y &lt;- c(17, 21, 58, 33, 15, 59, 13, 1, 45) son las edades de dos grupos de personas y que queremos quedarnos solo con los mayores edad. ¬øTenemos que andar averiguando en que posici√≥n se encuentran para luego seleccionarlos? No, vamos a seleccionar los elementos que cumplen una condici√≥n dada. x &lt;- c(7, 20, 18, 3, 19, 9, 13, 3, 45) y &lt;- c(17, 21, 58, 33, 15, 59, 13, 1, 45) x[x &gt;= 18] # mayores de 18 a√±os del conjunto x ## [1] 20 18 19 45 y[x &gt;= 18] # mayores de 18 a√±os del conjunto y ## [1] 21 58 15 45 Lo que hemos hecho ha sido pasarlo como √≠ndices un vector l√≥gico TRUE/FALSE, de forma que solo filtrar√° los que tengan un TRUE asignado, aquellos que cumplen la condici√≥n l√≥gica introducida. Esto tambi√©n nos puede servir para limpiar de datos ausentes, combinando la funci√≥n is.na(), que nos localiza el lugar que ocupan los ausentes, con el operador !, que lo que hace es negar lo que venga detr√°s. Tambi√©n podemos probar a combinar condiciones l√≥gicas para nuestra selecci√≥n. x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA) x[x &gt;= 18] # mayores de 18 a√±os del conjunto x ## [1] NA 20 19 21 25 80 NA x[is.na(x)] # solo valores ausentes ## [1] NA NA x[!is.na(x)] # sin valores ausentes: ! es el s√≠mbolo de la negaci√≥n ## [1] 7 20 3 19 21 25 80 !(x &gt;= 18) # niega los mayores de 18 a√±os, todo lo que no cumpla esa condici√≥n ## [1] TRUE NA FALSE TRUE FALSE FALSE FALSE FALSE NA x[x &gt;= 18 &amp; x &lt;= 25] # los valores que cumplen ambas (&amp;): entre 18 y 25 a√±os ## [1] NA 20 19 21 25 NA Como ves si un valor es NA, la evaluaci√≥n de una condici√≥n l√≥gica sobre √©l (mayor o menor de 18 a√±os) nos seguir√° devolviendo NA. Por √∫ltimo, R nos permite dar significado l√©xico a nuestros valores (significan algo, no solo n√∫meros), pudiendo poner nombres a los elementos de un vector, permitiendo su selecci√≥n por dichos nombres x &lt;- c(&quot;edad&quot; = 31, &quot;tlf&quot; = 613910687, &quot;cp&quot; = 33007) # cada n√∫mero tiene un significado distinto x ## edad tlf cp ## 31 613910687 33007 x[c(&quot;edad&quot;, &quot;cp&quot;)] # seleccionamos los elementos que tienen ese nombre asignado ## edad cp ## 31 33007 Con la funci√≥n names() adem√°s podemos, no solo consultar los nombres de una variable, sino cambiarlos a nuestro gusto. names(x) # Consultamos nombres ## [1] &quot;edad&quot; &quot;tlf&quot; &quot;cp&quot; names(x) &lt;- c(&quot;a√±os&quot;, &quot;m√≥vil&quot;, &quot;direcci√≥n&quot;) # Cambiamos nombres names(x) # Consultamos nuevos nombres ## [1] &quot;a√±os&quot; &quot;m√≥vil&quot; &quot;direcci√≥n&quot; x ## a√±os m√≥vil direcci√≥n ## 31 613910687 33007 3.7.1 which Hemos visto como seleccionar elementos de un vector que cumplen una condici√≥n, para a veces no queremos el elemento en s√≠, sino el lugar que ocupa: ¬øqu√© valores de un vector cumplen una condici√≥n l√≥gica, qu√© lugar ocupan? Para obtener dicho √≠ndice tenemos a nuestro disposici√≥n la funci√≥n which(), que no nos devuelve el elemento en s√≠ sino su lugar. x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA) x[x &gt;= 18] # Accedemos a los elementos que cumplen la condici√≥n ## [1] NA 20 19 21 25 80 NA which(x &gt;= 18) # Obtenemos los lugares que ocupan los elementos que cumplen la condici√≥n ## [1] 3 5 6 7 8 Esta funci√≥n es muy √∫til especialmente cuando queremos averiguar el valor que ocupa el m√°ximo/m√≠nimo de una colecci√≥n de valores, con las funciones which.max() y which.min(). max(x, na.rm = TRUE) # m√°ximo de x (si no eliminamos NA, nos devolver√° NA) ## [1] 80 min(x, na.rm = TRUE) # m√≠nimo de x (si no eliminamos NA, nos devolver√° NA) ## [1] 3 which.max(x) # Lugar que ocupa el m√°ximo ## [1] 8 x[which.max(x)] ## [1] 80 which.min(x) # Lugar que ocupa el m√≠nimo ## [1] 4 x[which.min(x)] ## [1] 3 3.7.2 NULL A veces veremos que adem√°s de NA y NaN, R nos muestra un dato llamado NULL. Cuando tenemos NA en alguna variable, el registro existe, pero no est√° relleno. Sin embargo, cuando tenemos un NULL significa que ese registro ni siquiera existe: no es un dato guardado pero cuyo valor desconocemos, es un dato que ni siquiera existe (por ejemplo, si guardamos datos de 7 personas, el dato de la octava persona no es NA, es que no hay octava persona directamente). x &lt;- c(1, NA, 3, NA, NA, 5, 6) x[2] # NA: el registro existe pero sin dato ## [1] NA names(x) # No hemos definido el nombre de las variables, as√≠ que devuelve NULL ## NULL "],["ordenar-vectores.html", "3.8 Ordenar vectores", " 3.8 Ordenar vectores Una acci√≥n habitual al trabajar con datos es saber ordenarlos: de menor a mayor edad, datos m√°s recientes vs antiguos, etc. Para ello tenemos la funci√≥n sort(), que podemos usar directamente para ordenar de menor a mayor, o con el argumento decreasing = TRUE, para ordenar de mayor a menor. x &lt;- c(1, -3, 0, 10, 5, 2, 7, -13) sort(x) # orden de menor a mayor ## [1] -13 -3 0 1 2 5 7 10 sort(x, decreasing = FALSE) # orden de mayor a menor ## [1] -13 -3 0 1 2 5 7 10 Otra forma de ordenar un vector es que R nos devuelva los √≠ndices de los elementos ordenados, y luego usar dichos √≠ndices para reorganizar los elementos, con la funci√≥n order(). order(x) # el elemento m√°s peque√±o es el octavo, luego el segundo, luego el tercero, luego el primero, luego el sexto, etc. ## [1] 8 2 3 1 6 5 7 4 x[order(x)] # accedemos a los √≠ndices ordenados, equivalente al sort(x) ## [1] -13 -3 0 1 2 5 7 10 "],["fechas.html", "3.9 Fechas", " 3.9 Fechas Hay un tipo muy especial de datos que son los datos tipo fecha. Una fecha podr√≠a ser a priori una simple cadena de texto &quot;2021-04-21&quot; pero podemos usar la funci√≥n as.Date() para que R entienda que esa cadena de texto representa un instante temporal. F√≠jate la diferencia entre una fecha en texto y una fecha con as.Date(). fecha_char &lt;- &quot;2021-04-21&quot; fecha_date &lt;- as.Date(fecha_char, format = &quot;%Y-%m-%d&quot;) fecha_char + 1 ## Error in fecha_char + 1: argumento no-num√©rico para operador binario fecha_date + 1 ## [1] &quot;2021-04-22&quot; En el momento en que el convertimos la cadena de texto a fecha, aunque se visualice como tal, internamente es un n√∫mero, por lo que podemos restar fechas (d√≠as entre ambas), podemos sumar n√∫meros a fechas (fecha d√≠as despu√©s), etc. Dentro del entorno {tidyverse}, el paquete {lubridate} tiene implementadas m√∫ltiples funciones para poder operar con fechas de forma sencilla e intuitiva. "],["glosario3.html", "3.10 üìö Glosario", " 3.10 üìö Glosario numeric: variables de tipo num√©ricas (algunas veces vendr√°n indicados como int o integer para enteros, y dbl o double para n√∫meros con decimales). character: variables de tipo caracter. Date: variables de tipo fecha. Media: medida de centralizaci√≥n que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. A pesar de ser la m√°s conocida, la media es muy poco robusta: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturbar con mucha facilidad. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(\\overline{x}\\). \\[\\overline{x} = \\frac{\\displaystyle \\sum_{i=1}^{n}x_i}{n}\\] Mediana: medida de centralizaci√≥n que consiste en, tras ordenar los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos n√∫meros por debajo como por encima). M√°s robusta que la media aunque menos la moda. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Me_x\\). \\[Me_x = \\displaystyle \\arg \\min_{x_i} \\left\\lbrace F_i &gt; 0.5 \\right\\rbrace, \\quad F_i = \\frac{\\#\\left\\lbrace x_j \\leq x_i \\right\\rbrace}{n}\\] Moda: medida de centralizaci√≥n que consiste en encontrar el valor m√°s repetido (el valor trending). Es la medida de centralizaci√≥n m√°s robusta. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Mo_x\\). \\[Mo_x = \\displaystyle \\arg \\max_{x_i} f_i , \\quad f_i = \\frac{\\#\\left\\lbrace x_j = x_i \\right\\rbrace}{n}\\] "],["consejos-y-tips-2.html", "3.11 Consejos y tips", " 3.11 Consejos y tips Operaciones elemento a elemento (vectorial) Es importante recordar que cada operaci√≥n con un vector es una operaci√≥n realizada en CADA elemento del vector, devolvi√©ndonos a su vez un vector de salida de igual longitud que la variable con la que hemos operado. Diferencia de conjuntos Una funci√≥n muy √∫til para ver las diferencias entre dos conjuntos es setdiff(), una funci√≥n que nos devuelve los elementos distintos entre dos conjuntos. y &lt;- 1:10 z &lt;- c(1, 3, 7, 10) setdiff(y, z) # Elementos en y que no est√°n en z ## [1] 2 4 5 6 8 9 Argumentos por defecto La funci√≥n sort() es un buen ejemplo de que las funciones traen definidos argumentos por defecto (aunque no los veamos a priori). La orden sort(x) en realidad est√° ejecutando sort(x, decreasing = TRUE), pero como es su valor por defecto, nos podemos ahorrar incluirlo. Escribe ? help sort() en la consola y ver√°s como en la cabecera de la funci√≥n ya hay preasignado un decreasing = TRUE. Recuperar un comando y autocompletar Si haces click con el rat√≥n en la consola y pulsas la flecha ¬´arriba¬ª del teclado, te ir√° apareciendo todo el historial de √≥rdenes ejecutadas. Es una manera de ahorrar tiempo para ejecutar √≥rdenes similares. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, si pulsas tabulador, R te autocompletar√° solo (prueba a escribir solo variab y pulsa tabulador) all, any Existen dos funciones muy √∫tiles en R para saber si TODOS o ALGUNO de los elementos de un vector cumple una condici√≥n. Las funciones all() y any() nos devolver√° un √∫nico valor l√≥gico. Estas funciones son muy √∫tiles al final de los c√≥digos para comprobar que las condiciones que tienen que verificar los datos se cumplen, y asegurarnos que el proceso se ha ejecutado correctamente (por ejemplo, que todos los datos sean positivos o no haya datos ausentes). x &lt;- c(1, 2, 3, 4, 5, NA, 7) all(x &lt; 3) ## [1] FALSE any(x &lt; 3) ## [1] TRUE all(x &gt; 0) ## [1] NA all(na.omit(x) &gt; 0) ## [1] TRUE all(is.na(x)) ## [1] FALSE any(is.na(x)) ## [1] TRUE Constantes: n√∫mero pi R tiene una variable reservada al n√∫mero \\(\\pi\\), lista para ser usada, por lo que se recomienda no nombrar a ninguna variable con dicho nombre. pi ## [1] 3.141593 Convertir tipos de datos A veces la lectura de variables num√©ricas de nuestros archivos puede hacer que un n√∫mero, por ejemplo 1, sea le√≠do como la cadena de texto &quot;1&quot;, con la que no podemos operar como un n√∫mero. Las funciones as.numeric(), as.character() y as.logical() nos permiten convertir una variable en tipo num√©rico, caracter o l√≥gico, respectivamente. &quot;1&quot; + 1 ## Error in &quot;1&quot; + 1: argumento no-num√©rico para operador binario as.numeric(&quot;1&quot;) + 1 ## [1] 2 as.character(1) ## [1] &quot;1&quot; as.logical(c(0, 1)) ## [1] FALSE TRUE Optimizar nuestro c√≥digo: eficiencia en tiempo de ejecuci√≥n Aunque parezca un tema menor, si tu c√≥digo tarda 1 milisegundo m√°s de lo que podr√≠a tardar de otra forma, si esa orden se repite muchas veces, ese milisegundo extra puede ser 5, 10 o 20 minutos m√°s que tu c√≥digo tardar√° en ejecutarse. Hay un paquete muy √∫til en R para medir tiempos de distintas √≥rdenes que hacen lo mismo (el paquete {microbenchmark}), vamos a instalarlo. install.packages(&quot;microbenchmark&quot;) library(microbenchmark) Este paquete contiene una orden para comparar el tiempo de dos √≥rdenes: necesita como primeros argumentos las dos √≥rdenes cuyos tiempos vamos a comparar, y un argumento times en el que le indicamos el n√∫mero de veces que ejecutar√° cada orden para realizar los tiempos medios. Vamos a comparar los comandos de ordenaci√≥n order() y sort(). x &lt;- rnorm(1e3) # 1000 elementos aleatorias de una normal N(0, 1) microbenchmark(sort(x), # primera forma x[order(x)], # segunda forma times = 1e3) # se repetir√° 1000 veces ## Unit: microseconds ## expr min lq mean median uq max neval cld ## sort(x) 46.978 49.8095 58.72934 51.6795 58.3395 196.788 1000 b ## x[order(x)] 34.311 36.7055 42.74070 37.9775 41.7645 169.096 1000 a S√≠, est√°s viendo bien: aunque a priori parezca contraintuitivo, es m√°s corto obtener los √≠ndices ordenados de un vector, y luego reordenarlo en base a esos √≠ndices, que la ordenaci√≥n directa a trav√©s del comando sort() (ya que usan algoritmos de ordenaci√≥n distintos). "],["ejercicios-1.html", "3.12 üìù Ejercicios", " 3.12 üìù Ejercicios üìùEjercicio 1: define un vector que contenga los n√∫meros 1, 10, -1 y 2, y gu√°rdalo en una variable llamada vector_num. Tras definirlo, calcula su suma y la versi√≥n ordenada del vector definido como sumar 1 a cada elemento de vector_num. Soluci√≥n: # Vector de n√∫meros vector_num &lt;- c(1, 10, -1, 2) # Suma sum(vector_num) ## [1] 12 # Ordenamos el vector + 1 (con sort) sort(vector_num + 1) ## [1] 0 2 3 11 # Ordenamos el vector + 1 (con order) vector_num2 &lt;- vector_num + 1 vector_num2[order(vector_num2)] ## [1] 0 2 3 11 üìùEjercicio 2: encuentra del vector vector_num original el lugar (el √≠ndice) que ocupa su m√≠nimo y su m√°ximo. Devuelve un vector l√≥gico con los elementos que son mayores 1 y menores que 7. Piensa una manera de encontrar si todos son positivos. Soluci√≥n: vector_num &lt;- c(1, 10, -1, 2) # Encontrando el lugar que ocupa el m√°ximo y m√≠nimo which.max(vector_num) ## [1] 2 which.min(vector_num) ## [1] 3 # Vector l√≥gico: mayores que 1 y menores que 7 vector_num &gt; 1 &amp; vector_num &lt; 7 ## [1] FALSE FALSE FALSE TRUE # ¬øSon todos positivos? all(vector_num &gt; 0) ## [1] FALSE üìùEjercicio 3: crea un vector con las palabras ‚ÄúHola‚Äù, ‚Äúme‚Äù, ‚Äúllamo‚Äù (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est√© correctamente escrita en castellano. Tras hacerlo, a√±ade ‚Äúy tengo 30 a√±os‚Äù. Soluci√≥n: # Definiendo el vector vector_char &lt;- c(&quot;Hola&quot;, &quot;me&quot;, &quot;llamo&quot;, &quot;Javier&quot;, &quot;√Ålvarez&quot;, &quot;Li√©bana&quot;) # Pegamos paste(vector_char, collapse = &quot; &quot;) ## [1] &quot;Hola me llamo Javier √Ålvarez Li√©bana&quot; # A√±adimos frase paste0(paste(vector_char, collapse = &quot; &quot;), &quot; y tengo 30 a√±os.&quot;) ## [1] &quot;Hola me llamo Javier √Ålvarez Li√©bana y tengo 30 a√±os.&quot; üìùEjercicio 4: obten la fecha de hoy, define la fecha de tu cumplea√±os, y calcula la diferencia de d√≠as. Soluci√≥n: # Hoy hoy &lt;- Sys.Date() # Cumple (diferentes formatos) cumple &lt;- as.Date(&quot;1989-09-10&quot;) cumple &lt;- as.Date(&quot;10-09-1989&quot;, &quot;%d-%m-%Y&quot;) # Diferencia hoy - cumple ## Time difference of 11686 days "],["flujo-de-trabajo-proyecto.html", "Cap√≠tulo 4 Flujo de trabajo: proyecto", " Cap√≠tulo 4 Flujo de trabajo: proyecto Estamos listos/as para crear nuestro primer proyecto de R :) Cuando se empieza a programar para un trabajo concreto de R es recomendable crearnos lo que se conoce como un proyecto de R: en lugar de ir abriendo ventanas sueltas para programar (los scripts, los archivos con extensi√≥n .R), podemos agruparlos en distintos proyectos, de forma que podamos acceder a ellos de forma ordenada (algo as√≠ como crear carpetas en nuestro disco duro). "],["crear-proyecto.html", "4.1 Crear proyecto", " 4.1 Crear proyecto Para crear nuestro proyecto deberemos de ir al men√∫ superior File &lt;&lt; New Project (ver 4.1) Imagen/gr√°fica 4.1: Crear un nuevo proyecto en R. Se nos abrir√° una ventana con 3 opciones: New directory: crear un proyecto desde el inicio (opci√≥n recomendable). Existing directory: crear un proyecto con los c√≥digos que tienes ya guardados en una carpeta. Version control: para importar el proyecto de alg√∫n repositorio y vincularlo a √©l. Imagen/gr√°fica 4.2: Opciones de creaci√≥n. Imagen/gr√°fica 4.3: Clickar en ¬´New project¬ª. Deberemos elegir el directorio de nuestro ordenador donde queremos que se guarde (una carpeta que contendr√° todos los c√≥digos y datos de ese proyecto), as√≠ como el nombre del proyecto (que ser√° a su vez el nombre de la subcarpeta que se os crear√° en el ordenador). Imagen/gr√°fica 4.4: Nombre del proyecto. Una vez que el proyecto est√° creado, abriremos nuestro primer script de R (donde escribiremos el c√≥digo), escribiremos una descripci√≥n del proyecto en la primera l√≠nea y guardaremos el archivo (archivo de extensi√≥n .R). Imagen/gr√°fica 4.5: Abrir nuestro primer script de R. Imagen/gr√°fica 4.6: Descripci√≥n al inicio del c√≥digo. Imagen/gr√°fica 4.7: Guardamos el c√≥digo. Imagen/gr√°fica 4.8: Guardamos el c√≥digo. Este ser√° nuestro c√≥digo principal (puedes ponerle el nombre que quieras, normalmente se le llama main.R para diferenciarlo del resto), desde el que iremos construyendo nuestro c√≥digo e iremos llamando a otros archivos si es necesario. Recuerda que programar es como escribir: cuanto m√°s limpio y estructurado, mejor se entender√°. La ventaja de tener los c√≥digos agrupados por proyectos es que si estamos trabajando en varios a la vez podemos saltar de uno a otro, visualizando solo los c√≥digos de un proyecto, y no los 100 archivos sin_titulo131.R que vayamos creando. Imagen/gr√°fica 4.9: Saltar de proyecto en proyecto. "],["directorios-de-trabajo-y-cabecera.html", "4.2 Directorios de trabajo y cabecera", " 4.2 Directorios de trabajo y cabecera Como luego veremos en la 5, es altamente recomendable que todos los archivos (c√≥digos, datos, im√°genes, recursos, etc) los tengamos dentro de la misma carpeta del proyecto (aunque podamos crear subdirectorios), para que trabajar en el proyecto sea m√°s sencillo e intuitivo. Vamos a crearnos dentro de la carpeta del proyecto, una subcarpeta que se llame CODIGOS, y creamos un script llamado variables.R dentro de esa carpeta. Imagen/gr√°fica 4.10: Subcarpeta ¬´CODIGOS¬ª. Imagen/gr√°fica 4.11: Creamos un fichero ¬´variables.R¬ª. En ese c√≥digo de prueba vamos a definir algunas variables fijas que luego usaremos en el c√≥digo principal (suele suceder con variables que van a ser fijas como nombres, fechas o codificaciones de variables). # Descripci√≥n: script de prueba con variables # Variables x &lt;- c(1, 2, 0, -1, 71) # Vector de n√∫meros y &lt;- c(&quot;hola&quot;, &quot;me&quot;, &quot;llamo&quot;, &quot;Javier&quot;) # Vector de caracteres apellido &lt;- &quot;√Ålvarez&quot; # Fechas hoy &lt;- as.Date(Sys.time()) # Convertir a tipo fecha la fecha de hoy fecha_origen &lt;- as.Date(&quot;2021-01-01&quot;) # Inicio de a√±o Imagen/gr√°fica 4.12: Escribimos una serie de variables fijas para luego ser usadas. No es obligatorio pero es altamente recomendable tener muy estructurado nuestros c√≥digos, de forma que el archivo .R haga una tarea concreta y definida (uno carga archivos, otro preprocesa, otro hace un modelo, otro hace las gr√°ficas), y sea el c√≥digo principal el que haga una llamada limpia a todos ellos, para que en caso de error, la detecci√≥n del mismo sea m√°s sencilla. As√≠ que eso haremos: desde nuestro archivo principal main.R llamaremos a ese archivo variables.R, para luego usar las variables definidas en √©l. ¬øC√≥mo indicarle a R donde est√° nuestro fichero? En R, como en todo lenguaje de programaci√≥n, podemos consultar lo que el ordenador llama directorio de trabajo: la carpeta ¬´base¬ª desde donde est√° ejecutando tu c√≥digo. Dicha ruta de directorio se puede consultar con la funci√≥n getwd(), pudiendo ver los archivos y carpetas que hay dentro del mismo con el comando dir() getwd() dir() Imagen/gr√°fica 4.13: Consultar directorio de trabajo predeterminado y archivos contenidos en √©l. Lo ideal es empezar el c√≥digo fijando como directorio de trabajo el directorio donde tengamos nuestro archivo principal main.R y para ello usaremos la funci√≥n setwd(), cuyo argumento ser√° la ruta donde queremos fijarlo. Para hacerlo de forma autom√°tica (y que el c√≥digo pueda ser abierto por ti pero tambi√©n por otros que no tengan tu misma estructura de carpetas), obtendremos de forma autom√°tica la ruta del archivo main.R o del proyecto con la orden rstudioapi::getSourceEditorContext()$path, y despu√©s usaremos dirname() para quedarnos solo con la ruta de carpetas (eliminando el nombre del fichero al final). Esa ser√° la ruta que le pasaremos a setwd(), quedando nuestro directorio de trabajo autom√°ticamente fijado, sin preocuparnos de la ruta # Fijamos directorio de trabajo autom√°ticamente setwd(dirname(rstudioapi::getSourceEditorContext()$path)) Imagen/gr√°fica 4.14: Fijamos de forma autom√°tico el directorio de trabajo. Una vez que hemos fijado nuestro directorio, para cargar c√≥digo .R, basta que usemos la funci√≥n source(), cuyo argumento ser√° la ruta del archivo. Como tenemos de directorio base el directorio en el que tenemos nuestro archivo principal (./), bastar√° que empecemos a escribir source(&quot;./&quot;), presionar el tabulador, y se nos abrir√° el men√∫ de archivos de nuestro directorio de trabajo, pudiendo ir seleccionando de forma sencilla la ruta de nuestro archivo. # Cargamos fichero variable.R source(&quot;./CODIGOS/variables.R&quot;) Imagen/gr√°fica 4.15: Cargar archivos de nuestro directorio de trabajo. Imagen/gr√°fica 4.16: Cargar archivos de nuestro directorio de trabajo. "],["ejecuci√≥n.html", "4.3 Ejecuci√≥n", " 4.3 Ejecuci√≥n Ese archivo que hemos incluido en el c√≥digo principal nos cargar√° las variables que hemos definido en √©l, pudiendo usarlas en el c√≥digo. Vamos a ejecutar lo que tenemos de momento, y para ello tenemos 2 opciones: o copiar el c√≥digo del script en la consola y pulsar ENTER, o bien, activando la casilla source on save y guardando el script (no solo se guardar√° sino que se ejecutar√°). Imagen/gr√°fica 4.17: Guardamos con la casilla ¬´source on save¬ª activada para que adem√°s de guardar se ejecute el c√≥digo. Como vemos en la imagen 4.17, una vez ejecutado, tenemos en nuestro panel de entorno (parte superior derecha) las variables ya cargadas que ten√≠amos definidas en nuestro fichero variables.R. Prueba a escribir algunas funciones que hemos aprendido con dichas variables y vuelve a hacer click en ¬´guardar¬ª con source on save activado. # Sumamos 3 a cada elemento de x z &lt;- x + 3 z ## [1] 4 5 3 2 74 # Imprimimos por pantalla la frase unida, y a dicha frase # le pegamos nuestro apellido cat(paste(paste(y, collapse = &quot; &quot;), apellido)) ## hola me llamo Javier √Ålvarez # D√≠as que han pasado desde el inicio de a√±o dias &lt;- hoy - fecha_origen dias ## Time difference of 250 days La funci√≥n cat() nos muestra por consola el texto que le pasemos de argumento (funci√≥n especial para mensajes de alerta por consola) Imagen/gr√°fica 4.18: C√°lculos con la variables definidas: suma, concatenaci√≥n de texto y diferencia de fechas. Ya hemos ejecutado nuestro primer proyecto en .R :) "],["consejos-y-tips-3.html", "4.4 Consejos y tips", " 4.4 Consejos y tips Comentarios en los c√≥digos Es crucial que intentes documentar al m√°ximo tu c√≥digo y que te acostumbres a ello desde el principio, dejando expl√≠cito que haces en cada paso, tanto para ti como para otra persona que pueda leer tu c√≥digo y lo entienda. Para ello usaremos # comentario cuando queramos dejar comentarios en el c√≥digo. Dichas partes, am√©n de estar en otro color, no son le√≠das por R ni ejecutadas: son comentarios que el programa ¬´no ve¬ª, solo son para nosotros. Limpiar el entorno A veces empezamos a programar sin apagar el ordenador y tenemos variables guardadas de otros d√≠as que pueden generar conflictos y consumo de memoria. Para asegurarnos que cada vez que empezamos, lo hacemos de cero, es altamente recomendable empezar el c√≥digo con rm(list = ls()). La funci√≥n ls() nos devuelve todas las variables que tenemos definidas en nuestro entorno, y la funci√≥n rm() nos las elimina. Anular warnings Algunas funciones pueden arrojarse ciertas advertencias que nunca est√° de m√°s leer. Pero si dichos mensajes de alerta los tenemos controlados y no queremos que nos ensucie la ejecuci√≥n en la consola, podemos poner al inicio del c√≥digo assign(&quot;last.warning&quot;, NULL, envir = baseenv()) para limpiar los warnings antiguos y options(warn = -1) para desactivarlos. Limpiar consola Podemos limpiar la consola clickando en al escoba que tenemos en la parte superior derecha de la misma. Esta acci√≥n no nos elimina ninguna variable, simplemente nos limpia la consola de mensajes. Guardar los scripts Los scripts que tengas sin guardar tendr√°n un asterisco * al final del nombre en la pesta√±a superior de la ventana. Fecha y hora de hoy La funci√≥n Sys.time() accede al sistema de nuestro ordenador para decirnos la fecha y hora del momento de la ejecuci√≥n de dicha funci√≥n. Sys.time() ## [1] &quot;2021-09-08 11:29:19 CEST&quot; Cambiar la notaci√≥n exponencial Por defecto, R muestra los n√∫meros en formato de notaci√≥n exponencial. Por ejemplo, el n√∫mero 1000000 nos lo mostrar√° por defecto como 1e+06. A veces podemos querer que se muestre con todas sus cifras (por ejemplo, en el t√≠tulo o leyenda de una gr√°fica): para anular la notaci√≥n exponencial, escribe al inicio del c√≥digo options(&quot;scipen&quot; = 10). "],["datos.html", "Cap√≠tulo 5 Tipos de datos II: tablas", " Cap√≠tulo 5 Tipos de datos II: tablas Sabemos un poco de la gram√°tica y ortograf√≠a de nuestro lenguaje, y sabemos las funcionalidades b√°sicas de nuestro Word. Vamos a encontrar la mejor trama para la novela: hablemos de estructuras de datos. "],["matrices.html", "5.1 Matrices", " 5.1 Matrices Hasta ahora hemos visto solo datos en una dimensi√≥n: una variable, que tiene n valores num√©ricos, n valores l√≥gicos o n valores de tipo texto. Una sola variable (de n elementos). Pero cuando analizamos datos solemos tener varias variables distintas. Cuando tenemos distintas variables num√©ricas de igual longitud, un formato de dato muy habitual de trabajar es lo que conocemos como matrices: una ¬´tabla¬ª de n√∫meros, con filas y columnas. Vamos a definir las edades, tel√©fonos y c√≥digos postales de una serie de individuos. edades &lt;- c(14, 24, 56, 31, 20, 87, 73) # vector num√©rico de longitud 7 tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA) cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073, 17140) Hasta ahora, cada variable la hemos definido por separado, pero ahora vamos a juntarlas: vamos a crear nuestro primer conjunto de datos juntado todas ellas en una matriz, un conjunto de n√∫meros organizado en 3 columnas (una por variable) y 7 filas o registros (una por persona). Para ello usaremos la funci√≥n cbind(), que nos concatena vectores de igual longitud en formato columna. x &lt;- cbind(edades, tlf, cp) # Construimos la matriz por columnas x ## edades tlf cp ## [1,] 14 NA 33007 ## [2,] 24 683839390 28019 ## [3,] 56 621539732 37005 ## [4,] 31 618211286 18003 ## [5,] 20 NA 33091 ## [6,] 87 914727164 25073 ## [7,] 73 NA 17140 Lo que tenemos es una columna por variable y una fila por registro. Tambi√©n podemos construir la matriz por filas con el comando rbind() (aunque lo habitual es tener cada variable en una columna). y &lt;- rbind(edades, tlf, cp) # Construimos la matriz por filas y ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## edades 14 24 56 31 20 87 73 ## tlf NA 683839390 621539732 618211286 NA 914727164 NA ## cp 33007 28019 37005 18003 33091 25073 17140 Como ves, ahora nuestros datos est√°n tabulados, tienen dos dimensiones. ¬øC√≥mo saber las dimensiones que tiene una matriz? Prueba a ejecutar la funci√≥n dim(). dim(x) ## [1] 7 3 dim(y) ## [1] 3 7 F√≠jate que dim() devuelve un vector de 2 elementos, por lo que para acceder las filas deberemos ejecutar dim(x)[1] (y dim(x)[2] para las columnas). Tambi√©n tenemos a nuestra disposici√≥n las funciones nrow() y ncol(), que nos devuelven directamente el n√∫mero de filas y columnas. dim(x)[1] ## [1] 7 dim(x)[2] ## [1] 3 nrow(x) ## [1] 7 ncol(x) ## [1] 3 Bien, ya sabemos definir una matriz a partir de variables. Igual que a veces es √∫til generar un vector de elementos repetidos, tambi√©n podemos definir una matriz de n√∫meros repetidos (por ejemplo, de ceros), con la funci√≥n matrix(), indic√°ndole el n√∫mero de filas y columnas. matrix(0, nrow = 5, ncol = 3) # 5 filas, 3 columnas, todo 0&#39;s ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 ## [4,] 0 0 0 ## [5,] 0 0 0 Tambi√©n podemos definir una matriz a partir de un vector num√©rico, reorganizando los valores en forma de matriz (con una dimensi√≥n tal que filas * columnas = longitud del vector), sabiendo que los elementos se van colocando por columnas (primeros valores en la primera columna, de arriba a abajo). z &lt;- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas) z ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 4 7 10 13 ## [2,] 2 5 8 11 14 ## [3,] 3 6 9 12 15 class(z) # Clase de la variable ## [1] &quot;matrix&quot; Dada una matriz x podemos darle vuelta (lo que se conoce como matriz transpuesta, donde filas pasan a ser columnas y viceversa) con la funci√≥n t(). x ## edades tlf cp ## [1,] 14 NA 33007 ## [2,] 24 683839390 28019 ## [3,] 56 621539732 37005 ## [4,] 31 618211286 18003 ## [5,] 20 NA 33091 ## [6,] 87 914727164 25073 ## [7,] 73 NA 17140 t(x) # Matriz transpuesta ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## edades 14 24 56 31 20 87 73 ## tlf NA 683839390 621539732 618211286 NA 914727164 NA ## cp 33007 28019 37005 18003 33091 25073 17140 "],["apply-vs-bucles.html", "5.2 Apply vs bucles", " 5.2 Apply vs bucles Si has programado en alg√∫n otro lenguaje, estar√°s echando en falta elementos como un if (blabla) {...} else {...} (que los usaremos a veces) o bucles for y while. ¬øNo existen los bucles en R? S√≠, s√≠ existen. He aqu√≠ un ejemplo. v &lt;- rep(0, 20) # Vector de 20 ceros for (i in 1:20) { # Bucle en base a un √≠ndice i que va de 1 a 20 v[i] &lt;- i^2 # En cada iteraci√≥n guardamos el valor de i al cuadrado en el elemento i del vector v } v ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 ## [20] 400 La raz√≥n por la que no hemos usado a√∫n bucles, e intentaremos evitarlos lo m√°ximo posible, es porque son muy ineficientes en tiempo de ejecuci√≥n. Vamos a poner un ejemplo. Supongamos que de la matriz x queremos calcular la suma de cada fila (es decir, 7 valores) o la suma de cada columna (3 valores). Con bucles ser√≠a as√≠. suma_por_filas &lt;- rep(0, dim(x)[1]) # dim(x)[1] n√∫mero de filas suma_por_cols &lt;- rep(0, dim(x)[2]) # dim(x)[2] n√∫mero de columnas for (i in 1:dim(x)[1]) { # Bucle recorriendo filas suma_por_filas[i] &lt;- sum(x[i, ], na.rm = TRUE) # Suma de la fila i, eliminando NA } suma_por_filas ## [1] 33021 683867433 621576793 618229320 33111 914752324 17213 for (j in 1:dim(x)[2]) { # Bucle recorriendo filas suma_por_cols[j] &lt;- sum(x[, j], na.rm = TRUE) # Suma de la columna j, eliminando NA } suma_por_cols ## [1] 305 2838317572 191338 En el c√≥digo anterior puedes ver como para acceder a la fila i-√©sima de la matriz se usa el operador [i, ] (dejando libre el √≠ndice de la columna), mientras que para acceder a la columna j-√©sima de la matriz se usa el operador [, j]. Para acceder al elemento (i, j) se usa el operador [i, j]. Tambi√©n habr√°s observado que, si escribes los bucles en tu script, tienen una flecha a la izquierda para ser minimizados. La pregunta es: ¬øno hay una forma m√°s eficiente de hacerlo? La respuesta: s√≠. La funci√≥n apply() nos permite ejecutar una funci√≥n por filas o por columnas. # Suma por filas (MARGIN = 1) quitando NA suma_por_filas &lt;- apply(x, MARGIN = 1, FUN = &quot;sum&quot;, na.rm = TRUE) suma_por_filas ## [1] 33021 683867433 621576793 618229320 33111 914752324 17213 # Una funci√≥n cualquiera por filas operacion_por_filas &lt;- apply(x, MARGIN = 1, FUN = function(x) { sum(sqrt(2) - 2) }) operacion_por_filas ## [1] -0.5857864 -0.5857864 -0.5857864 -0.5857864 -0.5857864 -0.5857864 -0.5857864 # Suma por columnas (MARGIN = 2) quitando NA suma_por_cols &lt;- apply(x, MARGIN = 2, FUN = &quot;sum&quot;, na.rm = TRUE) suma_por_cols ## edades tlf cp ## 305 2838317572 191338 Como puedes observar, necesitas tres argmentos y otros opcionales: la matriz, el √≠ndice por el que operar (MARGIN = 1 por filas, MARGIN = 2 por columnas) y la funci√≥n a aplicar, am√©n de otros argumentos extras que pudiera necesitar la funci√≥n. Veamos qu√© es m√°s eficiente con el ya conocido paquete {microbenchmark}. microbenchmark::microbenchmark(for (i in 1:dim(x)[1]) { suma_por_filas[i] &lt;- sum(x[i, ], na.rm = TRUE)}, apply(x, MARGIN = 1, FUN = &quot;sum&quot;, na.rm = TRUE), times = 1e2) # Comparamos tiempos de ejecuci√≥n de ambas formas, y lo repetimos 100 veces para sacar tiempos medios ## Unit: microseconds ## expr ## for (i in 1:dim(x)[1]) { suma_por_filas[i] &lt;- sum(x[i, ], na.rm = TRUE) } ## apply(x, MARGIN = 1, FUN = &quot;sum&quot;, na.rm = TRUE) ## min lq mean median uq max neval cld ## 1647.750 1698.9235 1956.5178 1802.896 2029.3400 5223.842 100 b ## 20.091 26.0675 35.3532 34.876 41.0475 87.760 100 a ¬°El bucle nos tarda 50 veces m√°s que el apply! Di no a los bucles: casi siempre hay una forma mejor de hacerlo. "],["tablas-data.html", "5.3 Tablas: data.frames", " 5.3 Tablas: data.frames Adem√°s del nombre de las columnas que ha heredado la matriz x de la concatenaci√≥n de las columnas que hemos realizado, podemos poner nombre a los registros, por ejemplo, el nombre de las personas a las que pertenece cada dato, definiendo una nueva variable con los nombres y concaten√°ndola. nombres &lt;- c(&quot;Sonia&quot;, &quot;Carla&quot;, &quot;Pepito&quot;, &quot;Carlos&quot;, &quot;Lara&quot;, &quot;Sandra&quot;, &quot;Javi&quot;) cbind(nombres, x) ## nombres edades tlf cp ## [1,] &quot;Sonia&quot; &quot;14&quot; NA &quot;33007&quot; ## [2,] &quot;Carla&quot; &quot;24&quot; &quot;683839390&quot; &quot;28019&quot; ## [3,] &quot;Pepito&quot; &quot;56&quot; &quot;621539732&quot; &quot;37005&quot; ## [4,] &quot;Carlos&quot; &quot;31&quot; &quot;618211286&quot; &quot;18003&quot; ## [5,] &quot;Lara&quot; &quot;20&quot; NA &quot;33091&quot; ## [6,] &quot;Sandra&quot; &quot;87&quot; &quot;914727164&quot; &quot;25073&quot; ## [7,] &quot;Javi&quot; &quot;73&quot; NA &quot;17140&quot; ¬øHas visto lo que ha sucedido? Como una matriz SOLO puede tener un tipo de dato, al a√±adir una variable de tipo textos, ha convertido los n√∫meros tambi√©n a texto poni√©ndole comillas: hemos roto la integridad de nuestro dato. Una forma de a√±adir nombre a los registros, sin incluirlo como variable, es usando la funci√≥n row.names(). row.names(x) &lt;- c(&quot;Sonia&quot;, &quot;Carla&quot;, &quot;Pepito&quot;, &quot;Carlos&quot;, &quot;Lara&quot;, &quot;Sandra&quot;, &quot;Javi&quot;) x ## edades tlf cp ## Sonia 14 NA 33007 ## Carla 24 683839390 28019 ## Pepito 56 621539732 37005 ## Carlos 31 618211286 18003 ## Lara 20 NA 33091 ## Sandra 87 914727164 25073 ## Javi 73 NA 17140 ¬øQu√© sucede si realmente queremos a√±adir variables cuyos tipos sean distintos (¬°ojo, pero con la misma longitud!)? Vamos a crear nuevas variables de texto nombres y apellidos, un valor l√≥gico casado y una fecha fecha_creacion (fecha de entrada en el sistema) para cada persona. # Nombres nombres &lt;- c(&quot;Sonia&quot;, &quot;Carla&quot;, &quot;Pepito&quot;, &quot;Carlos&quot;, &quot;Lara&quot;, &quot;Sandra&quot;, &quot;Javi&quot;) # Apellidos apellidos &lt;- c(&quot;P√©rez&quot;, &quot;Gonz√°lez&quot;, &quot;Fern√°ndez&quot;, &quot;Mart√≠nez&quot;, &quot;Li√©bana&quot;, &quot;Garc√≠a&quot;, &quot;Ortiz&quot;) # Estado civil (no lo sabemos de una persona) casado &lt;- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE) # Fecha de creaci√≥n (fecha en el que esa persona entra en el sistema) # lo convertimos a tipo fecha fecha_creacion &lt;- as.Date(c(&quot;2021-03-04&quot;, &quot;2020-10-12&quot;, &quot;1990-04-05&quot;, &quot;2019-09-10&quot;, &quot;2017-03-21&quot;, &quot;2020-07-07&quot;, &quot;2000-01-28&quot;)) Seguimos teniendo 7 registros, uno por persona pero ahora tenemos un popurr√≠ de variables, de la misma longitud pero de tipos distintos: (edades, tlf, cp) son variables num√©ricas. (nombres, apellidos) son variables de texto. casado es una variable l√≥gica. fecha_creacion de tipo fecha. ¬øQu√© suceder√≠a si yo intento mezclar todo en una matriz? # Juntamos todo en una matriz (juntamos por columnas) x &lt;- cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion) x ## nombres apellidos edades tlf cp casado fecha_creacion ## [1,] &quot;Sonia&quot; &quot;P√©rez&quot; &quot;14&quot; NA &quot;33007&quot; &quot;TRUE&quot; &quot;18690&quot; ## [2,] &quot;Carla&quot; &quot;Gonz√°lez&quot; &quot;24&quot; &quot;683839390&quot; &quot;28019&quot; &quot;FALSE&quot; &quot;18547&quot; ## [3,] &quot;Pepito&quot; &quot;Fern√°ndez&quot; &quot;56&quot; &quot;621539732&quot; &quot;37005&quot; &quot;FALSE&quot; &quot;7399&quot; ## [4,] &quot;Carlos&quot; &quot;Mart√≠nez&quot; &quot;31&quot; &quot;618211286&quot; &quot;18003&quot; NA &quot;18149&quot; ## [5,] &quot;Lara&quot; &quot;Li√©bana&quot; &quot;20&quot; NA &quot;33091&quot; &quot;TRUE&quot; &quot;17246&quot; ## [6,] &quot;Sandra&quot; &quot;Garc√≠a&quot; &quot;87&quot; &quot;914727164&quot; &quot;25073&quot; &quot;FALSE&quot; &quot;18450&quot; ## [7,] &quot;Javi&quot; &quot;Ortiz&quot; &quot;73&quot; NA &quot;17140&quot; &quot;FALSE&quot; &quot;10984&quot; Efectivamente: como en una matriz solo puede haber datos de un tipo, los n√∫meros los convierte a texto, las variables l√≥gicas las convierte a texto (TRUE es un valor l√≥gico, &quot;TRUE&quot; es un texto, como &quot;Pepito&quot;, sin significado l√≥gico - booleano - de verdadero/falso) y las fechas las ha convertido a texto (aunque las veas igual, ya no son de tipo de fecha, son texto y no podemos operar con ellas). # D√≠as entre la primera y el segundo elemento de fecha de creaci√≥n fecha_creacion[1] - fecha_creacion[2] ## Time difference of 143 days # D√≠as entre primera y segunda fecha de creaci√≥n pero tom√°ndolo de nuestra matriz (columna 7, fila 1 y 2) x[1, 7] - x[2, 7] ## Error in x[1, 7] - x[2, 7]: argumento no-num√©rico para operador binario He aqu√≠ LA pregunta: ¬øc√≥mo juntar variables de distinto tipo, sin cambiar su naturaleza, como cuando juntamos datos en una tabla de excel? El formato de tabla de datos en R que vamos a empezar a usar se llama data.frame: una colecci√≥n de variables de igual longitud pero cada una de un tipo distinto. Para crear un objeto de este tipo basta con usar la funci√≥n data.frame(), pas√°ndole como argumentos (separados por comas) las variables que queremos reunir, indicando en texto &quot;...&quot; el nombre de las columnas. # Creamos nuestro primer data.frame tabla &lt;- data.frame(&quot;Nombre&quot; = nombres, &quot;Apellido&quot; = apellidos, &quot;Edad&quot; = edades, &quot;Tel√©fono&quot; = tlf, &quot;C√≥digo Postal&quot; = cp, &quot;Casado&quot; = casado, &quot;Fecha_de_creaci√≥n&quot; = fecha_creacion) tabla ## Nombre Apellido Edad Tel√©fono C√≥digo.Postal Casado Fecha_de_creaci√≥n ## 1 Sonia P√©rez 14 NA 33007 TRUE 2021-03-04 ## 2 Carla Gonz√°lez 24 683839390 28019 FALSE 2020-10-12 ## 3 Pepito Fern√°ndez 56 621539732 37005 FALSE 1990-04-05 ## 4 Carlos Mart√≠nez 31 618211286 18003 NA 2019-09-10 ## 5 Lara Li√©bana 20 NA 33091 TRUE 2017-03-21 ## 6 Sandra Garc√≠a 87 914727164 25073 FALSE 2020-07-07 ## 7 Javi Ortiz 73 NA 17140 FALSE 2000-01-28 ¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS! 5.3.1 Data.frames: selecci√≥n manual de columnas y filas Si tenemos un data.frame ya creado y queremos a√±adir una columna es tan simple como usar la funci√≥n data.frame() que ya hemos visto para concatenar la columna. Si queremos acceder a una columna, fila o elemento en concreto, los data.frame tienes las mismas ventajas que una matriz, as√≠ basta con usar los mismos operadores. # A√±adimos una nueva columna con n¬∫ de hermanos/as hermanos &lt;- c(0, 0, 1, 5, 2, 3, 0) tabla &lt;- data.frame(tabla, hermanos) tabla ## Nombre Apellido Edad Tel√©fono C√≥digo.Postal Casado Fecha_de_creaci√≥n ## 1 Sonia P√©rez 14 NA 33007 TRUE 2021-03-04 ## 2 Carla Gonz√°lez 24 683839390 28019 FALSE 2020-10-12 ## 3 Pepito Fern√°ndez 56 621539732 37005 FALSE 1990-04-05 ## 4 Carlos Mart√≠nez 31 618211286 18003 NA 2019-09-10 ## 5 Lara Li√©bana 20 NA 33091 TRUE 2017-03-21 ## 6 Sandra Garc√≠a 87 914727164 25073 FALSE 2020-07-07 ## 7 Javi Ortiz 73 NA 17140 FALSE 2000-01-28 ## hermanos ## 1 0 ## 2 0 ## 3 1 ## 4 5 ## 5 2 ## 6 3 ## 7 0 # Accedemos a la tercera columna tabla[, 3] ## [1] 14 24 56 31 20 87 73 # Accedemos a la quinta fila tabla[5, ] ## Nombre Apellido Edad Tel√©fono C√≥digo.Postal Casado Fecha_de_creaci√≥n hermanos ## 5 Lara Li√©bana 20 NA 33091 TRUE 2017-03-21 2 # Accedemos a la tercera variable del quinto registro tabla[5, 3] ## [1] 20 Un data.frame no solo tiene las ventajas de una matriz sino que tambi√©n tiene las ventajas de una tabla de datos. Por ejemplo, podemos aceder a las variables por el √≠ndice de columna que ocupan pero tambi√©n por su nombre, poniendo el nombre de la tabla, el s√≠mbolo $ y con el tabulador nos aparecer√° un men√∫ de columnas a elegir. Imagen/gr√°fica 5.1: Men√∫ desplegable de variables (columnas) de un data.frame. Volvamos a nuestro script. Vamos a crear un script nuevo en la caprta CODIGOS de nuestro proyecto que se llame primer_data_frame.R. En √©l vamos a definir las variables que hab√≠amos lanzado en consola, y vamos a construir el mismo data.frame llamado tabla que ten√≠amos pero en nuestro script. Imagen/gr√°fica 5.2: Creando nuestro primer data.frame en el script. # Descripci√≥n: creaci√≥n de nuestros primeros data.frame # Variables edades &lt;- c(14, 24, 56, 31, 20, 87, 73) # vector num√©rico de longitud 7 tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA) cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073, 17140) nombres &lt;- c(&quot;Sonia&quot;, &quot;Carla&quot;, &quot;Pepito&quot;, &quot;Carlos&quot;, &quot;Lara&quot;, &quot;Sandra&quot;, &quot;Javi&quot;) apellidos &lt;- c(&quot;P√©rez&quot;, &quot;Gonz√°lez&quot;, &quot;Fern√°ndez&quot;, &quot;Mart√≠nez&quot;, &quot;Li√©bana&quot;, &quot;Garc√≠a&quot;, &quot;Ortiz&quot;) casado &lt;- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE) fecha_creacion &lt;- as.Date(c(&quot;2021-03-04&quot;, &quot;2020-10-12&quot;, &quot;1990-04-05&quot;, &quot;2019-09-10&quot;, &quot;2017-03-21&quot;, &quot;2020-07-07&quot;, &quot;2000-01-28&quot;)) hermanos &lt;- c(0, 0, 1, 5, 2, 3, 0) # Creamos el data.frame tabla &lt;- data.frame(&quot;Nombre&quot; = nombres, &quot;Apellido&quot; = apellidos, &quot;Edad&quot; = edades, &quot;Tel√©fono&quot; = tlf, &quot;C√≥digo Postal&quot; = cp, &quot;Casado&quot; = casado, &quot;Fecha_de_creaci√≥n&quot; = fecha_creacion) tabla &lt;- data.frame(tabla, hermanos) tabla ## Nombre Apellido Edad Tel√©fono C√≥digo.Postal Casado Fecha_de_creaci√≥n ## 1 Sonia P√©rez 14 NA 33007 TRUE 2021-03-04 ## 2 Carla Gonz√°lez 24 683839390 28019 FALSE 2020-10-12 ## 3 Pepito Fern√°ndez 56 621539732 37005 FALSE 1990-04-05 ## 4 Carlos Mart√≠nez 31 618211286 18003 NA 2019-09-10 ## 5 Lara Li√©bana 20 NA 33091 TRUE 2017-03-21 ## 6 Sandra Garc√≠a 87 914727164 25073 FALSE 2020-07-07 ## 7 Javi Ortiz 73 NA 17140 FALSE 2000-01-28 ## hermanos ## 1 0 ## 2 0 ## 3 1 ## 4 5 ## 5 2 ## 6 3 ## 7 0 Imagen/gr√°fica 5.3: Llamando a nuestro script desde nuestro c√≥digo principal. Adem√°s de dicho conjunto de datos, vamos a instalar (sino lo hemos hecho nunca en este ordenador) un paquete muy √∫til en R llamado {datasets}. Los paquetes que vayamos necesitando los instalaremos y llamaremos al inicio del c√≥digo principal. Imagen/gr√°fica 5.4: Instalamos y cargamos los paquetes necesarios al principio de nuestro main.R. # Paquetes necesarios # install.packages(&quot;datasets&quot;) # Descomentar si nunca se ha instalado library(datasets) Tras ello llamaremos a nuestro script primer_data_frame.R desde nuestro c√≥digo principal main.R y guardaremos el script con el source on save activado para que se ejecute. Adem√°s de que ahora tenemos nuestro conjunto de datos tabla en nuestro panel de entorno, si escribimos datasets:: y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usados: el paquete datasets nos proporciona data.frames de prueba para que podamos usarlos en nuestros c√≥digos seg√∫n vamos aprendiendo. Imagen/gr√°fica 5.5: Men√∫ desplegable con los data.frame de prueba en datasets Una de las ventajas de los data.frame es que podemos visualizarlos como si fuera una tabla de Excel dentro de nuestro R con la funci√≥n View(). Vamos a visualizar no solo el conjunto de datos tabla sino tambi√©n el conjunto iris del paquete datasets: los data.frame nos permiten trabajar con ellos como bases de datos o como matrices, con las ventajas de ambos. View(iris) View(tabla) Imagen/gr√°fica 5.6: Men√∫ desplegable con los data.frame de prueba en datasets En el caso de los data.frame tenemos adem√°s a nuestro disposici√≥n una herramienta muy potente: la funci√≥n subset() Dicha funci√≥n nos va a permitir seleccionar filas y columnas autom√°ticamente, tomando de entrada los siguientes argumentos x: una tabla de entrada, un data.frame de entrada. subset: la condici√≥n l√≥gica que queramos usar para seleccionar registros (filas). select: un vector que contenga el nombre de las columnas que queremos seleccionar (a lo mejor solo queremos filtrar por filas pero quiz√°s tambi√©n por columnas). Por ejemplo, vamos a seleccionar solo los nombres y apellidos de aquellas personas mayores de edad de nuestro conjunto de datos tabla, y del conjunto iris vamos a extraer todos los registros en los que el largo del s√©palo es mayor que 7.1, seleccionando solo las columnas de longitud de s√©palo y la especie de la planta. subset(tabla, subset = Edad &gt; 18, select = c(&quot;Nombre&quot;, &quot;Apellido&quot;)) ## Nombre Apellido ## 2 Carla Gonz√°lez ## 3 Pepito Fern√°ndez ## 4 Carlos Mart√≠nez ## 5 Lara Li√©bana ## 6 Sandra Garc√≠a ## 7 Javi Ortiz subset(iris, subset = Sepal.Length &gt; 7.1, select = c(&quot;Sepal.Length&quot;, &quot;Species&quot;)) ## Sepal.Length Species ## 106 7.6 virginica ## 108 7.3 virginica ## 110 7.2 virginica ## 118 7.7 virginica ## 119 7.7 virginica ## 123 7.7 virginica ## 126 7.2 virginica ## 130 7.2 virginica ## 131 7.4 virginica ## 132 7.9 virginica ## 136 7.7 virginica "],["consejos-y-tips-4.html", "5.4 Consejos y tips", " 5.4 Consejos y tips Acceso a librer√≠a A veces puede que no queramos cargar todo un paquete sino solo una funci√≥n del mismo, para lo que es suficiente nombre_paquete::nombre_funcion. Nombre de variables La funci√≥n names() no solo sirve para consultar los nombres de las variables de un data.frame sino tambi√©n para cambiarlos a nuestro gusto. # Consultamos nombres names(tabla) ## [1] &quot;Nombre&quot; &quot;Apellido&quot; &quot;Edad&quot; ## [4] &quot;Tel√©fono&quot; &quot;C√≥digo.Postal&quot; &quot;Casado&quot; ## [7] &quot;Fecha_de_creaci√≥n&quot; &quot;hermanos&quot; # Cambiamos nombres names(tabla) &lt;- c(&quot;nombre_persona&quot;, &quot;apellido_persona&quot;, &quot;edad&quot;, &quot;tlf&quot;, &quot;cp&quot;, &quot;casado&quot;, &quot;f_creacion&quot;) tabla ## nombre_persona apellido_persona edad tlf cp casado f_creacion NA ## 1 Sonia P√©rez 14 NA 33007 TRUE 2021-03-04 0 ## 2 Carla Gonz√°lez 24 683839390 28019 FALSE 2020-10-12 0 ## 3 Pepito Fern√°ndez 56 621539732 37005 FALSE 1990-04-05 1 ## 4 Carlos Mart√≠nez 31 618211286 18003 NA 2019-09-10 5 ## 5 Lara Li√©bana 20 NA 33091 TRUE 2017-03-21 2 ## 6 Sandra Garc√≠a 87 914727164 25073 FALSE 2020-07-07 3 ## 7 Javi Ortiz 73 NA 17140 FALSE 2000-01-28 0 Paquete {tibble} En dicho paquete tienes m√°s funciones para una gesti√≥n m√°s √°gil, eficiente y coherente de los data.frame. Ver https://tibble.tidyverse.org/. "],["ejercicios-2.html", "5.5 üìù Ejercicios", " 5.5 üìù Ejercicios Ejercicio 1: define una matriz de ceros de 3 filas y 7 columnas. Tras hacerlo calcula su transpuesta y obt√©n sus dimensiones Soluci√≥n: # Matriz matriz &lt;- matrix(0, nrow = 3, ncol = 7) # Transpuesta t(matriz) ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 ## [4,] 0 0 0 ## [5,] 0 0 0 ## [6,] 0 0 0 ## [7,] 0 0 0 # Dimensiones transpuesta dim(t(matriz)) ## [1] 7 3 ncol(t(matriz)) ## [1] 3 nrow(t(matriz)) ## [1] 7 Ejercicio 2: calcula la suma de cada fila de la matriz matriz &lt;- matrix(1:12, nrow = 4) usando un bucle. Haz lo mismo evitando usar bucles. Soluci√≥n: # Matriz matriz &lt;- matrix(1:12, nrow = 4) # Con bucle (recorremos sus filas) suma &lt;- rep(0, nrow(matriz)) # Definimos un vector de 0&#39;s con tantos elementos como filas, donde iremos metiendo los valores de la suma for (i in 1:nrow(matriz)) { suma[i] &lt;- sum(matriz[i, ]) # Sumamos la fila i } suma ## [1] 15 18 21 24 # Sin bucle (MARGIN = 1 ya que es una operaci√≥n por filas) suma &lt;- apply(matriz, MARGIN = 1, FUN = &quot;sum&quot;) suma ## [1] 15 18 21 24 Ejercicio 3: del conjunto iris del paquete datasets obt√©n el nombre de las variables, y selecciona aquellas filas cuya variable Petal.Width sea distinta de 0.2, y qu√©date solo con las variables Sepal.Length, Sepal.Width y Species. Calcula el n√∫mero de filas borradas. Tras hacer todo ello, traduce a castellano el nombre de las columnas del data.frame filtrado. Soluci√≥n: # Nombres de variables names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; # Filtramos filas filtro_fila &lt;- subset(iris, subset = Petal.Width != 0.2) # Filtramos columnas filtro_col &lt;- subset(filtro_fila, select = c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;, &quot;Species&quot;)) # Todo de una vez filtro &lt;- subset(iris, subset = Petal.Width != 0.2, select = c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;, &quot;Species&quot;)) filtro ## Sepal.Length Sepal.Width Species ## 6 5.4 3.9 setosa ## 7 4.6 3.4 setosa ## 10 4.9 3.1 setosa ## 13 4.8 3.0 setosa ## 14 4.3 3.0 setosa ## 16 5.7 4.4 setosa ## 17 5.4 3.9 setosa ## 18 5.1 3.5 setosa ## 19 5.7 3.8 setosa ## 20 5.1 3.8 setosa ## 22 5.1 3.7 setosa ## 24 5.1 3.3 setosa ## 27 5.0 3.4 setosa ## 32 5.4 3.4 setosa ## 33 5.2 4.1 setosa ## 38 4.9 3.6 setosa ## 41 5.0 3.5 setosa ## 42 4.5 2.3 setosa ## 44 5.0 3.5 setosa ## 45 5.1 3.8 setosa ## 46 4.8 3.0 setosa ## 51 7.0 3.2 versicolor ## 52 6.4 3.2 versicolor ## 53 6.9 3.1 versicolor ## 54 5.5 2.3 versicolor ## 55 6.5 2.8 versicolor ## 56 5.7 2.8 versicolor ## 57 6.3 3.3 versicolor ## 58 4.9 2.4 versicolor ## 59 6.6 2.9 versicolor ## 60 5.2 2.7 versicolor ## 61 5.0 2.0 versicolor ## 62 5.9 3.0 versicolor ## 63 6.0 2.2 versicolor ## 64 6.1 2.9 versicolor ## 65 5.6 2.9 versicolor ## 66 6.7 3.1 versicolor ## 67 5.6 3.0 versicolor ## 68 5.8 2.7 versicolor ## 69 6.2 2.2 versicolor ## 70 5.6 2.5 versicolor ## 71 5.9 3.2 versicolor ## 72 6.1 2.8 versicolor ## 73 6.3 2.5 versicolor ## 74 6.1 2.8 versicolor ## 75 6.4 2.9 versicolor ## 76 6.6 3.0 versicolor ## 77 6.8 2.8 versicolor ## 78 6.7 3.0 versicolor ## 79 6.0 2.9 versicolor ## 80 5.7 2.6 versicolor ## 81 5.5 2.4 versicolor ## 82 5.5 2.4 versicolor ## 83 5.8 2.7 versicolor ## 84 6.0 2.7 versicolor ## 85 5.4 3.0 versicolor ## 86 6.0 3.4 versicolor ## 87 6.7 3.1 versicolor ## 88 6.3 2.3 versicolor ## 89 5.6 3.0 versicolor ## 90 5.5 2.5 versicolor ## 91 5.5 2.6 versicolor ## 92 6.1 3.0 versicolor ## 93 5.8 2.6 versicolor ## 94 5.0 2.3 versicolor ## 95 5.6 2.7 versicolor ## 96 5.7 3.0 versicolor ## 97 5.7 2.9 versicolor ## 98 6.2 2.9 versicolor ## 99 5.1 2.5 versicolor ## 100 5.7 2.8 versicolor ## 101 6.3 3.3 virginica ## 102 5.8 2.7 virginica ## 103 7.1 3.0 virginica ## 104 6.3 2.9 virginica ## 105 6.5 3.0 virginica ## 106 7.6 3.0 virginica ## 107 4.9 2.5 virginica ## 108 7.3 2.9 virginica ## 109 6.7 2.5 virginica ## 110 7.2 3.6 virginica ## 111 6.5 3.2 virginica ## 112 6.4 2.7 virginica ## 113 6.8 3.0 virginica ## 114 5.7 2.5 virginica ## 115 5.8 2.8 virginica ## 116 6.4 3.2 virginica ## 117 6.5 3.0 virginica ## 118 7.7 3.8 virginica ## 119 7.7 2.6 virginica ## 120 6.0 2.2 virginica ## 121 6.9 3.2 virginica ## 122 5.6 2.8 virginica ## 123 7.7 2.8 virginica ## 124 6.3 2.7 virginica ## 125 6.7 3.3 virginica ## 126 7.2 3.2 virginica ## 127 6.2 2.8 virginica ## 128 6.1 3.0 virginica ## 129 6.4 2.8 virginica ## 130 7.2 3.0 virginica ## 131 7.4 2.8 virginica ## 132 7.9 3.8 virginica ## 133 6.4 2.8 virginica ## 134 6.3 2.8 virginica ## 135 6.1 2.6 virginica ## 136 7.7 3.0 virginica ## 137 6.3 3.4 virginica ## 138 6.4 3.1 virginica ## 139 6.0 3.0 virginica ## 140 6.9 3.1 virginica ## 141 6.7 3.1 virginica ## 142 6.9 3.1 virginica ## 143 5.8 2.7 virginica ## 144 6.8 3.2 virginica ## 145 6.7 3.3 virginica ## 146 6.7 3.0 virginica ## 147 6.3 2.5 virginica ## 148 6.5 3.0 virginica ## 149 6.2 3.4 virginica ## 150 5.9 3.0 virginica # Filas borradas nrow(iris) - nrow(filtro) ## [1] 29 # Cambiamos nombres a castellano del conjunto filtrado names(filtro) &lt;- c(&quot;longitud_sepalo&quot;, &quot;anchura_sepalo&quot;, &quot;especies&quot;) "],["importar_exportar.html", "Cap√≠tulo 6 Importando/exportando", " Cap√≠tulo 6 Importando/exportando Hemos aprendido a crear nuestros propios datos pero la mayor√≠a de veces los cargaremos de distintos archivos, fuentes, etc. Vamos a ver las 4 formas m√°s comunes de importar (cargar) datos "],["importaci√≥n-de-datos.html", "6.1 Importaci√≥n de datos", " 6.1 Importaci√≥n de datos Las 4 formas m√°s comunes de importar (cargar) datos son: desde un archivo propio de R (extensi√≥n .RData). desde un archivo separado por comas (un archivo .csv). desde un excel (archivo .xlsx). desde un enlace de internet. 6.1.1 Archivo .RData La forma m√°s sencilla de guardar datos y variables en R, y que adem√°s ocupa menos espacio en nuestro disco duro, es guardarlo en archivos propios que tiene R como son los archivos con extensiones .rda y .RData. Es recomendable tener los datos en la misma carpeta del proyecto pero una carpeta separada, ya que podemos tener muchos archivos y as√≠ no mezclamos dichos ficheros con los c√≥digos que escirbamos. En la carpeta DATOS del proyecto tenemos 4 archivos .RData: coches.RData, panel_vacunas_ccaa.RData, panel_vacunas_fecha.RData y panel_variables.RData. ¬øC√≥mo cargar archivos .RData? Muy sencillo: como son ficheros nativos de R, basta con usar la funci√≥n de carga load(), y dentro la ruta de los archivos. # Al fijar directorio de trabajo, no necesitamos toda la ruta, solo &quot;./&quot; y la ruta dentro de la carpeta del proyecto load(&quot;./DATOS/coches.RData&quot;) load(&quot;./DATOS/panel_vacunas_ccaa.RData&quot;) load(&quot;./DATOS/panel_vacunas_fecha.RData&quot;) load(&quot;./DATOS/panel_variables.RData&quot;) Imagen/gr√°fica 6.1: Importaci√≥n de ficheros de extensi√≥n .RData. Como ves en la imagen 6.1, en el panel de entorno de la parte superior derecha ahora tendremos 4 data.frames que antes no ten√≠amos. Un funci√≥n muy √∫til es head(), con argumento el nombre de un data.frame, que nos permite visualizar las primeras columnas. # Ver las primeras filas de la tabla que guarda distintos modelos de coche y caracter√≠sticas head(coches) ## consumo cilindrada peso potencia tiempo ## Mazda RX4 11.20069 2621.936 1188.411 111.52570 40.91298 ## Mazda RX4 Wag 11.20069 2621.936 1304.077 111.52570 42.30491 ## Datsun 710 10.31643 1769.807 1052.333 94.28991 46.25702 ## Hornet 4 Drive 10.99134 4227.872 1458.298 111.52570 48.32006 ## Hornet Sportabout 12.57832 5899.356 1560.356 177.42725 42.30491 ## Valiant 12.99528 3687.097 1569.428 106.45635 50.25883 ## motor transmision ncyl ncarb ngear ## Mazda RX4 cilindros en V Manual 6 4 4 ## Mazda RX4 Wag cilindros en V Manual 6 4 4 ## Datsun 710 cilindros en serie Manual 4 1 4 ## Hornet 4 Drive cilindros en serie Autom√°tica 6 1 3 ## Hornet Sportabout cilindros en V Autom√°tica 8 2 3 ## Valiant cilindros en serie Autom√°tica 6 1 3 6.1.2 Archivo .csv Otra opci√≥n de importaci√≥n habitual son los archivos .csv (comma separated values): son archivos separados por comas (u otro caracter como puntos, puntos y comas, o tabuladores). En apariencia cuando los abrimos en el ordenador son como un Excel (ya que los abre el Excel), pero ocupan mucho menos que un Excel y su lectura es universal (independiente de tener instalado o no el Excel) ya que son archivos de texto sin formato. Para leer un archivo .csv basta con usar la funci√≥n read.csv(), y la mayor√≠a de las veces basta indicarle la ruta del archivo para su lectura (argumento file). vacunas_esp &lt;- read.csv(file = &quot;./DATOS/datos_ES.csv&quot;) names(vacunas_esp) # Todas las variables del data.frame ## [1] &quot;fechas&quot; ## [2] &quot;ISO&quot; ## [3] &quot;poblacion&quot; ## [4] &quot;porc_pobl_total&quot; ## [5] &quot;poblacion_mayor_16a&quot; ## [6] &quot;porc_pobl_total_mayor_16a&quot; ## [7] &quot;dosis_entrega_pfizer&quot; ## [8] &quot;dosis_entrega_astra&quot; ## [9] &quot;dosis_entrega_moderna&quot; ## [10] &quot;dosis_entrega_janssen&quot; ## [11] &quot;dosis_entrega&quot; ## [12] &quot;dosis_entrega_100hab&quot; ## [13] &quot;porc_entregadas_sobre_total&quot; ## [14] &quot;dosis_diarias_entrega_pfizer&quot; ## [15] &quot;dosis_diarias_entrega_astra&quot; ## [16] &quot;dosis_diarias_entrega_moderna&quot; ## [17] &quot;dosis_diarias_entrega&quot; ## [18] &quot;dosis_7D_entrega_pfizer&quot; ## [19] &quot;dosis_7D_entrega_astra&quot; ## [20] &quot;dosis_7D_entrega_moderna&quot; ## [21] &quot;dosis_7D_entrega&quot; ## [22] &quot;dosis_7D_entrega_100hab&quot; ## [23] &quot;dosis_admin&quot; ## [24] &quot;dosis_primera&quot; ## [25] &quot;dosis_pauta_completa&quot; ## [26] &quot;dosis_admin_100hab&quot; ## [27] &quot;porc_admin_sobre_ccaa&quot; ## [28] &quot;porc_admin_vs_total&quot; ## [29] &quot;dosis_diarias_admin&quot; ## [30] &quot;dosis_diarias_admin_100hab&quot; ## [31] &quot;crec_diario_dosis_admin&quot; ## [32] &quot;dosis_diarias_primera&quot; ## [33] &quot;dosis_diarias_segunda&quot; ## [34] &quot;dosis_7D_admin&quot; ## [35] &quot;dosis_7D_admin_100hab&quot; ## [36] &quot;crec_7D_dosis_admin&quot; ## [37] &quot;porc_admin_vs_total_7D&quot; ## [38] &quot;personas_vacunadas&quot; ## [39] &quot;personas_pauta_completa&quot; ## [40] &quot;personas_1dosis&quot; ## [41] &quot;porc_personas_vacunadas&quot; ## [42] &quot;porc_personas_pauta_completa&quot; ## [43] &quot;porc_personas_vacunadas_16a&quot; ## [44] &quot;porc_personas_pauta_completa_16a&quot; ## [45] &quot;personas_vacunadas_diarias&quot; ## [46] &quot;personas_pauta_completa_diarias&quot; ## [47] &quot;porc_personas_vacunadas_diarias&quot; ## [48] &quot;porc_personas_pauta_completa_diarias&quot; ## [49] &quot;personas_vacunadas_7D&quot; ## [50] &quot;personas_pauta_completa_7D&quot; ## [51] &quot;porc_personas_vacunadas_7D&quot; ## [52] &quot;porc_personas_pauta_completa_7D&quot; ## [53] &quot;porc_personas_vacunadas_16a_7D&quot; ## [54] &quot;porc_personas_pauta_completa_16a_7D&quot; ## [55] &quot;crec_diario_personas_vacunadas&quot; ## [56] &quot;crec_7D_personas_vacunadas&quot; ## [57] &quot;crec_diario_personas_pauta_completa&quot; ## [58] &quot;crec_7D_personas_pauta_completa&quot; ## [59] &quot;desv_porc_admin_vs_total&quot; ## [60] &quot;desv_dosis_entrega&quot; ## [61] &quot;desv_porc_personas_vacunadas&quot; ## [62] &quot;desv_porc_personas_pauta_completa&quot; ## [63] &quot;fecha_30vacunados_ritmo7D&quot; ## [64] &quot;fecha_50vacunados_ritmo7D&quot; ## [65] &quot;fecha_70vacunados_ritmo7D&quot; ## [66] &quot;fecha_30inmunizados_ritmo7D&quot; ## [67] &quot;fecha_50inmunizados_ritmo7D&quot; ## [68] &quot;fecha_70inmunizados_ritmo7D&quot; ## [69] &quot;fecha_30inmunizados_16a_ritmo7D&quot; ## [70] &quot;fecha_50inmunizados_16a_ritmo7D&quot; ## [71] &quot;fecha_70inmunizados_16a_ritmo7D&quot; vacunas_esp[1:5, 1:7] # Primeras filas y columnas ## fechas ISO poblacion porc_pobl_total poblacion_mayor_16a ## 1 2021-01-05 ES 47450795 100 40129822 ## 2 2021-01-06 ES 47450795 100 40129822 ## 3 2021-01-07 ES 47450795 100 40129822 ## 4 2021-01-08 ES 47450795 100 40129822 ## 5 2021-01-09 ES 47450795 100 40129822 ## porc_pobl_total_mayor_16a dosis_entrega_pfizer ## 1 100 743925 ## 2 100 743925 ## 3 100 743925 ## 4 100 743925 ## 5 100 743925 Podemos personalizar la lectura en funci√≥n del archivo, dando valores a los argumentos sep (para indicar el caracter que se est√° usando para separar columnas, en caso de no ser &quot;,&quot; por defecto), dec (el caracter que esdtamos usando para marcar decimales, por defecto es &quot;.&quot;) o header (por defecto en TRUE, lo que le indicamos que el nombre de las columnas est√° en la primera fila). Al tener nuestro archivo preparado para que sirva con los par√°metros por defecto no debemos a√±adirlo, pero podemos hacer la prueba para ver que la lectura es la misma. vacunas_esp &lt;- read.csv(file = &quot;./DATOS/datos_ES.csv&quot;, sep = &quot;,&quot;, dec = &quot;.&quot;, header = TRUE) vacunas_esp[1:5, 1:7] # Primeras filas y columnas ## fechas ISO poblacion porc_pobl_total poblacion_mayor_16a ## 1 2021-01-05 ES 47450795 100 40129822 ## 2 2021-01-06 ES 47450795 100 40129822 ## 3 2021-01-07 ES 47450795 100 40129822 ## 4 2021-01-08 ES 47450795 100 40129822 ## 5 2021-01-09 ES 47450795 100 40129822 ## porc_pobl_total_mayor_16a dosis_entrega_pfizer ## 1 100 743925 ## 2 100 743925 ## 3 100 743925 ## 4 100 743925 ## 5 100 743925 6.1.3 Archivo .xlsx Muchas veces no tendremos un .csv (por desgracia) y nos tocar√° leer desde un excel. Para ello deberemos instalar (la primera vez) y cargar el paquete {readxl} que nos permitir√° usar funciones para cargar archivos .xls (la funci√≥n read_xls()) y archivos .xlsx (la funci√≥n read_xlsx()). Adem√°s del argumento path con la ruta del archivo, podemos en el argumento sheet indicarle la hoja de Excel a leer (en caso de tener varias). install.packages(&quot;readxl&quot;) library(readxl) boston &lt;- read_xlsx(path = &quot;./DATOS/Boston.xlsx&quot;) head(boston) ## # A tibble: 6 √ó 14 ## crim zn indus chas nox rm age dis rad tax ptratio black ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.00632 18 2.31 0 0.538 6.58 65.2 4.09 1 296 15.3 397. ## 2 0.0273 0 7.07 0 0.469 6.42 78.9 4.97 2 242 17.8 397. ## 3 0.0273 0 7.07 0 0.469 7.18 61.1 4.97 2 242 17.8 393. ## 4 0.0324 0 2.18 0 0.458 7.00 45.8 6.06 3 222 18.7 395. ## 5 0.0690 0 2.18 0 0.458 7.15 54.2 6.06 3 222 18.7 397. ## 6 0.0298 0 2.18 0 0.458 6.43 58.7 6.06 3 222 18.7 394. ## # ‚Ä¶ with 2 more variables: lstat &lt;dbl&gt;, medv &lt;dbl&gt; 6.1.4 Desde web Por √∫ltimo, muchas veces querremos cargar archivos colgados en la web que, aunque al descargarlos son .csv o .xlsx, son archivos din√°micos que sabemos que van a ir cambiando, como por ejemplo los datos de casos covid, hospitalizados, ingresos UCI y fallecidos, de la p√°gina del ISCIII https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos. Imagen/gr√°fica 6.2: Archivos de la pandemia en el ISCIII. Esos archivos cambian cada d√≠a, por lo que para visualizarlos, analizarlos o guardarlos cada d√≠a, tendr√≠amos que, cada d√≠a, entrar de forma manual a la p√°gina y bajarnos el archivo. O no‚Ä¶ R nos permite leer archivos subidos en una web, d√°ndole a la funci√≥n de lectura el enlace del archivo en lugar de la ruta local de nuestro ordenador (para averiguar el enlace, basta con clickar bot√≥n derecho en la web y seleccionar ¬´copiar direcci√≥n de enlace¬ª) datos_ISCIII &lt;- read.csv(file = &quot;https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv&quot;) head(datos_ISCIII) ## provincia_iso sexo grupo_edad fecha num_casos num_hosp num_uci num_def ## 1 A H 0-9 2020-01-01 0 0 0 0 ## 2 A H 10-19 2020-01-01 0 0 0 0 ## 3 A H 20-29 2020-01-01 0 0 0 0 ## 4 A H 30-39 2020-01-01 0 0 0 0 ## 5 A H 40-49 2020-01-01 0 0 0 0 ## 6 A H 50-59 2020-01-01 0 0 0 0 Mientras el enlace web no cambie, cada vez que ejecutemos esa orden en nuestro c√≥digo tendremos en datos_ISCIII el √∫ltimo archivo actualizado que haya, sea el que sea, sin tener que descargarlo de forma manual, ¬°y sin necesidad de guardarlo en nuestro local, solo en la memoria virtual de nuestra sesi√≥n de R! "],["exportaci√≥n-de-datos.html", "6.2 Exportaci√≥n de datos", " 6.2 Exportaci√≥n de datos Aunque se puede exportar en cualquier formato que puedas importar, vamos a ver las dos formas m√°s √∫tiles y eficientes de exportar datos en R: fichero .RData. fichero .csv (obviaremos la exportaci√≥n a Excel porque un .csv ya es posible abrirlo con dicho engendro del demonio). 6.2.1 Guardar en .RData La exportaci√≥n en fichero .RData es la opci√≥n m√°s recomendable si t√∫ o tu equipo solo trabaj√°is con R, es la opci√≥n nativa de fichero, para que su importaci√≥n sea tan sencilla como una funci√≥n load(). Para exportar en R.Data basta con uses la funci√≥n save(), ind√≠candole lo que quieres guardar y la ruta donde quieres guardarlo. Es importante entender que la principal ventaja de exportar un fichero .RData es que no se est√° portando una tabla, o un fichero tabulado con un formato de filas y columnas: est√°s exportando cualquier cosa, cualquier variable de R, con la naturaleza de esa variable intacta, sin necesidad de pasarlo otro formato. # Exportamos en .RData la variable nombres save(nombres, file = &quot;./EXPORTAR/nombres.RData&quot;) Para tenerlo organizado, la orden anterior est√° hecha habiendo creado en nuestra carpeta del proyecto una carpeta EXPORTAR para guardar lo que vayamos exportando. Ese fichero solo podr√° ser abierto por R, pero cuando lo cargemos, tendremos la variable nombres tal cual la hemos guardado. 6.2.2 Guardar en .csv No siempre trabajamos en R y a veces necesitamos una exportaci√≥n de un data.frame o una tabla que podamos abrir en nuestra ordenador, ya sea para explic√°rsela a alguien o para envi√°rsela a otra persona. Para ello exportaremos en .csv, un fichero sin formato, y que es capaz de ser abierto por todo tipo de hojas de c√°lculo: basta que usemos la funci√≥n write.csv(). # Exportamos en .csv el data.frame tabla write.csv(tabla, file = &quot;./EXPORTAR/tabla.csv&quot;) Podemos consultar con ? write.csv las distintas opciones de exportaciones (por ejemplo, con row.names podemos indicarle si queremos nombres de filas o no, y con col.names si queremos exportar la cabecera con el nombre de las columnas). "],["consejos-y-tips-5.html", "6.3 Consejos y tips", " 6.3 Consejos y tips Paquetes {readr} y {tidyr} En dichos paquetes tienes m√°s funciones para una f√°cil exportaci√≥n y tabulaci√≥n de distintos tipos de datos, sea el formato que sea. Ver https://tidyr.tidyverse.org/ y https://readr.tidyverse.org/ Imagen/gr√°fica 6.3: Paquete readr. Imagen/gr√°fica 6.4: Paquete tidyr. Paquete {rvest} En dicho paquete tienes m√°s funciones para una lectura directamente de una p√°gina web (no desde un documento, desde la propia p√°gina web, como si estuvieras navegando en ella). Ver https://github.com/tidyverse/rvest. Secciones en el c√≥digo Los comentarios no solo sirven para documentar el c√≥digo sino que adem√°s pueden servirnos para construir secciones de c√≥digo. Prueba a escribir un comentario con varias ###############: ¬øves la flecha que te aparece en la parte izquierda? Sirve para minimizar o maximizar trozos de c√≥digo, de forma que tu c√≥digo a√∫n m√°s limpio. Imagen/gr√°fica 6.5: Secciones en el c√≥digo. L√≠neas de c√≥digo en los errores Dado que los errores del c√≥digo nos vendr√°n referenciados en la consola por el n√∫mero de l√≠nea donde fueron detectados, puede sernos muy √∫til mostrar dichos n√∫meros en la barra lateral izquierda, yendo a Tools &lt;&lt; Global Options &lt;&lt; Code &lt;&lt; Display &lt;&lt; Show line numbers Imagen/gr√°fica 6.6: L√≠neas de c√≥digo. Margen derecho en la ventana de scripts Aunque no afecte a nuestro c√≥digo escribir todo en una l√≠nea sin saltos de l√≠nea, no somos b√°rbaros/as. ¬øPor qu√© cuadno escribes en un Word lo haces en formato vertical pero cuando programas pones todas las √≥rdenes seguidas? Recuerda que la legibilidad de tu c√≥digo no solo te ahorrar√° tiempo sino que te har√° programar mejor. ¬øC√≥mo podemos fijar un margen imaginario para nosotros ser quienes demos al ENTER? Yendo a Tools &lt;&lt; Global Options &lt;&lt; Code &lt;&lt; Display &lt;&lt; Show margin (es un margen imaginario para ser nosotros quienes lo hagamos efectivo, a R le da igual) Imagen/gr√°fica 6.7: Margen derecho. "],["control.html", "Cap√≠tulo 7 Estructuras de control", " Cap√≠tulo 7 Estructuras de control Aunque la mayor√≠a de veces son sustituibles por otras expresiones m√°s legibles y eficientes, es importante que conozcamos como se usan las expresiones de control m√°s t√≠picas. "],["ifelse.html", "7.1 if‚Ä¶else", " 7.1 if‚Ä¶else Como en cualquier lenguaje de programaci√≥n, las estructuras if...else... nos permiten ejecutar partes de nuestro c√≥digo solo cuando se cumple la condici√≥n o condiciones l√≥gicas que queremos. Cuando ejecutamos un if estamos diciendo SI las condiciones impuestas se cumplen (TRUE), ejecuta las ordenes que tengamos dentro de las llaves. En caso contrario, no sucede nada SALVO que tengamos adem√°s un else anidado. Si elif devuelve FALSE, no suceder√° nada SALVO que tengamos adem√°s un else: lo que sucede cuando no se cumple, como en el ejemplo que tenemos debajo. edades &lt;- c(14, 24, 56, 31, 20, 87, 73) mayores_de_edad &lt;- FALSE if (all(edades &gt;= 18)) { # Si todas las personas son mayores de edad mayores_de_edad &lt;- TRUE print(&quot;todos mayores de edad&quot;) } else { # si la condici√≥n no se cumple: filtramos solo los mayores edades &lt;- edades[edades &gt;= 18] print(&quot;alg√∫n menor de edad se ha eliminado&quot;) } ## [1] &quot;alg√∫n menor de edad se ha eliminado&quot; Las √≥rdenes dentro del primer if se ejecutar√° si todas las personas son mayores de edad. En caso de no cumplirse (como es el caso), se ejecutar√° lo que hay entre llaves tras el else (filtra solo los mayores de edad e imprime un mensaje de control). Dicha estructura puede anidarse, de forma que vayamos concatenando estructuras ifelse, como en el ejemplo que tenemos debajo. edades &lt;- c(14, 14, 16, 11, 2, 17, 13) if (all(edades &gt;= 18)) { # Si todas las personas son mayores de edad mayores_de_edad &lt;- TRUE print(&quot;todos mayores de edad&quot;) } else if (any(edades &gt;= 18)) { # si alguna es mayor de edad edades_18 &lt;- edades[edades &gt;= 18] print(&quot;alg√∫n menor de edad se ha eliminado&quot;) } else { # ninguna persona mayor de edad print(&quot;todas las personas son menores de edad&quot;) } ## [1] &quot;todas las personas son menores de edad&quot; Esta estructura condicional puede ser vectorizada, de forma que podamos reunir en una sola fila un n√∫mero elevado de estructuras de comparaci√≥n. Por ejemplo, vamos a definir un vector de n√∫meros y vamos a comprobar si son n√∫meros pares o impares (para ello, usamos el operador %%, que nos calcula el resto de cada n√∫mero al dividirlo por una cifra). 1 %% 2 ## [1] 1 2 %% 2 ## [1] 0 3 %% 2 ## [1] 1 5 %% 3 ## [1] 2 Para nuestro objetivo aplicaremos la funci√≥n ifelse(), cuyos argumentos de entrada ser√°n la condici√≥n a evaluar, lo que sucede cuando se cumple y lo que no, que aplicar√° a cada elemento del vector de entrada. numeros &lt;- 1:10 ifelse((numeros %% 2) == 0, &quot;par&quot;, &quot;impar&quot;) # Los pares al dividir entre 2 tienen resto 0 ## [1] &quot;impar&quot; &quot;par&quot; &quot;impar&quot; &quot;par&quot; &quot;impar&quot; &quot;par&quot; &quot;impar&quot; &quot;par&quot; &quot;impar&quot; ## [10] &quot;par&quot; Esta funci√≥n ifelse() es muy util para codificar variables o averiguar cuales cumplen una condici√≥n, sin necesidad de hacer un bucle que recorra todos los valores. Recuerda: di (por lo general) no a los bucles. "],["forwhile.html", "7.2 for/while", " 7.2 for/while Aunque el 99% (porcentaje inventado, pero m√°s o menos) de las veces los bucles pueden ser sustituidos por c√≥digos de forma vectorial mucho m√°s eficientes (ya hemos visto algunos ejemplos), a veces no nos quedar√° m√°s remedio que usarlos por lo que nunca viene mal conocer su estructura. Un bucle for{} es una estructura que nos permite ejecutar un conjunto de √≥rdenes un n√∫mero repetido (finito y conocido) de veces: dado un conjunto de √≠ndices, el bucle ir√° recorriendo cada elemento de dicho conjunto, y para cada uno de ellos ejecutar√° lo que tenga dentro de las llaves. indices &lt;- 1:10 variable &lt;- NULL # vector donde guardaremos los pasos del bucle for (i in 1:10) { variable[i] &lt;- i # R es silenciosos: salvo que hagamos un print dentro del bucle no nos imprimir√° nada por pantalla } variable ## [1] 1 2 3 4 5 6 7 8 9 10 for (i in 1:length(indices)) { variable[i] &lt;- i } variable ## [1] 1 2 3 4 5 6 7 8 9 10 for (i in 1:length(indices)) { print(i^3) # imprimimos el √≠ndice al cubo } ## [1] 1 ## [1] 8 ## [1] 27 ## [1] 64 ## [1] 125 ## [1] 216 ## [1] 343 ## [1] 512 ## [1] 729 ## [1] 1000 Escribiendo length(indices), si cambiamos la variable indice no necesitamos cambiar el bucle (llegar√° hasta el final de dicho conjunto de valores, valga lo que valga). Aunque normalmente el conjunto que recorre el bucle suelen ser √≠ndices num√©ricos, podemos recorrer cualquier tipo de objeto. dias_semana &lt;- c(&quot;lunes&quot;, &quot;martes&quot;, &quot;mi√©rcoles&quot;, &quot;jueves&quot;, &quot;viernes&quot;, &quot;s√°bado&quot;, &quot;domingo&quot;) nombre_mayuscula &lt;- NULL for (dias in dias_semana) { # dias recorre los d√≠as de la semana tomando sus valores print(toupper(dias)) } ## [1] &quot;LUNES&quot; ## [1] &quot;MARTES&quot; ## [1] &quot;MI√âRCOLES&quot; ## [1] &quot;JUEVES&quot; ## [1] &quot;VIERNES&quot; ## [1] &quot;S√ÅBADO&quot; ## [1] &quot;DOMINGO&quot; Otra manera de dise√±ar un bucle es con la estructura while{}, que ejecutar√° el bucle un n√∫mero de veces a priori desconocido hasta que la condici√≥n impuesta deje de ser TRUE. max_ciclos &lt;- 10 ciclos &lt;- 1 # Mientras el n√∫mero de ciclos sea inferior 10, imprime while(ciclos &lt;= max_ciclos) { print(paste(&quot;Todav√≠a no, vamos por el ciclo &quot;, ciclos)) # Pegamos la frase al n√∫mero de ciclo por el que vayamos con paste ciclos &lt;- ciclos + 1 } ## [1] &quot;Todav√≠a no, vamos por el ciclo 1&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 2&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 3&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 4&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 5&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 6&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 7&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 8&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 9&quot; ## [1] &quot;Todav√≠a no, vamos por el ciclo 10&quot; ¬øY qu√© sucede cuando la condici√≥n nunca llega a ser FALSE? Compru√©balo t√∫ mismo/a. while (1 &gt; 0) { # Nunca va a dejar de ser cierto print(&quot;Presiona ESC para salir del bucle&quot;) } 7.2.1 BREAK/NEXT En R tenemos dos comandos reservados para poder abortar un bucle o avanzar forzosamente un bucle: dichas palabras son break y next. La primera nos habilita para parar un bucle aunque no haya llegado al final de su conjunto de √≠ndices a recorrer (o se siga cumpliendo la condici√≥n del while{}). for(i in 1:10) { if (i == 7) { break # si i es 7, el bucle frena aqu√≠ (nunca llegar√° a imprimir el 7 ni los sucesivos) } print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 Mientras que la segunda obliga al bucle a avanzar a la siguiente interacci√≥n, abortando la iteraci√≥n actual en la que se encuentra. for(i in 1:10) { if (i == 7) { next # si i es 7, la iteraci√≥n frenar√° aqu√≠ y pasar√° a la siguiente por lo que imprimir√° todos menos el 7 } print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 8 ## [1] 9 ## [1] 10 7.2.2 REPEAT Aunque es una opci√≥n muy poco usada, existe una estructura de control llamada repeat{} que nos ejecuta un bucle de forma infinita hasta que le ordenemos parar con un break. conteo &lt;- 0 repeat { conteo &lt;- conteo + 1 if (conteo &gt;= 100) { break } } conteo ## [1] 100 "],["consejos-y-tips-6.html", "7.3 Consejos y tips", " 7.3 Consejos y tips Cuidado con los bucles infinitos Las estucturas while{} y repeat{} son de las menos usadas por su peligrosidad, ya que si no incluimos un break o la condici√≥n nunca llega a ser TRUE, el bucle seguir√° ejecut√°ndose de forma infinita y solo podr√° ser detenido abortando la ejecuci√≥n con la tecla ESC. C√≥digo limpio: minimizando estructuras de control en el c√≥digo Puedes minimizar las estructuras de control pulsando en la flecha que aparece a la izquierda de ellas. "],["otros_datos.html", "Cap√≠tulo 8 Tipos de datos III: listas/factores", " Cap√≠tulo 8 Tipos de datos III: listas/factores Veamos alg√∫n tipo de dato muy particular m√°s all√° de vectores, matrices y data.frames. "],["listas.html", "8.1 Listas", " 8.1 Listas Probablemente las listas sea uno de los tipos de datos m√°s importantes en R ya que permiten almacenar colecciones de variables de diferente tipo (ya lo hac√≠an los data.frames) pero tambi√©n de diferente longitud, y con estructuras totalmente heter√≥geneas, de ah√≠ que sea el formato de salida de much√≠simas funciones de R que te devuelven a la vez un cadena de texto, un vector de n√∫meros o una tabla, todo guardado en la misma variable (incluso una lista puede tener dentro a su vez otra lista). Vamos a crear nuestra primera lista. # Fecha de nacimiento fecha_nacimiento &lt;- as.Date(&quot;1989-09-10&quot;) # Notas de asignaturas en primer y segundo parcial notas &lt;- data.frame(&quot;biolog√≠a&quot; = c(5, 7), &quot;f√≠sica&quot; = c(4, 5), &quot;matem√°ticas&quot; = c(8, 9.5)) # Nombre a las filas row.names(notas) &lt;- c(&quot;primer_parcial&quot;, &quot;segundo_parcial&quot;) # N√∫meros de tel√©fono tlf &lt;- c(&quot;914719567&quot;, &quot;617920765&quot;, &quot;716505013&quot;) # Nombres padres &lt;- c(&quot;Juan&quot;, &quot;Julia&quot;) # Guardamos TODO en una lista (con nombres de cada elemento) datos &lt;- list(&quot;nacimiento&quot; = fecha_nacimiento, &quot;notas_insti&quot; = notas, &quot;tel√©fonos&quot; = tlf, &quot;nombre_padres&quot; = padres) datos ## $nacimiento ## [1] &quot;1989-09-10&quot; ## ## $notas_insti ## biolog√≠a f√≠sica matem√°ticas ## primer_parcial 5 4 8.0 ## segundo_parcial 7 5 9.5 ## ## $tel√©fonos ## [1] &quot;914719567&quot; &quot;617920765&quot; &quot;716505013&quot; ## ## $nombre_padres ## [1] &quot;Juan&quot; &quot;Julia&quot; names(datos) ## [1] &quot;nacimiento&quot; &quot;notas_insti&quot; &quot;tel√©fonos&quot; &quot;nombre_padres&quot; Hemos creado una lista de 4 elementos: el elemento nacimiento (una fecha), el elemento notas_insti (un data.frame), el elemento tel√©fonos (un vector de n√∫meros) y nombre_padres (un vector de texto). Una lista es una varible que en un primer nivel solo tiene una dimensi√≥n por lo que si quieres saber cuantos elementos tiene debes ejecutar la funci√≥n length(). dim(datos) # devolver√° NULL al no tener dos dimensiones ## NULL length(datos) ## [1] 4 class(datos) # de tipo lista ## [1] &quot;list&quot; Para acceder a un elemento de la lista tenemos dos opciones: Acceder por √≠ndice: con el operador [[i]] accedemos al elemento i-√©simo de la lista. Acceder por nombre: con el operador $nombre_elemento accedemos al elemento cuyo nombre sea nombre_elemento. datos[[1]] ## [1] &quot;1989-09-10&quot; datos$nacimiento ## [1] &quot;1989-09-10&quot; datos[[2]] ## biolog√≠a f√≠sica matem√°ticas ## primer_parcial 5 4 8.0 ## segundo_parcial 7 5 9.5 datos$notas_insti ## biolog√≠a f√≠sica matem√°ticas ## primer_parcial 5 4 8.0 ## segundo_parcial 7 5 9.5 Si queremos acceder a varios elementos a la vez de la lista deberemos usar el operador []. datos[1:2] ## $nacimiento ## [1] &quot;1989-09-10&quot; ## ## $notas_insti ## biolog√≠a f√≠sica matem√°ticas ## primer_parcial 5 4 8.0 ## segundo_parcial 7 5 9.5 Como hemos comentado, tambi√©n podemos aplicar la recursividad y hacer listas con otras listas dentro, de forma que para acceder a cada nivel deberemos usar el operador [[]]. lista_de_listas &lt;- list(&quot;lista_1&quot; = datos[3:4], &quot;lista_2&quot; = datos[1:2]) names(lista_de_listas) # Nombres de los elementos del primer nivel ## [1] &quot;lista_1&quot; &quot;lista_2&quot; names(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista ## [1] &quot;tel√©fonos&quot; &quot;nombre_padres&quot; lista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior ## [1] &quot;914719567&quot; &quot;617920765&quot; &quot;716505013&quot; Un ejemplo de la utilidad de las listas la tenemos en los archivos R.Data de vacunas que hemos cargado en nuestro script. Con names(panel_vacunas) podemos ver que elementos contiene en el primer nivel. names(panel_vacunas) ## [1] &quot;AN&quot; &quot;AR&quot; &quot;AS&quot; &quot;IB&quot; &quot;CN&quot; &quot;CB&quot; &quot;CL&quot; &quot;CM&quot; &quot;CT&quot; &quot;VC&quot; ## [11] &quot;EX&quot; &quot;GA&quot; &quot;RI&quot; &quot;MD&quot; &quot;MC&quot; &quot;NC&quot; &quot;PV&quot; &quot;CE&quot; &quot;ML&quot; &quot;FFAA&quot; ## [21] &quot;ES&quot; Cada elemento de la lista es un data.frame de una comunidad auton√≥noma, que a su vez contiene una serie de variables (columnas) para cada una de las fechas (filas): ¬°nos permite guardar ¬´datos tridimensionales¬ª!. class(panel_vacunas$ES) ## [1] &quot;data.frame&quot; names(panel_vacunas$ES) ## [1] &quot;fechas&quot; ## [2] &quot;ISO&quot; ## [3] &quot;poblacion&quot; ## [4] &quot;porc_pobl_total&quot; ## [5] &quot;poblacion_mayor_16a&quot; ## [6] &quot;porc_pobl_total_mayor_16a&quot; ## [7] &quot;dosis_entrega_pfizer&quot; ## [8] &quot;dosis_entrega_astra&quot; ## [9] &quot;dosis_entrega_moderna&quot; ## [10] &quot;dosis_entrega_janssen&quot; ## [11] &quot;dosis_entrega&quot; ## [12] &quot;dosis_entrega_100hab&quot; ## [13] &quot;porc_entregadas_sobre_total&quot; ## [14] &quot;dosis_diarias_entrega_pfizer&quot; ## [15] &quot;dosis_diarias_entrega_astra&quot; ## [16] &quot;dosis_diarias_entrega_moderna&quot; ## [17] &quot;dosis_diarias_entrega&quot; ## [18] &quot;dosis_7D_entrega_pfizer&quot; ## [19] &quot;dosis_7D_entrega_astra&quot; ## [20] &quot;dosis_7D_entrega_moderna&quot; ## [21] &quot;dosis_7D_entrega&quot; ## [22] &quot;dosis_7D_entrega_100hab&quot; ## [23] &quot;dosis_admin&quot; ## [24] &quot;dosis_primera&quot; ## [25] &quot;dosis_pauta_completa&quot; ## [26] &quot;dosis_admin_100hab&quot; ## [27] &quot;porc_admin_sobre_ccaa&quot; ## [28] &quot;porc_admin_vs_total&quot; ## [29] &quot;dosis_diarias_admin&quot; ## [30] &quot;dosis_diarias_admin_100hab&quot; ## [31] &quot;crec_diario_dosis_admin&quot; ## [32] &quot;dosis_diarias_primera&quot; ## [33] &quot;dosis_diarias_segunda&quot; ## [34] &quot;dosis_7D_admin&quot; ## [35] &quot;dosis_7D_admin_100hab&quot; ## [36] &quot;crec_7D_dosis_admin&quot; ## [37] &quot;porc_admin_vs_total_7D&quot; ## [38] &quot;personas_vacunadas&quot; ## [39] &quot;personas_pauta_completa&quot; ## [40] &quot;personas_1dosis&quot; ## [41] &quot;porc_personas_vacunadas&quot; ## [42] &quot;porc_personas_pauta_completa&quot; ## [43] &quot;porc_personas_vacunadas_16a&quot; ## [44] &quot;porc_personas_pauta_completa_16a&quot; ## [45] &quot;personas_vacunadas_diarias&quot; ## [46] &quot;personas_pauta_completa_diarias&quot; ## [47] &quot;porc_personas_vacunadas_diarias&quot; ## [48] &quot;porc_personas_pauta_completa_diarias&quot; ## [49] &quot;personas_vacunadas_7D&quot; ## [50] &quot;personas_pauta_completa_7D&quot; ## [51] &quot;porc_personas_vacunadas_7D&quot; ## [52] &quot;porc_personas_pauta_completa_7D&quot; ## [53] &quot;porc_personas_vacunadas_16a_7D&quot; ## [54] &quot;porc_personas_pauta_completa_16a_7D&quot; ## [55] &quot;crec_diario_personas_vacunadas&quot; ## [56] &quot;crec_7D_personas_vacunadas&quot; ## [57] &quot;crec_diario_personas_pauta_completa&quot; ## [58] &quot;crec_7D_personas_pauta_completa&quot; ## [59] &quot;desv_porc_admin_vs_total&quot; ## [60] &quot;desv_dosis_entrega&quot; ## [61] &quot;desv_porc_personas_vacunadas&quot; ## [62] &quot;desv_porc_personas_pauta_completa&quot; ## [63] &quot;fecha_30vacunados_ritmo7D&quot; ## [64] &quot;fecha_50vacunados_ritmo7D&quot; ## [65] &quot;fecha_70vacunados_ritmo7D&quot; ## [66] &quot;fecha_30inmunizados_ritmo7D&quot; ## [67] &quot;fecha_50inmunizados_ritmo7D&quot; ## [68] &quot;fecha_70inmunizados_ritmo7D&quot; ## [69] &quot;fecha_30inmunizados_16a_ritmo7D&quot; ## [70] &quot;fecha_50inmunizados_16a_ritmo7D&quot; ## [71] &quot;fecha_70inmunizados_16a_ritmo7D&quot; head(panel_vacunas$ES[, 1:5]) ## fechas ISO poblacion porc_pobl_total poblacion_mayor_16a ## 1 2021-01-05 ES 47450795 100 40129822 ## 2 2021-01-06 ES 47450795 100 40129822 ## 21 2021-01-07 ES 47450795 100 40129822 ## 3 2021-01-08 ES 47450795 100 40129822 ## 11 2021-01-09 ES 47450795 100 40129822 ## 12 2021-01-10 ES 47450795 100 40129822 El acceso lo podemos realizar por orden que ocupa en la lista pero tambi√©n de forma intuitiva con $ y el c√≥digo ISO de la comunidad aut√≥noma. Lo mismo podemos hacer con el panel de fechas, donde ahora cada elemento de la lista es una fecha, y en cada elemento de ella, est√° guardada la informaci√≥n de cada variable (columna) y cada comunidad (fila). names(panel_vacunas_fecha) ## [1] &quot;2021-01-05&quot; &quot;2021-01-06&quot; &quot;2021-01-07&quot; &quot;2021-01-08&quot; &quot;2021-01-09&quot; ## [6] &quot;2021-01-10&quot; &quot;2021-01-11&quot; &quot;2021-01-12&quot; &quot;2021-01-13&quot; &quot;2021-01-14&quot; ## [11] &quot;2021-01-15&quot; &quot;2021-01-16&quot; &quot;2021-01-17&quot; &quot;2021-01-18&quot; &quot;2021-01-19&quot; ## [16] &quot;2021-01-20&quot; &quot;2021-01-21&quot; &quot;2021-01-22&quot; &quot;2021-01-23&quot; &quot;2021-01-24&quot; ## [21] &quot;2021-01-25&quot; &quot;2021-01-26&quot; &quot;2021-01-27&quot; &quot;2021-01-28&quot; &quot;2021-01-29&quot; ## [26] &quot;2021-01-30&quot; &quot;2021-01-31&quot; &quot;2021-02-01&quot; &quot;2021-02-02&quot; &quot;2021-02-03&quot; ## [31] &quot;2021-02-04&quot; &quot;2021-02-05&quot; &quot;2021-02-06&quot; &quot;2021-02-07&quot; &quot;2021-02-08&quot; ## [36] &quot;2021-02-09&quot; &quot;2021-02-10&quot; &quot;2021-02-11&quot; &quot;2021-02-12&quot; &quot;2021-02-13&quot; ## [41] &quot;2021-02-14&quot; &quot;2021-02-15&quot; &quot;2021-02-16&quot; &quot;2021-02-17&quot; &quot;2021-02-18&quot; ## [46] &quot;2021-02-19&quot; &quot;2021-02-20&quot; &quot;2021-02-21&quot; &quot;2021-02-22&quot; &quot;2021-02-23&quot; ## [51] &quot;2021-02-24&quot; &quot;2021-02-25&quot; &quot;2021-02-26&quot; &quot;2021-02-27&quot; &quot;2021-02-28&quot; ## [56] &quot;2021-03-01&quot; &quot;2021-03-02&quot; &quot;2021-03-03&quot; &quot;2021-03-04&quot; &quot;2021-03-05&quot; ## [61] &quot;2021-03-06&quot; &quot;2021-03-07&quot; &quot;2021-03-08&quot; &quot;2021-03-09&quot; &quot;2021-03-10&quot; ## [66] &quot;2021-03-11&quot; &quot;2021-03-12&quot; &quot;2021-03-13&quot; &quot;2021-03-14&quot; &quot;2021-03-15&quot; ## [71] &quot;2021-03-16&quot; &quot;2021-03-17&quot; &quot;2021-03-18&quot; &quot;2021-03-19&quot; &quot;2021-03-20&quot; ## [76] &quot;2021-03-21&quot; &quot;2021-03-22&quot; &quot;2021-03-23&quot; &quot;2021-03-24&quot; &quot;2021-03-25&quot; ## [81] &quot;2021-03-26&quot; &quot;2021-03-27&quot; &quot;2021-03-28&quot; &quot;2021-03-29&quot; &quot;2021-03-30&quot; ## [86] &quot;2021-03-31&quot; &quot;2021-04-01&quot; &quot;2021-04-02&quot; &quot;2021-04-03&quot; &quot;2021-04-04&quot; ## [91] &quot;2021-04-05&quot; &quot;2021-04-06&quot; &quot;2021-04-07&quot; &quot;2021-04-08&quot; &quot;2021-04-09&quot; ## [96] &quot;2021-04-10&quot; &quot;2021-04-11&quot; &quot;2021-04-12&quot; &quot;2021-04-13&quot; &quot;2021-04-14&quot; ## [101] &quot;2021-04-15&quot; &quot;2021-04-16&quot; &quot;2021-04-17&quot; &quot;2021-04-18&quot; &quot;2021-04-19&quot; ## [106] &quot;2021-04-20&quot; &quot;2021-04-21&quot; &quot;2021-04-22&quot; &quot;2021-04-23&quot; names(panel_vacunas_fecha$`2021-04-23`) ## [1] &quot;ccaa&quot; ## [2] &quot;fechas&quot; ## [3] &quot;ISO&quot; ## [4] &quot;poblacion&quot; ## [5] &quot;porc_pobl_total&quot; ## [6] &quot;poblacion_mayor_16a&quot; ## [7] &quot;porc_pobl_total_mayor_16a&quot; ## [8] &quot;dosis_entrega_pfizer&quot; ## [9] &quot;dosis_entrega_astra&quot; ## [10] &quot;dosis_entrega_moderna&quot; ## [11] &quot;dosis_entrega_janssen&quot; ## [12] &quot;dosis_entrega&quot; ## [13] &quot;dosis_entrega_100hab&quot; ## [14] &quot;porc_entregadas_sobre_total&quot; ## [15] &quot;dosis_diarias_entrega_pfizer&quot; ## [16] &quot;dosis_diarias_entrega_astra&quot; ## [17] &quot;dosis_diarias_entrega_moderna&quot; ## [18] &quot;dosis_diarias_entrega&quot; ## [19] &quot;dosis_7D_entrega_pfizer&quot; ## [20] &quot;dosis_7D_entrega_astra&quot; ## [21] &quot;dosis_7D_entrega_moderna&quot; ## [22] &quot;dosis_7D_entrega&quot; ## [23] &quot;dosis_7D_entrega_100hab&quot; ## [24] &quot;dosis_admin&quot; ## [25] &quot;dosis_primera&quot; ## [26] &quot;dosis_pauta_completa&quot; ## [27] &quot;dosis_admin_100hab&quot; ## [28] &quot;porc_admin_sobre_ccaa&quot; ## [29] &quot;porc_admin_vs_total&quot; ## [30] &quot;dosis_diarias_admin&quot; ## [31] &quot;dosis_diarias_admin_100hab&quot; ## [32] &quot;crec_diario_dosis_admin&quot; ## [33] &quot;dosis_diarias_primera&quot; ## [34] &quot;dosis_diarias_segunda&quot; ## [35] &quot;dosis_7D_admin&quot; ## [36] &quot;dosis_7D_admin_100hab&quot; ## [37] &quot;crec_7D_dosis_admin&quot; ## [38] &quot;porc_admin_vs_total_7D&quot; ## [39] &quot;personas_vacunadas&quot; ## [40] &quot;personas_pauta_completa&quot; ## [41] &quot;personas_1dosis&quot; ## [42] &quot;porc_personas_vacunadas&quot; ## [43] &quot;porc_personas_pauta_completa&quot; ## [44] &quot;porc_personas_vacunadas_16a&quot; ## [45] &quot;porc_personas_pauta_completa_16a&quot; ## [46] &quot;personas_vacunadas_diarias&quot; ## [47] &quot;personas_pauta_completa_diarias&quot; ## [48] &quot;porc_personas_vacunadas_diarias&quot; ## [49] &quot;porc_personas_pauta_completa_diarias&quot; ## [50] &quot;personas_vacunadas_7D&quot; ## [51] &quot;personas_pauta_completa_7D&quot; ## [52] &quot;porc_personas_vacunadas_7D&quot; ## [53] &quot;porc_personas_pauta_completa_7D&quot; ## [54] &quot;porc_personas_vacunadas_16a_7D&quot; ## [55] &quot;porc_personas_pauta_completa_16a_7D&quot; ## [56] &quot;crec_diario_personas_vacunadas&quot; ## [57] &quot;crec_7D_personas_vacunadas&quot; ## [58] &quot;crec_diario_personas_pauta_completa&quot; ## [59] &quot;crec_7D_personas_pauta_completa&quot; ## [60] &quot;desv_porc_admin_vs_total&quot; ## [61] &quot;desv_dosis_entrega&quot; ## [62] &quot;desv_porc_personas_vacunadas&quot; ## [63] &quot;desv_porc_personas_pauta_completa&quot; ## [64] &quot;fecha_30vacunados_ritmo7D&quot; ## [65] &quot;fecha_50vacunados_ritmo7D&quot; ## [66] &quot;fecha_70vacunados_ritmo7D&quot; ## [67] &quot;fecha_30inmunizados_ritmo7D&quot; ## [68] &quot;fecha_50inmunizados_ritmo7D&quot; ## [69] &quot;fecha_70inmunizados_ritmo7D&quot; ## [70] &quot;fecha_30inmunizados_16a_ritmo7D&quot; ## [71] &quot;fecha_50inmunizados_16a_ritmo7D&quot; ## [72] &quot;fecha_70inmunizados_16a_ritmo7D&quot; head(panel_vacunas_fecha$`2021-04-23`[, 1:7]) ## ccaa fechas ISO poblacion porc_pobl_total poblacion_mayor_16a ## 77 AN 2021-04-23 AN 8464411 17.838 7062213 ## 771 AR 2021-04-23 AR 1329391 2.802 1132764 ## 772 AS 2021-04-23 AS 1018784 2.147 901209 ## 773 IB 2021-04-23 IB 1171543 2.469 986279 ## 774 CN 2021-04-23 CN 2175952 4.586 1871033 ## 775 CB 2021-04-23 CB 582905 1.228 501384 ## porc_pobl_total_mayor_16a ## 77 17.598 ## 771 2.823 ## 772 2.246 ## 773 2.458 ## 774 4.662 ## 775 1.249 "],["factores.html", "8.2 Factores", " 8.2 Factores Los factores son el tipo de dato que tiene R para definir variables categ√≥ricas, variables que aunque puedan ser n√∫meros, en realidad representa categor√≠as (categor√≠a 1, 2, 3‚Ä¶). Internamente los factores se guardan como variable num√©ricas enteras (enumerando las categor√≠as) pero se nos mostar√°n con el nombre asignada a dicha categor√≠a. Para convertir una variable a factor basta con ejecutar la funci√≥n factor(), que nos convierte cada valor diferente en una categor√≠a (para ver valores diferentes de un vector, usar la funci√≥n unique()). datos &lt;- c(1, 2, 2, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1) unique(datos) ## [1] 1 2 3 datos ## [1] 1 2 2 3 1 2 3 3 1 2 3 3 1 datos_factor &lt;- factor(datos) # Convertimos a factor datos_factor ## [1] 1 2 2 3 1 2 3 3 1 2 3 3 1 ## Levels: 1 2 3 Es importante entender que un factor es una categor√≠a, como rojo/blanco/negro, por lo que desde el momento en el que lo convertimos en factor, ya no podemos hacer operaciones aritm√©ticas. datos + 1 ## [1] 2 3 3 4 2 3 4 4 2 3 4 4 2 datos_factor + 1 ## Warning in Ops.factor(datos_factor, 1): &#39;+&#39; not meaningful for factors ## [1] NA NA NA NA NA NA NA NA NA NA NA NA NA Como puedes observar, al tenerlo en factor, adem√°s de la variable en s√≠ se nos muestra debajo los levels, los nombres de las categor√≠as. Si no le indicamos que nombres queremos, nos convierte los valores a texto y lo toma como nombre de categor√≠a. Con el argumento labels podemos configurarlo a nuestro gusto. Con la funci√≥n levels podemos reasignarle nombres tras su generaci√≥n. datos_factor &lt;- factor(datos, labels = paste(&quot;Categor√≠a&quot;, sort(unique(datos)))) # damos nombre de categor√≠a 1, 2, 3... datos_factor ## [1] Categor√≠a 1 Categor√≠a 2 Categor√≠a 2 Categor√≠a 3 Categor√≠a 1 Categor√≠a 2 ## [7] Categor√≠a 3 Categor√≠a 3 Categor√≠a 1 Categor√≠a 2 Categor√≠a 3 Categor√≠a 3 ## [13] Categor√≠a 1 ## Levels: Categor√≠a 1 Categor√≠a 2 Categor√≠a 3 levels(datos_factor) &lt;- c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;) datos_factor ## [1] C1 C2 C2 C3 C1 C2 C3 C3 C1 C2 C3 C3 C1 ## Levels: C1 C2 C3 Aunque sirve tambi√©n para variables num√©ricas, la funci√≥n table() nos calcula las frecuencias de cada una de las categor√≠as, las veces que se repiten en nuestro conjunto (es una forma eficiente de guardar categor√≠as ya que solo se guardan los valores √∫nicos y el n√∫mero de veces que se repiten, as√≠ como su lugar). table(datos_factor) ## datos_factor ## C1 C2 C3 ## 4 4 5 Una ventaja de los factores es que le podemos indicar que considere que las categor√≠as son ordinales: tiene una jerarqu√≠a de orden, con el argumento ordered = TRUE. notas &lt;- c(7, 2, 10, 5, 7, 8, 10, 8, 2, 2, 5, 5, 5, 10) # notas de clase: tienen un orden notas_factor &lt;- factor(notas) notas_factor[1] &lt; notas_factor[2] ## Warning in Ops.factor(notas_factor[1], notas_factor[2]): &#39;&lt;&#39; not meaningful for ## factors ## [1] NA notas_factor_ordenados &lt;- factor(notas, ordered = TRUE) notas_factor_ordenados[1] &lt; notas_factor_ordenados[2] # nos dice que la categor√≠a 7 no es menor que la categor√≠a 2 ## [1] FALSE notas_factor_ordenados ## [1] 7 2 10 5 7 8 10 8 2 2 5 5 5 10 ## Levels: 2 &lt; 5 &lt; 7 &lt; 8 &lt; 10 Para pasar de factor a variable num√©rica (y poder operar con ellos), basta usar la funci√≥n as.numeric(). notas_factor_ordenados + 1 ## Warning in Ops.ordered(notas_factor_ordenados, 1): &#39;+&#39; is not meaningful for ## ordered factors ## [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA as.numeric(notas_factor_ordenados) + 1 ## [1] 4 2 6 3 4 5 6 5 2 2 3 3 3 6 mean(as.numeric(notas_factor_ordenados)) ## [1] 2.857143 Tambi√©n podemos convertir variables continuas (o discretas) a factores indicando los rangos de las categor√≠as que queremos asignar con la funci√≥n cut(). Por ejemplo, supongamos que tenemos notas num√©ricas de clase y queremos asignar una nota categ√≥rica. En el argumento breaks debemos indicarle los cortes que queremos en los datos, teniendo n+1 valores, siendo n el n√∫mero de categor√≠as. Con right = FALSE le vamos a indicar que los intervalos son abiertos por la derecha. notas &lt;- c(7.4, 1.1, 2.9, 10, 5.2, 7.7, 8.9, 10, 8.1, 2.6, 2.4, 5.5, 5, 5, 10, 6.3, 9.4) # notas de clase notas_categoricas &lt;- cut(notas, breaks = c(0, 5, 7, 9, 10, 10.1), labels = c(&quot;suspenso&quot;, &quot;aprobado&quot;, &quot;notable&quot;, &quot;sobresaliente&quot;, &quot;mh&quot;), right = FALSE) notas_categoricas ## [1] notable suspenso suspenso mh aprobado ## [6] notable notable mh notable suspenso ## [11] suspenso aprobado aprobado aprobado mh ## [16] aprobado sobresaliente ## Levels: suspenso aprobado notable sobresaliente mh Adem√°s, la funci√≥n cut() identifica los datos de tipo fecha, pudiendo hacer cortes por unidades temporales. fechas &lt;- as.Date(c(&quot;2021-04-10&quot;, &quot;2021-03-10&quot;, &quot;2021-01-01&quot;, &quot;2020-01-15&quot;, &quot;2020-09-10&quot;, &quot;2020-09-15&quot;, &quot;2020-07-08&quot;)) fechas_cortes &lt;- cut(fechas, breaks = &quot;year&quot;) levels(fechas_cortes) &lt;- c(&quot;2020&quot;, &quot;2021&quot;) fechas_cortes ## [1] 2021 2021 2021 2020 2020 2020 2020 ## Levels: 2020 2021 "],["fechas-y-horas.html", "8.3 Fechas y horas", " 8.3 Fechas y horas Como ya hemos dicho, las fechas y momentos temporales no ser√°n meras cadenas de caracter sino que tienen clases especiales asociadas y algunas funciones especiales que pueden sernos √∫tiles: las fechas ser√°n de tipo dates mientras que las horas ser√° de tipo POSIXct o POSIXlt. En el primer caso, las fechas ser√°n guardadas internamente como el n√∫mero de d√≠as transcurridos desde el 1 de enero de 1970, y las horas como n√∫mero de segundos desde el 1 de enero de 1970 (para la clase POSIXct) o una lista de segundos, minutos y horas (para la clase POSIXlt). ¬øC√≥mo obtener autom√°ticamente la fecha de hoy, por ejemplo? La funci√≥n Sys.Date() nos devuelve directamente la fecha y hora en el momento de la ejecuci√≥n de la orden. fecha &lt;- Sys.Date() fecha ## [1] &quot;2021-09-08&quot; fecha - 7 # una semana antes ## [1] &quot;2021-09-01&quot; class(fecha) # de clase fecha ## [1] &quot;Date&quot; Para convertir una cadena de texto a fecha, basta usar la funci√≥n as.Date() con la fecha en formato &quot;yyyy-mm-dd&quot; por defecto. Si le introducimos otro tipo de formato, debemos especific√°rselo en un segundo argumento. as.Date(&quot;2021-03-10&quot;) # formato por defecto ## [1] &quot;2021-03-10&quot; as.Date(&quot;10-03-2020&quot;, &quot;%d-%m-%Y&quot;) # con d√≠a-mes-a√±o (4 cifras) ## [1] &quot;2020-03-10&quot; as.Date(&quot;10-03-20&quot;, &quot;%d-%m-%y&quot;) # con d√≠a-mes-a√±o (2 cifras) ## [1] &quot;2020-03-10&quot; as.Date(&quot;03-10-2020&quot;, &quot;%m-%d-%Y&quot;) # con mes-d√≠a-a√±o (4 cifras) ## [1] &quot;2020-03-10&quot; as.Date(&quot;Octubre 21, 1995 21:24&quot;, &quot;%B %d, %Y %H:%M&quot;) # fecha escrita ## [1] &quot;1995-10-21&quot; F√≠jate la diferencia cuando lo convertimos en fecha &quot;2021-03-10&quot; - 1 # error ## Error in &quot;2021-03-10&quot; - 1: argumento no-num√©rico para operador binario as.Date(&quot;2021-03-10&quot;) - 1 # d√≠a previo ## [1] &quot;2021-03-09&quot; Aunque aparentemente parezca una cadena de texto, prueba a ejecutar unclass(fecha) para comprobar que tiene internamente guardado. unclass(fecha) ## [1] 18878 unclass(as.Date(&quot;1969-01-01&quot;)) # justo un a√±o antes de la referencia ## [1] -365 Para la fecha con hora actual podemos usar una funci√≥n similar, la funci√≥n Sys.time(). Al igual que la funci√≥n as.Date() para convertir cadenas de texto en fechas, podemos hacer uso de la funci√≥n strptime() para convertir cadenas de texto en fecha-hora. fecha_hora &lt;- Sys.time() # fecha y hora actual en formato POSIXct class(fecha_hora) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; unclass(fecha_hora) ## [1] 1631093364 strptime(&quot;Octubre 21, 1995 21:24&quot;, &quot;%B %d, %Y %H:%M&quot;) # fecha escrita ## [1] &quot;1995-10-21 21:24:00 CET&quot; # fecha y hora actual en formato POSIXlt fecha_hora2 &lt;- as.POSIXlt(Sys.time()) class(fecha_hora2) ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; unclass(fecha_hora2) ## $sec ## [1] 24.06899 ## ## $min ## [1] 29 ## ## $hour ## [1] 11 ## ## $mday ## [1] 8 ## ## $mon ## [1] 8 ## ## $year ## [1] 121 ## ## $wday ## [1] 3 ## ## $yday ## [1] 250 ## ## $isdst ## [1] 1 ## ## $zone ## [1] &quot;CEST&quot; ## ## $gmtoff ## [1] 7200 ## ## attr(,&quot;tzone&quot;) ## [1] &quot;&quot; &quot;CET&quot; &quot;CEST&quot; str(unclass(fecha_hora2)) ## List of 11 ## $ sec : num 24.1 ## $ min : int 29 ## $ hour : int 11 ## $ mday : int 8 ## $ mon : int 8 ## $ year : int 121 ## $ wday : int 3 ## $ yday : int 250 ## $ isdst : int 1 ## $ zone : chr &quot;CEST&quot; ## $ gmtoff: int 7200 ## - attr(*, &quot;tzone&quot;)= chr [1:3] &quot;&quot; &quot;CET&quot; &quot;CEST&quot; fecha_hora2$min # Accedemos a los minutos ## [1] 29 Adem√°s tenemos disponibles funciones para extraer facilmente algunas variables temporales como el d√≠a de la semana, el mes o el cuatrimestre, con las funciones weekdays(), months(), and quarters(). weekdays(fecha) ## [1] &quot;mi√©rcoles&quot; months(fecha) ## [1] &quot;septiembre&quot; quarters(fecha) ## [1] &quot;Q3&quot; Al igual que podemos realizar operaciones aritm√©ticas sencillas con las fechas, tambi√©n podemos realizar comparaciones, por ejemplo, si el d√≠a actual es menor o mayor que otra fecha dada. fecha_actual &lt;- Sys.Date() fecha_actual &gt; as.Date(&quot;2020-04-15&quot;) ## [1] TRUE fecha_actual &lt; as.Date(&quot;2020-04-15&quot;) ## [1] FALSE La funci√≥n difftime() nos permite adem√°s hallar distancias entre fechas pero no solo en d√≠as (lo que suceder√≠a si restamos 2 fechas) sino en las unidades temporales que queramos. difftime(Sys.time(), as.POSIXct(&quot;2020-01-17 10:24:12 CEST&quot;), units = &quot;days&quot;) ## Time difference of 600.0036 days difftime(Sys.time(), as.POSIXct(&quot;2020-01-17 10:24:12 CEST&quot;), units = &quot;hours&quot;) ## Time difference of 14400.09 hours difftime(Sys.time(), as.POSIXct(&quot;2020-01-17 10:24:12 CEST&quot;), units = &quot;weeks&quot;) ## Time difference of 85.7148 weeks "],["consejos-y-tips-7.html", "8.4 Consejos y tips", " 8.4 Consejos y tips Paquete {lubridate} En dicho paquete tienes muchas funcionalidades para trabajar con fechas. Ver https://lubridate.tidyverse.org/. Imagen/gr√°fica 8.1: Paquete lubridate. Paquete {forcats} En dicho paquete tienes muchas funcionalidades para trabajar con factores. Ver https://forcats.tidyverse.org/. Imagen/gr√°fica 8.2: Paquete lubridate. Operaciones aritm√©ticas con listas Una lista no se puede vectorizar de forma inmediata, por lo cualquier operaci√≥n aritm√©tica aplicada a una lista dar√° error (ver m√°s adelante la funci√≥n lapply()). datos / 2 ## [1] 0.5 1.0 1.0 1.5 0.5 1.0 1.5 1.5 0.5 1.0 1.5 1.5 0.5 "],["ejercicios-3.html", "8.5 üìù Ejercicios", " 8.5 üìù Ejercicios Ejercicio 1: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluir√© uno que sea un data.frame para que veas que en una lista cabe de todo). Soluci√≥n: # Ejemplo: lista con texto, num√©rico, l√≥gico y un data.frame lista_ejemplo &lt;- list(&quot;nombre&quot; = &quot;Javier&quot;, &quot;cp&quot; = 28019, &quot;soltero&quot; = TRUE, &quot;notas&quot; = data.frame(&quot;mates&quot; = c(7.5, 8, 9), &quot;lengua&quot; = c(10, 5, 6), &quot;gimnasia&quot; = c(4, 8, 6))) lista_ejemplo ## $nombre ## [1] &quot;Javier&quot; ## ## $cp ## [1] 28019 ## ## $soltero ## [1] TRUE ## ## $notas ## mates lengua gimnasia ## 1 7.5 10 4 ## 2 8.0 5 8 ## 3 9.0 6 6 # Longitud length(lista_ejemplo) ## [1] 4 # Accedemos al elemento dos lista_ejemplo[[2]] ## [1] 28019 Ejercicio 2: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad (como dato num√©rico) y si est√°s soltero/a. Soluci√≥n: library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union # Creamos lista: con lubridate calculamos la diferencia de a√±os desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy) lista_personal &lt;- list(&quot;nombre&quot; = &quot;Javier&quot;, &quot;apellidos&quot; = &quot;√Ålvarez Li√©bana&quot;, &quot;edad&quot; = time_length(interval(ymd(&quot;1989-09-10&quot;), ymd(Sys.Date())), unit = &quot;years&quot;), &quot;soltero&quot; = TRUE) lista_personal ## $nombre ## [1] &quot;Javier&quot; ## ## $apellidos ## [1] &quot;√Ålvarez Li√©bana&quot; ## ## $edad ## [1] 31.99452 ## ## $soltero ## [1] TRUE # Otra opci√≥n: la edad calculada con floor (quita decimales y se queda con la parte entera) lista_personal &lt;- list(&quot;nombre&quot; = &quot;Javier&quot;, &quot;apellidos&quot; = &quot;√Ålvarez Li√©bana&quot;, &quot;edad&quot; = floor(time_length(interval(ymd(&quot;1989-09-10&quot;), ymd(Sys.Date())), unit = &quot;years&quot;)), &quot;soltero&quot; = TRUE) lista_personal ## $nombre ## [1] &quot;Javier&quot; ## ## $apellidos ## [1] &quot;√Ålvarez Li√©bana&quot; ## ## $edad ## [1] 31 ## ## $soltero ## [1] TRUE "],["FUNCIONES.html", "Cap√≠tulo 9 Creaci√≥n de funciones", " Cap√≠tulo 9 Creaci√≥n de funciones En R no solo podemos usar las funciones predeterminadas que vienen ya cargadas, o las de los paquetes que instalamos, sino que adem√°s podemos crear nuestras propias funciones, para automatizar tareas que vayamos a repetir a lo largo de nuestro c√≥digo. ¬øC√≥mo crear nuestra propia funci√≥n? Veamos su sintaxis b√°sica. Para crear una funci√≥n necesitamos un nombre_funcion (sin espacios ni caracteres extra√±os), al que le asignamos la orden function(). Dentro de function() tendr√≠amos que definir los argumentos de entrada que vamos a usar. nombre_funcion &lt;- function(argumento_1, argumento_2, ... ) { # C√≥digo que queramos ejecutar en la funci√≥n c√≥digo # Salida return(variable_salida) } argumento_1, argumento_2, ‚Ä¶: ser√°n los argumentos de entrada, los argumentos que toma la funci√≥n para ejecutar el c√≥digo que tiene dentro c√≥digo: l√≠neas de c√≥digo que queramos que ejecute la funci√≥n. IMPORTANTE: todas las variables que definamos dentro de la funci√≥n son variables locales, solo existir√°n dentro de la funci√≥n salvo que especifiquemos lo contrario. return(variable_salida): dentro del comando return() se introducir√° la salida de la funci√≥n, que puede ser un n√∫mero, un data.frame, una gr√°fica, una matriz, o todo junto en una lista. "],["primera-funci√≥n.html", "9.1 Primera funci√≥n", " 9.1 Primera funci√≥n Veamos un ejemplo muy simple de funci√≥n para calcular el √°rea de un rect√°ngulo. # Definici√≥n del nombre de funci√≥n y argumentos de entrada calcular_area &lt;- function(lado_1, lado_2) { # Cuerpo de la funci√≥n area &lt;- lado_1 * lado_2 # Resultado que devolvemos return(area) } ¬øC√≥mo aplicar la funci√≥n? Con el nombre y los valores de los argumentos. # Aplicaci√≥n de la funci√≥n con los par√°metros por defecto calcular_area(5, 3) # √°rea de un rect√°ngulo 5 x 3 ## [1] 15 Imagina ahora que nos damos cuenta que el 90% de las veces el √°rea que nos toca calcular es la de un cuadrado: R nos permite definir argumentos en la funci√≥n con valores por defecto (tomar√°n dicho valor salvo que le asignemos otro). ¬øPor qu√© no asignar lado_2 = lado_1 por defecto, para ahorrar l√≠neas de c√≥digo y tiempo? # Definici√≥n del nombre de funci√≥n y argumentos de entrada calcular_area &lt;- function(lado_1, lado_2 = lado_1) { # Cuerpo de la funci√≥n area &lt;- lado_1 * lado_2 # Resultado que devolvemos return(area) } calcular_area(lado_1 = 5) # si no indicamos nada, lado_2 = lado_1 ## [1] 25 Compliquemos un poco la funci√≥n y a√±adamos en la salida los valores de cada lado etiquetados como primer lado y segundo lado. # Definici√≥n del nombre de funci√≥n y argumentos de entrada calcular_area &lt;- function(lado_1, lado_2 = lado_1) { # Cuerpo de la funci√≥n area &lt;- lado_1 * lado_2 # Resultado que devolvemos en modo lista ya que devolvemos # varios argumentos a la vez (podemos dar a cada elemento # de la lista con un nombre que nos permita identificarlo) return(list(&quot;area&quot; = area, &quot;lado_1&quot; = lado_1, &quot;lado_2&quot; = lado_2)) } Veamos que nos devuelve ahora calcular_area(5, 3) ## $area ## [1] 15 ## ## $lado_1 ## [1] 5 ## ## $lado_2 ## [1] 3 F√≠jate que puedes guardar la salida de forma conjunta para luego acceder a solo uno de los elementos de la lista de salida. x &lt;- calcular_area(5, 3) x$area ## [1] 15 x$lado_1 ## [1] 5 x$lado_2 ## [1] 3 Antes nos daba igual el orden de los argumentos pero ahora no, ya que en la salida incluimos lado_1 y lado_2. Es altamente recomendable hacer la llamada a la funci√≥n indicando expl√≠citamente los argumentos argumento_1 = valor_1 para mejorar la legibilidad e interpretabilidad de nuestro c√≥digo (recuerda: programa como escribir√≠as una novela). calcular_area(lado_1 = 5, lado_2 = 3) ## $area ## [1] 15 ## ## $lado_1 ## [1] 5 ## ## $lado_2 ## [1] 3 "],["segunda-funci√≥n.html", "9.2 Segunda funci√≥n", " 9.2 Segunda funci√≥n Vayamos con un ejemplo m√°s complejo. Imaginemos que en nuestro c√≥digo vamos a tener calcular, para cada d√≠a, el n√∫mero de vacunas diarias administradas, el n√∫mero de vacunas administradas en los √∫ltimos 7 d√≠as y el n√∫mero de vacunadas administradas en los √∫ltimos 14 d√≠as, usando tan solo el n√∫mero de vacunadas acumuladas. Para ello vamos a usar la funci√≥n diff() que nos calcula las diferencias de un vector dado. x &lt;- c(1, 2, 3, 7, 10, 15, 20, 50, 100, 250, 600, 1200) diff(x) # vector con [elemento2 - elemento1, elemento3 - elemento2, elemento4 - elemento3, ...] ## [1] 1 1 4 3 5 5 30 50 150 350 600 diff(x, 3) # vector con [elemento4 - elemento1, elemento5 - elemento2, elemento6 - elemento3, ...] ## [1] 6 8 12 13 40 85 230 550 1100 diff(x, 7) # vector con [elemento8 - elemento1, elemento9 - elemento2, elemento10 - elemento3, ...] ## [1] 49 98 247 593 1190 # Para Espa√±a casos_diarios &lt;- diff(panel_vacunas$ES$personas_vacunadas) casos_7D &lt;- diff(panel_vacunas$ES$personas_vacunadas, 7) # diferencias a 7 d√≠as casos_14D &lt;- diff(panel_vacunas$ES$personas_vacunadas, 14) # diferencias a 14 d√≠as # Para Andaluc√≠a casos_diarios &lt;- diff(panel_vacunas$AN$personas_vacunadas) casos_7D &lt;- diff(panel_vacunas$AN$personas_vacunadas, 7) # diferencias a 7 d√≠as casos_14D &lt;- diff(panel_vacunas$AN$personas_vacunadas, 14) # diferencias a 14 d√≠as # ... ¬øCu√°nto ocupar√≠a realizar esta misma tarea para cada comunidad, y cada variable? ¬øPor qu√© no la automatizamos? datos_acumulados &lt;- function(variable_acumulada, dias_dif = c(1, 7, 14)) { # Dentro de las llaves el cuerpo de la funci√≥n acumulados_diferenciales &lt;- NULL for (i in dias_dif) { # Vamos calculando tantos acumulados diferenciales como le hayamos pasado por el argumento dias_dif # A lo que ten√≠amos, le concatenamos por columnas uno nuevo acumulados_diferenciales &lt;- c(acumulados_diferenciales, rev(diff(variable_acumulada, i))[1]) } # La salida de la funci√≥n return(acumulados_diferenciales) } Como vemos, los argumentos pueden ser cualquier tipo de variable, y nos permite adem√°s generalizar y automatizar una tarea para que pueda ser usada incluso en alg√∫n escenario para el que no tuvi√©ramos previsto (acumulados a ‚Ä¶ 13 d√≠as, por ejemplo). Para que nuestra funci√≥n sea realmente √∫til debemos intentar asignar nombres de funciones y argumentos lo m√°s concisos posibles y evidentes en su interpretaci√≥n. datos_acumulados(panel_vacunas$ES$personas_vacunadas) ## [1] 263914 1403809 3246147 datos_acumulados(panel_vacunas$AN$personas_vacunadas) ## [1] 59583 235051 537727 datos_acumulados(panel_vacunas$ES$personas_vacunadas, dias_dif = c(1, 3, 13, 21)) ## [1] 263914 816950 3073866 4779568 F√≠jate que hemos devuelto solo el √∫ltimo acumulado (hemos dado la vuelta al vector resultante y nos hemos quedado con el primer elemento). Para hacer que la salida sea m√°s interpretable, muchas de las funciones en R tienen como salida una lista, con unos nombres asignados. datos_acumulados &lt;- function(variable_acumulada) { # Datos dato_diario &lt;- diff(variable_acumulada) dato_7D &lt;- diff(variable_acumulada, 7) dato_14D &lt;- diff(variable_acumulada, 14) # La salida de la funci√≥n como una lista, con 3 vectores return(list(&quot;diario&quot; = dato_diario, &quot;7D&quot; = dato_7D, &quot;14D&quot; = dato_14D)) } datos_salida &lt;- datos_acumulados(panel_vacunas$ES$personas_vacunadas) names(datos_salida) ## [1] &quot;diario&quot; &quot;7D&quot; &quot;14D&quot; datos_salida ## $diario ## [1] 33992 33992 70653 42705 42705 42705 81950 93597 94548 92764 ## [11] 42226 42225 42226 61129 53539 43950 43124 17175 17176 17175 ## [21] 18624 15876 19464 19464 9682 9682 9682 3166 11265 13420 ## [31] 26031 4458 4459 4458 9833 15107 33663 45331 22986 22985 ## [41] 22986 36073 43687 66918 126790 42768 42769 42768 63596 106609 ## [51] 140881 157476 68588 68589 68588 74417 130284 147861 208913 66537 ## [61] 66537 66537 107709 105255 127181 100675 60566 60566 60566 62460 ## [71] 38789 54080 26122 26123 26123 26122 41558 91262 103674 113995 ## [81] 135234 135233 135234 125305 221541 231064 81155 81155 91719 91719 ## [91] 227822 297306 375063 368637 172281 172282 172281 261006 313321 380661 ## [101] 370506 146544 146543 146544 147228 297290 255746 263914 ## ## $`7D` ## [1] 348702 408307 468863 490974 490495 490015 489536 468715 428657 ## [10] 378059 328419 303368 278319 253268 210763 173100 148614 124954 ## [19] 117461 109967 102474 87016 82405 76361 82928 77704 72481 ## [28] 67257 73924 77766 98009 117309 135837 154363 172891 199131 ## [37] 227711 260966 342425 362207 381991 401773 429296 492218 566181 ## [46] 596867 622687 648507 674327 685148 708823 715803 767240 765189 ## [55] 763137 761086 794378 769349 748669 640431 634460 628489 622518 ## [64] 577269 510803 437702 363149 328706 294263 259819 238917 291390 ## [73] 340984 428857 537968 647078 756190 839937 970216 1097606 1064766 ## [82] 1010687 967173 923658 1026175 1101940 1245939 1533421 1624547 1705110 ## [91] 1785672 1818856 1834871 1840469 1842338 1816601 1790862 1765125 1651347 ## [100] 1635316 1510401 1403809 ## ## $`14D` ## [1] 817417 836964 846922 819393 793863 768334 742804 679478 601757 ## [10] 526673 453373 420829 388286 355742 297779 255505 224975 207882 ## [19] 195165 182448 169731 160940 160171 174370 200237 213541 226844 ## [28] 240148 273055 305477 358975 459734 498044 536354 574664 628427 ## [37] 719929 827147 939292 984894 1030498 1076100 1114444 1201041 1281984 ## [46] 1364107 1387876 1411644 1435413 1479526 1478172 1464472 1407671 1399649 ## [55] 1391626 1383604 1371647 1280152 1186371 1003580 963166 922752 882337 ## [64] 816186 802193 778686 792006 866674 941341 1016009 1078854 1261606 ## [73] 1438590 1493623 1548655 1614251 1679848 1866112 2072156 2343545 2598187 ## [82] 2635234 2672283 2709330 2845031 2936811 3086408 3375759 3441148 3495972 ## [91] 3550797 3470203 3470187 3350870 3246147 "],["variables-localesglobales.html", "9.3 Variables locales/globales", " 9.3 Variables locales/globales Hemos dicho que ¬´lo local se queda en lo local¬ª, ¬øpero qu√© sucede si nombramos a una variable dentro de una funci√≥n que se nos ha olvidado asignar un valor dentro de la misma? Debemos ser cautos al usar funciones en R, ya que debido a la ¬´regla lexicogr√°fica¬ª, si una variable no se define dentro de la funci√≥n, R buscar√° dicha variable en el entorno de variable. x &lt;- 1 funcion_ejemplo &lt;- function() { print(x) # No devuelve nada per se, solo realiza la acci√≥n de imprimir en consola } funcion_ejemplo() ## [1] 1 Si una variable ya est√° definida fuera de la funci√≥n (entorno global), y adem√°s es usada dentro de la misma cambiando su valor, el valor de dicha variable solo cambia dentro de la funci√≥n pero no en el entorno global. x &lt;- 1 funcion_ejemplo &lt;- function() { x &lt;- 2 print(x) # lo que vale dentro } funcion_ejemplo() # lo que vale dentro ## [1] 2 print(x) # lo que vale fuera ## [1] 1 Si queremos que adem√°s de cambiar localmente lo haga globalmente deberemos usar la doble asignaci√≥n (&lt;&lt;-). x &lt;- 1 y &lt;- 2 funcion_ejemplo &lt;- function() { x &lt;- 3 # no cambia globalmente, solo localmente y &lt;&lt;- 0 # cambia globalmente print(x) print(y) } funcion_ejemplo() # lo que vale dentro ## [1] 3 ## [1] 0 x # lo que vale fuera ## [1] 1 y # lo que vale fuera ## [1] 0 "],["ejercicios-4.html", "9.4 üìù Ejercicios", " 9.4 üìù Ejercicios Ejercicio 1: define una funci√≥n propia llamada pares que, dados dos n√∫meros x e y, nos diga si la suma de ambos es par o no. Soluci√≥n: # Definimos funci√≥n pares &lt;- function(x, y) { # Sumamos suma &lt;- x + y # Comprobamos si es par calculando el resto al dividir entre 2: si al dividir suma entre 2 el resto es 0 ==&gt; es par par &lt;- suma %% 2 == 0 # Devolvemos la salida return(par) } # Aplicamos la funci√≥n pares(1, 3) ## [1] TRUE pares(1, 0) ## [1] FALSE pares(2, 6) ## [1] TRUE pares(2, 7) ## [1] FALSE Tambi√©n se puede definir directamente como # Definimos funci√≥n pares &lt;- function(x, y) { # Devolvemos la salida return((x + y) %% 2 == 0) } pares(1, 3) ## [1] TRUE pares(1, 0) ## [1] FALSE pares(2, 6) ## [1] TRUE pares(2, 7) ## [1] FALSE Ejercicio 2: define una funci√≥n propia llamada proximo_par que, dados un n√∫mero x, nos diga si es par y, en aso de no serlo, nos devuelva el pr√≥ximo n√∫mero que si lo sea. Soluci√≥n: # Definimos funci√≥n proximo_par &lt;- function(x) { # ¬øpar? TRUE/FALSE par &lt;- (x %% 2) == 0 # Si es par, devolvemos el propio n√∫mero (era par), sino le sumamos uno if (par) { return(list(&quot;par&quot; = par, &quot;proximo&quot; = x)) } else { # Si no es par, devolvemos el siguiente (que ser√° par) return(list(&quot;par&quot; = par, &quot;proximo&quot; = x + 1)) } # Devolvemos una lista de dos elementos: par (TRUE/FALSE) y proximo (si es par, el propio x, sino x + 1) } # Aplicamos la funci√≥n proximo_par(7) ## $par ## [1] FALSE ## ## $proximo ## [1] 8 proximo_par(8) ## $par ## [1] TRUE ## ## $proximo ## [1] 8 "],["qu√©-sabemos-hacer.html", "Cap√≠tulo 10 ¬øQu√© sabemos hacer?", " Cap√≠tulo 10 ¬øQu√© sabemos hacer? Hasta aqu√≠ el aperitivo Quiz√°s creas que te queda un mundo por aprender: ¬øC√≥mo manejo datos (filtrar, operar con ellos, etc)? ¬øC√≥mo realizo an√°lisis estad√≠sticos? ¬øC√≥mo visualizo datos? ¬øC√≥mo generar informes con los resultados (ver (Xie 2015))? ¬øC√≥mo crear webs interactivas para la visualizaci√≥n y an√°lisis de datos? No te voy a mentir: no tendr√≠as d√≠as de tu vida para ir investigando todos los paquetes que hay hechos en R. Pero la idea de estos primeros cap√≠tulos no era que fueses experto en R sino que vieses que con pocas l√≠neas de c√≥digo y con cierta pr√°ctica se puede empezar a tener herramientas para comenzar nuestra andadura en el an√°lisis estad√≠stico a trav√©s de este software. No te obsesiones con saberte todos los comandos de todos los paquetes o acabar√°s loco/a. Imagen/gr√°fica 10.1: Cuando intentas aprenderte todos los paquetes. Estos primeros cap√≠tulos suelen ser un poco ¬´aburridos¬ª Si sabes programar, te habr√°n parecido triviales (m√°s all√° de conocer la sintaxis propia de R). Si no sab√≠as programar, han sido de repente un pu√±ado de conceptos y cosas a recordar, que hasta que nos los vayas practicando tendr√°s que acudir a este manual (u otros recursos). No te obsesiones con memorizar: yo consulto cada d√≠a cosas que aparecen en este tutorial porque se me olvidan. Lo importante es entender, no memorizar comandos Pero aunque sean m√°s aburridos estos primeros conceptos, son necesarios para empezar a caminar: el inicio de aprender un idioma siempre es un poco meh, pero sin las reglas b√°sicas de gram√°tica y un m√≠nimo de l√©xico nunca podr√°s empezar. Bibliograf√≠a "],["aleatorio_1.html", "10.1 Incursi√≥n aleatoria", " 10.1 Incursi√≥n aleatoria Antes de acabar esta breve introducci√≥n a R merece la pena hablar de ¬´lo aleatorio¬ª y su generaci√≥n en R. ¬øC√≥mo se define la aleatoriedad? Si alguna vez has interactuado con matem√°ticos o estad√≠sticos (Dios te libre), seguramente es una palabra que les hayas escuchado mentar: aleatoriedad. Existen m√∫ltiples definiciones, y este manual tampoco pretende ser un tratado de filosof√≠a de la ciencia, pero podemos definir la aleatoriedad de la siguiente manera: Aleatoriedad: propiedad de todo proceso cuyo resultado final no se puede conocer con exactitud - a nivel individual o particular - antes de que se realice, aunque las condiciones iniciales se mantengan constantes (ejemplo: lanzar un dado). ¬øQu√© NO significa la palabra ¬´aleatorio¬ª? üõë NO tiene que implicar algo ca√≥tico. üõë NO significa que no se pueda predecir a nivel de conjunto. üõë NO significa que carezca de un patr√≥n de comportamiento. El ejemplo perfecto para entender las implicaciones de algo aleatorio es un dado, ya que no podemos saber con exactitud cu√°l ser√° la siguiente tirada, pero tiene un patr√≥n: si tiramos un mill√≥n de veces, aproximadamente un sexto del total de tiradas ser√°n un 1. En el an√°lisis estad√≠stico y en la programaci√≥n en R nos vamos a encontrar con m√∫ltiples situaciones en las que lo aleatorio juega un papel importante, y aunque este sea un tutorial muy b√°sico e introductorio, creo que es interesante conocer algunas formas muy sencillas de generar n√∫meros aleatorios (o‚Ä¶no tanto, ahora llegamos a la Secci√≥n 10.1.1). Empecemos por lo m√°s simple: vamos a simular tiradas de una moneda, asumiendo que solo tenemos dos opciones (eliminando la opci√≥n de caer de canto). Cuando tiramos una moneda es un experimento aleatorio, ya que no sabemos el resultado exacto de la siguiente tirada, pero s√≠ sabemos que la probabilidad te√≥rica es de 50-50, y que las √∫nicas opciones a elegir son cara y cruz. Una forma de ver el experimento de lanzar una moneda es pensar que tenemos una urna con dos bolas (cara y cruz), y empezamos a sacar bolas de la urna (permitiendo que al sacar una bola, se pueda devolver a la urna de nuevo). Eso es precisamente lo que hace la funci√≥n sample(), una funci√≥n que nos seleccionar√° ¬´aleatoriamente¬ª elementos de una urna. x: los elementos distintos que tiene para elegir, que en nuestro caso ser√°n &quot;cara&quot; y &quot;cruz&quot;. size: el n√∫mero de bolas que queremos sacar de la urna. replace: si tras extraer devolvemos la bola a la urna (replace = TRUE) o si se queda fuera (replace = FALSE, valor por defecto). prob: la probabilidad que tiene cada elemento en caso de no ser equiprobables (valor por defecto). # Tiramos 20 veces una moneda sample(x = c(&quot;cara&quot;, &quot;cruz&quot;), size = 20, replace = TRUE) ## [1] &quot;cruz&quot; &quot;cruz&quot; &quot;cruz&quot; &quot;cruz&quot; &quot;cruz&quot; &quot;cruz&quot; &quot;cruz&quot; &quot;cruz&quot; &quot;cruz&quot; &quot;cara&quot; ## [11] &quot;cara&quot; &quot;cara&quot; &quot;cara&quot; &quot;cara&quot; &quot;cara&quot; &quot;cara&quot; &quot;cara&quot; &quot;cruz&quot; &quot;cara&quot; &quot;cruz&quot; F√≠jate que hemos indicado expl√≠citamente replace = TRUE para decirle que aunque solo tengamos dos opciones, vamos a permitir que tras extraer una bola, la apuntemos, y la volvamos a introducir (puede salir de nuevo). ¬øQu√© sucede si replace = FALSE (su valor por defecto)? # Tiramos 20 veces una moneda SIN reemplazamiento sample(x = c(&quot;cara&quot;, &quot;cruz&quot;), size = 20) ## Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when &#39;replace = FALSE&#39; Al tener solo dos opciones, y no permitir que al extraer bolas vuelvan a la urna, tras extraer las dos √∫nicas bolas, el proceso no puede continuar hasta los 20 lanzamientos. Como seguramente te hayas percatado, lanzar una moneda es un experimento dicot√≥mico, y dichos experimentos tienen una gran ventaja en programaci√≥n y es que podemos escribirlo en binario: 0 para lo que llamemos fracaso (cara, por ejemplo), 1 para lo que llamemos √©xito (cruz). Generar experimentos dicot√≥micos de forma binario nos permite hacer c√°lculos sobre las tiradas de forma muy sencilla e intuitiva, ya que nos permite pasar de tener cadenas de texto a n√∫meros. # Tiramos 50 veces una moneda: 0 es cara, 1 es cruz n_tiradas &lt;- 50 tiradas &lt;- sample(x = 0:1, size = n_tiradas, replace = TRUE) tiradas ## [1] 1 0 1 0 1 0 0 1 1 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 1 0 1 0 ## [39] 1 0 1 1 0 1 0 0 0 0 1 1 # Cantidad de cruces: sumamos los 1&#39;s sum(tiradas) ## [1] 22 # Cantidad de caras: lo que son cruces n_tiradas - sum(tiradas) ## [1] 28 # % de caras cat(paste0(100 * sum(tiradas) / n_tiradas, &quot;% de cruces&quot;)) ## 44% de cruces El argumento prob = ... nos permite generar experimentos que sean dicot√≥micos pero que no sean equiprobables, algo similar a lanzar una moneda trucada (por ejemplo, 30% caras y 70% cruces). N√≥tese como dichas probabilidades deben ser introducidas como proporciones (divididas entre 100). # Tiradas de una moneda trucada tiradas &lt;- sample(x = 0:1, size = n_tiradas, replace = TRUE, prob = c(0.3, 0.7)) # % de caras cat(paste0(100 * sum(tiradas) / n_tiradas, &quot;% de cruces&quot;)) ## 76% de cruces üìùEjercicio: ¬øc√≥mo simular√≠as 200 tiradas de un dado? Soluci√≥n: # Lo √∫nico que cambia son las opciones en la urna sample(x = 1:6, size = 200, replace = TRUE) ## [1] 5 3 2 6 5 4 4 4 6 4 3 6 5 5 2 6 6 5 2 5 5 3 5 6 4 1 1 1 2 2 4 6 2 4 4 4 3 ## [38] 6 5 6 1 5 4 6 4 5 1 5 3 5 4 4 1 4 1 1 1 3 6 5 6 6 5 4 2 4 6 3 2 1 5 2 1 6 ## [75] 1 1 1 5 5 3 1 5 1 1 4 5 5 5 3 5 5 4 4 6 1 4 4 6 5 6 6 1 2 5 4 6 4 1 2 2 6 ## [112] 1 1 1 2 2 5 5 5 6 3 6 3 4 6 2 2 3 3 4 6 6 4 2 2 1 5 6 2 3 2 6 5 1 5 5 6 1 ## [149] 2 5 5 6 5 3 4 5 3 6 2 5 5 5 4 5 6 5 1 2 3 3 3 6 5 6 1 4 3 4 4 1 6 2 6 2 1 ## [186] 5 2 6 1 6 5 1 3 2 3 6 4 2 6 4 10.1.1 Pseudoaleatoriedad Si has hecho varias pruebas con los c√≥digos de arriba quiz√°s ya hayas visto que cada vez que lanzas el c√≥digo, el resultado es distinto, algo similar a lo que suceder√≠a si lanzas una moneda. Prueba a ejecutar este c√≥digo varias veces. sample(0:1, size = 20, replace = TRUE) ## [1] 0 0 0 1 0 1 0 0 1 1 1 1 1 1 0 1 0 1 0 0 sample(0:1, size = 20, replace = TRUE) ## [1] 0 1 1 0 1 0 0 0 0 1 1 1 1 0 0 1 0 1 0 1 sample(0:1, size = 20, replace = TRUE) ## [1] 1 0 0 0 0 0 0 1 0 0 0 0 1 1 1 1 0 0 0 1 ¬øY si quisi√©ramos generar toda la clase la misma tirada de moneda? Lo primero que quiz√°s pienses es que es imposible, ya que al tirar una moneda en la vida real, nunca vamos a tener forma de garantizar que salgan las mismas tiradas a diferentes personas. Y efectivamente eso ser√≠a cierto si nuestros procesos generados hubiesen sido aleatorios, como en la vida real pero‚Ä¶no lo son. Mientras esperamos a que lleguen al mainstream los ordenadores cu√°nticos, TODO lo que hay en tu ordenador es determ√≠nistico, ya que cualquier proceso se reduce a una secuencia de bits (0's y 1's) y un algoritmo (sin azar, cuyo resultado siempre ser√° el mismo bajo las mismas condiciones iniciales). He aqu√≠ la decepci√≥n de tu vida: un ordenador ¬´normal¬ª NO puede generar procesos aleatorios, sino procesos y n√∫meros PSEUDOALEATORIOS, basados en cadenas pseudoaleatorias generadas por un algoritmo determin√≠stico. Dichas secuencias aparentan ser aleatorias pero no lo son, y de hecho muchas son peri√≥dicas: si generamos el n√∫mero suficiente de elementos de la cadena pseudoaleatoria volveremos al inicio. Muchos de los algoritmos disponibles para generar n√∫meros aleatorios dependen, entre otros factores, de un valor inicial llamada semilla (normalmente obtenida a partir del reloj interno del ordenador): misma semilla, mismo resultado ¬´aleatorio¬ª. Para fijar la semilla usaremos set.seed(), pas√°ndole como argumento una secuencia de n√∫meros (todos la misma). set.seed(1234567) sample(0:1, size = 20, replace = TRUE) ## [1] 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 0 1 1 1 0 set.seed(1234567) sample(0:1, size = 20, replace = TRUE) ## [1] 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 0 1 1 1 0 set.seed(1234567) sample(0:1, size = 20, replace = TRUE) ## [1] 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 0 1 1 1 0 Siempre la misma tirada si la semilla inicial es la misma ya que las cadenas pseudoaleatorias que usa el ordenador para simular nuestras tiradas son id√©nticas. "],["recursos.html", "10.2 Recursos", " 10.2 Recursos Ahora que ya sabes lo b√°sico para poder empezar a trabajar en un entorno amigable, aunque la idea es que este manual tenga m√°s cap√≠tulos (¬ølos tiene?) para seguir avanzando, por si se me olvida, te dejo una lista de recursos √∫tiles para que puedas ir viendo el abanico de opciones que tienes C√≥digo de este manual: este manual est√° programado en s√≠ mismo en R y los c√≥digos pueden ser consultados libremente en el respositorio de GitHub (hablaremos m√°s adelante de como gestionar versiones de nuestro c√≥digo en dicha plataforma). Big Book of R: recopilatorio de tutoriales de R en distintos campos. Incursi√≥n a los modelos de regresi√≥n en R: manual sobre el uso de distintos modelos predictivos basados los Modelos Lineales Generalizados (GLM). Paquete para aprender R: el paquete {swirl} permite ir aprendiendo de forma sencilla (con preguntas tipo test) algunos conceptos b√°sicos de R (muchos de ellos vistos en este manual). Puedes consultar la documentaci√≥n en su p√°gina web Manejo de datos: probablemente el conjunto de herramientas m√°s usadas en R sean los paquetes agrupados en {tidyverse} (y que veremos en cap√≠tulos sucesivos si los hubiese), un conjunto de paquetes integrados para un manejo intuitivo de los datos, tanto en su preprocesamiento, como en la generaci√≥n de estad√≠sticas y gr√°ficas. Tidyverse cookbook Tidyverse skills for data science Visualizaci√≥n de datos en Twitter: una de las fortalezas de R es su versatilidad para la visualizaci√≥n de datos. Y al igual que un escritor necesita leer mucho para tomar ideas, hay dos recursos en Twitter que te recomiendo encarecidamente: El hashtag #TidyTuesday es una etiqueta en la que cada semana se plantea el reto de proponer la mejor visualizaci√≥n para un conjunto de datos dado, donde no solo puedes participar con la comunidad sino ver las visualizaciones de otros usuarios de R. Adem√°s he elaborado una lista de Twitter de usuarios que se dedican a la visualizaci√≥n de datos. Paquetes para la visualizaci√≥n de datos: los paquetes {ggplot2} y {plotly} son probablemente los paquetes por excelencia en R para la visualizaci√≥n de datos. El primero es uno de los paquetes m√°s potentes de R, dentro del entorno {tidyverse}, que no solo nos permite crear gr√°ficos muy limpios y elegantes con pocas l√≠neas sino que su sintaxis es muy intuitiva respecto a los datos visualizados. La idea inicial es poder aprender algo de {ggplot2} en futuros cap√≠tulos pero puedes empezar si quieres echando un vistazo a su web oficial. Tambi√©n te recomiendo el tutorial de C√©dric Scherer. El segundo paquete, {plotly} puede llegar a tener las mismas funcionalidades pero su programaci√≥n es m√°s tediosa. Su principal ventaja es que genera gr√°ficos interactivos: gr√°ficos HTML (como si fuera una p√°gina web) (no una imagen est√°tica) que permite al usuario interactuar con los datos pasando el rat√≥n (incluso permite crear men√∫s). Un ejemplo es la web de visualizaci√≥n covid de Asturias que elabor√© durante la pandemia para el Gobierno de Asturias (la web en s√≠ est√° elaborada con {shiny}, un paquete de R que permite crear aplicaciones web). Generaci√≥n de informes desde R: el paquete {rmarkdown} permite generar directamente informes que mezclen texto, f√≥rmulas matem√°ticas, gr√°ficas y c√≥digo R (como este mismo manual), sin necesidad de importarlos a otras herramientas de Office. Comunidad de R hispano: tenemos un grupo de Discord y grupo de Telegram varios usuarios de R en Espa√±a para compartir recursos. "],["bibliograf√≠a.html", "Bibliograf√≠a", " Bibliograf√≠a "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
